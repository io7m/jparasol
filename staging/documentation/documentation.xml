<?xml version="1.0" encoding="UTF-8"?>

<!--
  Copyright © 2014 <code@io7m.com> http://io7m.com

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  -->

<s:document
  xmlns:s="http://schemas.io7m.com/structural/2.1.0"
  xmlns:xi="http://www.w3.org/2001/XInclude">
  <s:document-title>io7m-jparasol 0.11.3 Documentation</s:document-title>
  <s:document-style>documentation.css</s:document-style>
  <s:document-contents/>

  <s:part>
    <s:part-title>Package Information</s:part-title>
    <s:part-contents />
    <s:section>
      <s:section-title>Orientation</s:section-title>
      <s:subsection>
        <s:subsection-title>Overview</s:subsection-title>
        <s:paragraph>
          The <s:term s:type="package">io7m-jparasol</s:term> package 
          implements a minimalist pure functional shading language.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section>
      <s:section-title>Installation</s:section-title>
      <s:subsection>
        <s:subsection-title>Source compilation</s:subsection-title>
        <s:paragraph>
          The project can be compiled and installed with
          <s:link-external s:target="http://maven.apache.org">Maven</s:link-external>:
        </s:paragraph>
        <s:paragraph>
          <s:verbatim s:type="example"><![CDATA[$ mvn -C clean install]]></s:verbatim>
        </s:paragraph>
      </s:subsection>

      <s:subsection>
        <s:subsection-title>Maven</s:subsection-title>
        <s:paragraph>
          Regular releases are made to the
          <s:link-external s:target="http://search.maven.org/#search%7Cga%7C1%7Cio7m-jparasol">Central Repository</s:link-external>,
          so it's possible to use the <s:term s:type="package">io7m-jparasol</s:term>
          package in your projects with the following Maven dependency:
        </s:paragraph>
        <s:paragraph>
          <s:verbatim s:type="example"><![CDATA[<dependency>
  <groupId>com.io7m.jparasol</groupId>
  <artifactId>io7m-jparasol-core</artifactId>
  <version>0.11.3</version>
</dependency>]]></s:verbatim>
        </s:paragraph>
        <s:paragraph>
          All <s:link-external s:target="http://io7m.com">io7m.com</s:link-external>
          packages use Semantic Versioning
          <s:footnote>
            <s:link-external s:target="http://semver.org">http://semver.org</s:link-external>
          </s:footnote>, which implies that it is always safe to use version ranges
          with an exclusive upper bound equal to the next major version - the API of
          the package will not change in a backwards-incompatible manner before the
          next major version.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section>
      <s:section-title>Platform Specific Issues</s:section-title>
      <s:paragraph>
        There are currently no known platform-specific issues.
      </s:paragraph>
    </s:section>

    <s:section>
      <s:section-title>License</s:section-title>
      <s:paragraph>
        All files distributed with the <s:term s:type="package">io7m-jparasol</s:term>
        package are placed under the following license:
        <s:verbatim s:type="license"><![CDATA[Copyright © 2014 <code@io7m.com> http://io7m.com

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.]]>
        </s:verbatim>
      </s:paragraph>
    </s:section>
  </s:part>

  <s:part>
    <s:part-title>Language Tutorial</s:part-title>
    <s:part-contents/>

    <s:section>
      <s:section-title>Prerequisites</s:section-title>
      <s:paragraph>
        The <s:term s:type="package">parasol</s:term> compiler is implemented
        as a set of APIs with a simple command-line frontend. The frontend
        is packaged into a convenient 
        <s:link-external s:target="http://mvn-repository.io7m.com//com/io7m/jparasol/io7m-jparasol-compiler-frontend/0.11.3/io7m-jparasol-compiler-frontend-0.11.3-jparasol-c.jar">executable jar</s:link-external>
        containing all of the compiler's dependencies. The jar file can
        be executed in the usual manner:
      </s:paragraph>
      <s:formal-item s:kind="example">
        <s:formal-item-title>Compiler example</s:formal-item-title>
        <s:verbatim><![CDATA[$ java -jar io7m-jparasol-compiler-frontend-0.11.3-jparasol-c.jar
parasol-c: [options] --compile-one output shader file0 [file1 ... fileN]
        or [options] --compile-batch output batch-list source-list
        or [options] --check file0 [file1 ... fileN]
        or [options] --show-glsl-versions
        or [options] --version

  Where: output           is a directory (unless --zip is specified) that will be populated with GLSL shaders
         shader           is the fully-qualified name of a shading program
         batch-list       is a file containing (output , ':' , shader) tuples, separated by newlines
         source-list      is a file containing a set of filenames, separated by newlines
         file[0 .. N]     is a series of filenames containing source code

     --check                            Parse and type-check all source files, but do not produce GLSL source
     --compact                          Enable compaction (eliminates duplicate source files)
     --compile-batch                    Produce multiple GLSL programs from a set of sources
     --compile-one                      Compile a specific shader program to GLSL source
  -h,--help                             Show this help message
     --log-properties <properties>      Configure logging based on the given property file
     --log-stack-traces                 Enable logging of exception stack traces
     --require-glsl <version-set>       Require GLSL source code for the given set of GLSL versions, failing if any of
                                        the versions cannot be satisfied
     --require-glsl-es <version-set>    Require GLSL ES source code for the given set of GLSL ES versions, failing if
                                        any of the versions cannot be satisfied
     --show-glsl-versions               Show the available GLSL versions
     --threads <count>                  Set the number of threads to use during code generation
     --version                          Display compiler version
     --zip                              Write shaders to a zip archive instead of a directory

   Where: version-set     := version-segment ( ',' version-segment )*
          version-segment := version-exact | version-range
          version-exact   := integer
          version-range   := ('(' | '[') integer? ',' integer? (')' | ']')

     Where '[' and ']' denote inclusive bounds, and '(' ')' denote exclusive bounds.

     Example: 130 selects version 130
     Example: [120, 150] selects versions 120 to 150
     Example: (120, 150] selects versions 130 to 150
     Example: 120,[140,330],440 selects versions 120, 140, 150, 330, and 440

  Version: 0.11.3]]></s:verbatim>
      </s:formal-item>
      <s:paragraph>
        The name of the <s:term s:type="file">io7m-jparasol-compiler-frontend-0.11.3-jparasol-c.jar</s:term> file
        is actually selected by Maven. For the sake of brevity, it is assumed that the user
        has renamed this file to <s:term s:type="file">jparasol-c.jar</s:term> for this
        tutorial.
      </s:paragraph>
      <s:paragraph>
        The programmer is expected to be familiar enough with GLSL to
        dislike the language.
      </s:paragraph>
    </s:section>

    <s:section>
      <s:section-title>Why?</s:section-title>
      <s:subsection>
        <s:subsection-title>Versioning</s:subsection-title>
        <s:paragraph>
          GLSL is a versioning and compatibility nightmare: There are, at the 
          time of writing, fourteen different versions of GLSL in use. The 
          versions of OpenGL and GLSL available are tied to hardware and to 
          OpenGL drivers. Different versions of GLSL differ wildly in syntax 
          and in the names of functions defined in the standard library. The 
          same program may have to be rewritten five or six times to deal 
          with trivial syntax differences between versions. The standard
          recommendation is for programs to explicitly mark the version of
          GLSL for which they're intended by including a 
          <s:term s:type="keyword">#version</s:term> directive at the start
          of the file. Without this directive, many GLSL implementations
          fall back to using the oldest available version, which then typically
          means that the compiler rejects the program as invalid. With a
          <s:term s:type="keyword">#version</s:term> directive included, the
          programmer is asserting that he/she wishes to use a specific version
          which, of course, may not be available. Certain versions of OpenGL
          (such as OpenGL ES 2), place arbitrary restrictions on programs
          (such as not being able to declare multiple fragment shader outputs).
        </s:paragraph>
        <s:paragraph>
          Most programmers attempt to work around these problems by layering
          on hacks and preprocessor macros. This is obviously unacceptable to
          programmers that actually care about correctness.
        </s:paragraph>
      </s:subsection>

      <s:subsection>
        <s:subsection-title>Correctness</s:subsection-title>
        <s:paragraph>
          GLSL is a nightmare from the perspective of correctness: Programs
          are parsed and type-checked at runtime. The commitee that mismanages 
          OpenGL decided that all OpenGL drivers should implement their own compilers. 
          Apart from the inevitable correctness issues that stem from this requirement, 
          this also means that errors that should be entirely statically detectable 
          are signalled at the latest possible stage (run time). Systems that use 
          thousands of GLSL shaders are required to do obscene amounts of 
          testing to ensure that all of their shaders are valid GLSL.
        </s:paragraph>
        <s:paragraph>
          The language, on one hand, requires explicit type conversions. This is
          generally beneficial because there are none of magical implicit type 
          conversions that appear in somewhat more weakly-typed languages. The
          language then works hard to eliminate the beneficial aspects by overloading
          all functions and operators, so that the programmer really has no idea
          which particular overloaded variant is being used <s:footnote>
            This often causes serious performance problems. See
            <s:link-external s:target="http://www.humus.name/Articles/Persson_LowlevelShaderOptimization.pdf">Low-level Thinking in High-Level Shading Language Programs</s:link-external>.
          </s:footnote>.
        </s:paragraph>
        <s:paragraph>
          The language has no module system and simply dumps its entire standard
          library into the same namespace as the programmer's code. The programmer
          must explicitly prefix the names of any defined functions or variables
          in order to avoid potential collisions. The OpenGL committee are free to
          introduce new name collisions at any time.
        </s:paragraph>
        <s:paragraph>
          There are also very limited facilities for inspecting programs that
          have been compiled. For example, the GLSL compiler is free to remove
          any program inputs or parameters that is has deemed to be unused (and
          has therefore optimized out). The programmer using the shading program
          wants to be able to assign values to inputs by name. Unfortunately,
          without the programmer manually parsing the original program, there
          is no way to tell the difference between an input or parameter that
          has been optimized out, and an input or parameter that never existed
          in the first place. There is no way to distinguish between "The compiler
          removed the parameter" and "I got the name of the parameter wrong".
          The GLSL compiler obviously has this information, but
          it is not made available to the programmer. In order to really guarantee
          correctness, it's necessary for the programmer to reimplement parts 
          of the GLSL compiler!
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Modularity and re-use</s:subsection-title>
        <s:paragraph>
          A GLSL shader is represented by a single file. Code that is re-used
          between shaders must either be copied and pasted, or must be inserted
          automatically via some error-prone macro or preprocessor
          system. The GLSL language does not support
          <s:term s:type="keyword">#include</s:term> directives, so the programmer
          is forced to build their own system to manage pieces of shaders.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section>
      <s:section-title>What?</s:section-title>
      <s:subsection>
        <s:subsection-title>Parasol</s:subsection-title>
        <s:paragraph>
          The <s:term s:type="package">Parasol</s:term> language is an aggressively
          minimalist pure-functional shading language. The intention is to provide
          a language with simple and predictable semantics that can then be
          compiled to all possible versions of GLSL, eliminating all of the versioning
          concerns previously expressed. On versions of GLSL that do not provide certain
          functions, the compiler silently provides emulations 
          <s:footnote>
            Consider the <s:term s:type="function">trunc</s:term> function. This
            function is not available on certain versions of GLSL, but is equivalent
            to the expression <s:term s:type="expression">sign(x) * floor(abs(x))</s:term>
            for some <s:term s:type="expression">x</s:term>.
            The compiler can provide a software emulation in this case, allowing the
            programmer to safely call <s:term s:type="package">Parasol</s:term>'s
            <s:term s:type="function">Float.truncate</s:term> function anywhere without
            issue.
          </s:footnote>. Essentially, the programmer provides a
          <s:term s:type="package">Parasol</s:term> program and a range of GLSL versions
          upon which the program is expected to run. The compiler produces GLSL for
          all of the possible versions and will raise errors if a valid program really cannot
          be produced for a particular GLSL version 
          <s:footnote>
            For example, if the programmer writes a fragment shader that writes
            to multiple outputs, there is no way this program can run on OpenGL ES 2
            and there is no way that the compiler can provide any kind of emulation
            to work around the problem.
          </s:footnote>.
        </s:paragraph>
        <s:paragraph>
          The <s:term s:type="package">Parasol</s:term> language is
          both pure-functional and <s:term s:type="term">total</s:term>. That
          is, programs do not have side effects and are guaranteed to
          terminate. The language statically rejects recursive and mutually
          recursive terms, and does not provide looping constructs or
          arrays.
        </s:paragraph>
        <s:paragraph>
          The <s:term s:type="package">Parasol</s:term> language categorically
          rejects operator and function overloading 
          <s:footnote>
            The language actually rejects operators entirely, to keep
            the language definition as simple as possible.
          </s:footnote>; the programmer always knows exactly which function
          is being applied on sight. This eliminates the correctness issues
          caused by pervasive overloading.
        </s:paragraph>
        <s:paragraph>
          The language provides a simple non-hierarchical module and package
          system for controlling the namespace. <s:term s:type="package">Parasol</s:term>
          programs can be developed as sets of re-usable libraries without
          any fear of name collisions. The language works from the assumption
          that, although shader programs are likely to be short and linear, 
          there are also likely to be a large number of them, with significant 
          amounts of duplicated code. The <s:term s:type="package">Parasol</s:term>
          module system allows code to be imported and re-used safely, with full
          type checking and without requiring a complicated and error-prone
          preprocessor.
        </s:paragraph>
        <s:paragraph>
          The <s:term s:type="package">jparasol</s:term> compiler is a strictly
          offline compiler developed in Java. The compiler takes 
          <s:term s:type="package">Parasol</s:term>
          programs as input, and produces GLSL programs (and additional metadata)
          as output. The produced GLSL can then be loaded as normal in any OpenGL program
          and has no dependencies on <s:term s:type="package">Parasol</s:term>,
          the <s:term s:type="package">jparasol</s:term> compiler, or anything else.
          The additional metadata produced as output describes various properties
          of the program. This means that programmers are not required to 
          parse <s:term s:type="package">Parasol</s:term>
          programs to, for example, determine all of the declared inputs, 
          parameters, and outputs. The metadata is an optional component; 
          programmers are not required to use it in order to make use of
          compiled GLSL programs.
        </s:paragraph>
      </s:subsection>

      <s:subsection>
        <s:subsection-title>Limitations</s:subsection-title>
        <s:paragraph>
          The language considers portability and correctness
          to be more important than exposing the latest flashy 
          features of GLSL. The language therefore exposes 
          features roughly analogous
          to version <s:term s:type="constant">1.40</s:term> of
          GLSL in an attempt to provide the subset of OpenGL and
          GLSL that will work on as many implementations as possible. 
          The language does not support geometry shaders
          or tesselation shaders. The language does not support
          double-precision floating point. These features will
          likely be introduced as time moves on and older versions
          of OpenGL disappear into history.
        </s:paragraph>
        <s:paragraph>
          As described, the language is currently <s:term s:type="term">total</s:term>,
          meaning that all programs are guaranteed to terminate. This
          is both a desirable property (because non-terminating shader
          programs are extremely bad news on some OpenGL implementations), and
          a severe limitation (because programs that require loops cannot
          be expressed in <s:term s:type="package">Parasol</s:term>
          at all). In practice, this has not turned out to be much of
          a problem
          <s:footnote>
            It is possible to express all of the shaders required
            to implement a renderer equal in capability to that of
            the
            <s:link-external s:target="http://source.valvesoftware.com">Source</s:link-external>
            engine (circa 2014) without any loops or arrays.
          </s:footnote>. The shading programs found in most
          game engines tend to be linear in nature and do 
          not require iterating over arrays of values.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section>
      <s:section-title>How?</s:section-title>
      <s:subsection>
        <s:subsection-title>Parasol ↔ GLSL</s:subsection-title>
        <s:paragraph>
          The <s:term s:type="package">Parasol</s:term> language
          takes a similar view of the world as a typical GLSL program. That is,
          a <s:term s:type="term">program</s:term> consists of exactly one 
          <s:term s:type="term">vertex shader</s:term>
          and exactly one <s:term s:type="term">fragment shader</s:term>.
        </s:paragraph>
        <s:paragraph>
          In GLSL, the vertex shader is responsible for assigning values to
          a set of declared outputs, and additionally assigning a clip-space
          vertex position to a built-in variable named 
          <s:term s:type="expression">gl_Position</s:term>. 
        </s:paragraph>
        <s:paragraph>
          In <s:term s:type="package">Parasol</s:term>, a vertex shader
          declares a set of inputs, outputs, and parameters. One of the
          outputs is marked as being the <s:term s:type="term">vertex</s:term>
          output, to which the programmer is expected to assign a clip-space
          vertex position. There are no built-in names. Input, output, and
          parameter names in <s:term s:type="package">Parasol</s:term>
          programs will appear exactly as written in the resulting GLSL
          and are therefore subject to the same naming restrictions (and
          this is checked by the compiler).
        </s:paragraph>
        <s:paragraph>
          In early versions
          of GLSL, the fragment shader was responsible for calculating a single
          RGBA colour vector and assigning it to a built-in variable called
          <s:term s:type="expression">gl_FragColor</s:term>. In later versions
          of OpenGL, it became possible to have multiple colour attachments
          to framebuffers, and therefore it became necessary for the fragment
          shader to assign multiple outputs. The <s:term s:type="expression">gl_FragColor</s:term>
          variable was essentially replaced with the
          <s:term s:type="expression">gl_FragData</s:term> variable, which is
          of an array type. In modern OpenGL, the 
          <s:term s:type="expression">gl_FragColor</s:term> and
          <s:term s:type="expression">gl_FragData</s:term> variables have been
          removed, and programmers are required to explicitly declare named
          fragment shader outputs.
        </s:paragraph>
        <s:paragraph>
          In <s:term s:type="package">Parasol</s:term>, a fragment shader
          declares a set of inputs, outputs, and parameters. All of the
          outputs must be named and numbered. This allows the compiler to
          map numbered outputs to the <s:term s:type="expression">gl_FragData</s:term>
          array in early versions of GLSL, and to correctly declare
          named outputs in modern GLSL. The compiler checks that output
          numbers start at <s:term s:type="constant">0</s:term> and
          increase monotonically.
        </s:paragraph>
        <s:paragraph>
          As stated previously, in GLSL a vertex or fragment shader is 
          typically represented by a single file and execution begins 
          at a function called <s:term s:type="expression">main</s:term>.
        </s:paragraph>
        <s:paragraph>
          The <s:term s:type="package">Parasol</s:term> language implements
          a simple module system to promote re-use of code, and all functions,
          types, and shaders must be declared inside of modules. Vertex
          and fragment shaders are declared inside of modules and then
          aggregated into <s:term s:type="term">programs</s:term>. When it
          comes time to produce GLSL, the programmer provides the
          <s:term s:type="term">fully-qualified</s:term> name of a
          declared <s:term s:type="term">program</s:term> and the compiler
          produces a set of GLSL shaders based on the selection.
        </s:paragraph>
      </s:subsection>

      <s:subsection>
        <s:subsection-title>Hello World GLSL</s:subsection-title>
        <s:paragraph>
          A simple GLSL vertex shader in GLSL 1.40 that simply transforms
          the given object-space coordinates to clip-space by multiplying
          by a given modelview and projection matrix:
        </s:paragraph>
        <s:formal-item s:kind="example">
          <s:formal-item-title>Hello World GLSL - Vertex shader</s:formal-item-title>
          <s:verbatim><![CDATA[#version 140

in vec4 v_position;
uniform mat4 m_modelview;
uniform mat4 m_projection;

void
main ()
{
  gl_Position = m_projection * m_modelview * v_position;
}
]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          A simple fragment shader in GLSL 1.40 that declares a colour
          output and assigns a constant red colour to it:
        </s:paragraph>
        <s:formal-item s:kind="example">
          <s:formal-item-title>Hello World GLSL - Fragment shader</s:formal-item-title>
          <s:verbatim><![CDATA[#version 140

out vec4 out_rgba;

void
main ()
{
  out_rgba = vec4 (1.0, 0.0, 0.0, 1.0);
}]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          The programmer then compiles and loads each shader file from the
          OpenGL API, links them, and then uses them.
        </s:paragraph>
      </s:subsection>

      <s:subsection>
        <s:subsection-title>Hello World Parasol</s:subsection-title>
        <s:paragraph>
          As stated, all terms, types, and shaders must be declared in
          modules. For this tutorial, a <s:term s:type="expression">HelloWorld</s:term>
          module suffices, declared in package
          <s:term s:type="expression">com.io7m.examples</s:term>.
        </s:paragraph>
        <s:paragraph>
          The previous GLSL shaders translated to <s:term s:type="package">Parasol</s:term>
          become:
        </s:paragraph>
        <s:formal-item s:kind="example">
          <s:formal-item-title>Hello World Parasol</s:formal-item-title>
          <s:verbatim><![CDATA[package com.io7m.examples;

module HelloWorld is

  import com.io7m.parasol.Matrix4x4f as M4;

  shader vertex v is
    in         v_position   : vector_4f;
    parameter  m_modelview  : matrix_4x4f;
    parameter  m_projection : matrix_4x4f;
    out vertex o            : vector_4f;
  with
    value position_clip =
      M4.multiply_vector (M4.multiply (m_projection, m_modelview), v_position);
  as
    out o = position_clip;
  end;

  shader fragment f is
    out o : vector_4f as 0;
  with
    value red =
      new vector_4f (1.0, 0.0, 0.0, 1.0);
  as
    out o = red;
  end;

  shader program p is
    vertex v;
    fragment f;
  end;

end;]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          The module declares a vertex shader named <s:term s:type="type">v</s:term>,
          a fragment shader named <s:term s:type="type">p</s:term>, and combines the two
          into a program named <s:term s:type="type">p</s:term>. Any number of
          shaders and programs can be declared in a single module (but their names
          must obviously differ).
        </s:paragraph>
        <s:paragraph>
          The vertex shader declares an input <s:term s:type="expression">v_position</s:term>,
          two parameters <s:term s:type="expression">m_modelview</s:term> and
          <s:term s:type="expression">m_projection</s:term>, and an output named
          <s:term s:type="expression">o</s:term> which is marked as the main
          vertex output with the <s:term s:type="expression">vertex</s:term> keyword.
          The shader performs the same multiplication as the GLSL program, assigning
          the result to a local variable named <s:term s:type="expression">position_clip</s:term>.
          Variables in <s:term s:type="package">Parasol</s:term> are immutable
          and the programmer is not required to state the types of values because
          the language features local type inference. Finally, the shader writes
          the calculated value to the output
          <s:term s:type="expression">o</s:term> with an 
          <s:term s:type="term">output assignment</s:term>. The right-hand side of
          an <s:term s:type="term">output assignment</s:term> is required to be
          a name <s:footnote>
            The reason for this is because the GLSL standard has various rules
            about how and when shader outputs must be assigned. <s:term s:type="package">Parasol</s:term>
            language programs <s:term s:type="term">syntactically</s:term> guarantee that either all outputs are
            assigned, or none of them are.
          </s:footnote>. The <s:term s:type="package">Parasol</s:term> compiler
          requires that all outputs be assigned.
        </s:paragraph>
        <s:paragraph>
          Because the language only provides functions and not operators, the order
          of operations is completely unambiguous; the arguments to functions are
          evaluated eagerly from left to right and then substituted into the body
          of the function. Does the multiplication in the GLSL version mean
          <s:term s:type="expression">(p * m) * v</s:term> or
          <s:term s:type="expression">p * (m * v)</s:term>? In this case, it may
          not matter, but what about in more complicated expressions with
          overloading? Programmers get this wrong constantly. The 
          <s:term s:type="package">Parasol</s:term>
          language keeps things explicit - mistakes become difficult to make.
        </s:paragraph>
        <s:paragraph>
          The fragment shader simply declares a value named <s:term s:type="expression">red</s:term>
          and assigns it to the single declared output named <s:term s:type="expression">o</s:term>.
          Note that <s:term s:type="expression">o</s:term> is assigned both a name
          and a number; this is required by the language.
        </s:paragraph>
        <s:paragraph>
          The program <s:term s:type="type">p</s:term> states that it uses
          the vertex shader <s:term s:type="type">v</s:term> and the fragment
          shader <s:term s:type="type">f</s:term>. The compiler will check that
          the programs are <s:term s:type="term">compatible</s:term> when
          <s:term s:type="type">p</s:term> is declared. The rules for
          <s:term s:type="term">compatibility</s:term> are the same as they
          are for GLSL; the vertex shader must have a corresponding output
          with the same name and type as each of the fragment shader's
          inputs.
        </s:paragraph>
        <s:paragraph>
          Assuming that the above is in a file named <s:term s:type="file">HelloWorld.txt</s:term>
          and that the resulting GLSL shaders should be written to a directory
          called <s:term s:type="file">/tmp/shaders</s:term>, the program can be compiled
          as follows:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Compilation</s:formal-item-title>
          <s:verbatim><![CDATA[$ java -jar jparasol-c.jar --compile-one /tmp/shaders com.io7m.examples.HelloWorld.p HelloWorld.txt]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          The compiler says nothing unless an error occurs.
        </s:paragraph>
        <s:paragraph>
          By default, the compiler will attempt to produce GLSL shaders for all
          known versions of GLSL. It will silently fail to produce a program for
          a version that cannot be supported. In the case of the above program,
          there are no versions of GLSL that cannot support the program. It is 
          usually more desirable to specify a range of required versions and have the
          compiler raise an error when it cannot produce code for one or more
          versions. To compile the same program but with the requirement that
          all versions of GLSL must be supported:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Compilation (versions)</s:formal-item-title>
          <s:verbatim><![CDATA[$ java -jar jparasol-c.jar --require-glsl [,] --require-glsl-es [,] --compile-one /tmp/shaders com.io7m.examples.HelloWorld.p HelloWorld.txt]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          The <s:term s:type="expression">[,]</s:term> notation is standard
          mathematical range notation. This particular expression represents
          an inclusive upper and lower bound that effectively covers all versions.
          The notation is <s:link s:target="jparasol-c.ranges">explained fully</s:link>
          in the documentation for the compiler frontend.
        </s:paragraph>
        <s:paragraph>
          An examination of the output directory will show that the compiler
          has produced code for all of the GLSL versions:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Compilation output</s:formal-item-title>
          <s:verbatim><![CDATA[$ ls -alF /tmp/shaders/
total 0
drwxr-xr-x  5 nobody nobody   100 2014-06-11 18:06 ./
drwxrwxrwt 66 root   root    6020 2014-06-11 18:06 ../
drwxr-xr-x  2 nobody nobody   320 2014-06-11 18:06 com.io7m.examples.HelloWorld.f/
drwxr-xr-x  2 nobody nobody    60 2014-06-11 18:06 com.io7m.examples.HelloWorld.p/
drwxr-xr-x  2 nobody nobody   320 2014-06-11 18:06 com.io7m.examples.HelloWorld.v/

$ cat /tmp/shaders/com.io7m.examples.HelloWorld.v/glsl-110.v
#version 110

attribute vec4 v_position;
uniform mat4 m_modelview;
uniform mat4 m_projection;
varying vec4 o;

void
main (void)
{
  vec4 pl_position_clip = ((m_projection * m_modelview) * v_position);
  gl_Position = pl_position_clip;
  o = pl_position_clip;
}

$ cat /tmp/shaders/com.io7m.examples.HelloWorld.f/glsl-110.f
#version 110

void
main (void)
{
  vec4 pl_red = vec4 (1.0, 0.0, 0.0, 1.0);
  gl_FragColor = pl_red;
}

$ cat /tmp/shaders/com.io7m.examples.HelloWorld.v/glsl-140.v
#version 140

in vec4 v_position;
uniform mat4 m_modelview;
uniform mat4 m_projection;
out vec4 o;

void
main (void)
{
  vec4 pl_position_clip = ((m_projection * m_modelview) * v_position);
  gl_Position = pl_position_clip;
  o = pl_position_clip;
}

$ cat /tmp/shaders/com.io7m.examples.HelloWorld.f/glsl-140.f
#version 140

out vec4 o;

void
main (void)
{
  vec4 pl_red = vec4 (1.0, 0.0, 0.0, 1.0);
  o = pl_red;
}

$ cat /tmp/shaders/com.io7m.examples.HelloWorld.v/glsl-es-100.v
#version 100

precision highp float;
precision highp int;

attribute vec4 v_position;
uniform mat4 m_modelview;
uniform mat4 m_projection;
varying vec4 o;

void
main (void)
{
  vec4 pl_position_clip = ((m_projection * m_modelview) * v_position);
  gl_Position = pl_position_clip;
  o = pl_position_clip;
}

$ cat /tmp/shaders/com.io7m.examples.HelloWorld.f/glsl-es-100.f
#version 100

precision highp float;
precision highp int;

void
main (void)
{
  vec4 pl_red = vec4 (1.0, 0.0, 0.0, 1.0);
  gl_FragColor = pl_red;
}]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          As can be seen, the resulting GLSL program is almost identical,
          with the added bonus that the <s:term s:type="package">Parasol</s:term>
          version provides code for all possible GLSL versions.
        </s:paragraph>
      </s:subsection>
    </s:section>
    <s:section>
      <s:section-title>Where next?</s:section-title>
      <s:paragraph>
        The <s:link-external s:target="http://io7m.github.io/jparasol//specification/index-m.xhtml">specification</s:link-external>
        gives the precise formal definitions for the language, and a complete listing
        of the standard libraries.
      </s:paragraph>
    </s:section>
  </s:part>
  
  <s:part>
    <s:part-title>Tools reference</s:part-title>
    <s:part-contents/>
    <s:section>
      <s:section-title>jparasol-c</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>Overview</s:subsection-title>
        <s:formal-item s:kind="example">
          <s:formal-item-title>Options</s:formal-item-title>
          <s:verbatim><![CDATA[parasol-c: [options] --compile-one output shader file0 [file1 ... fileN]
  or [options] --compile-batch output batch-list source-list
  or [options] --check file0 [file1 ... fileN]
  or [options] --show-versions
  or [options] --version]]></s:verbatim>
        </s:formal-item>
      </s:subsection>
      <s:subsection xml:id="jparasol-c.compile">
        <s:subsection-title>Compile</s:subsection-title>
        <s:paragraph>
          The <s:term s:type="command">--compile-one</s:term> command accepts an output directory 
          (or archive, see <s:link s:target="jparasol-c.zip">--zip</s:link>)
          <s:term s:type="variable">o</s:term>,
          the fully-qualified name of a program <s:term s:type="variable">p</s:term>, 
          and a list of one or more <s:term s:type="package">Parasol</s:term> source files. 
          The files are parsed and type-checked and then 
          <s:term s:type="variable">p</s:term>, 
          and the constituent shaders of <s:term s:type="variable">p</s:term>,
          are transformed to GLSL and written
          to <s:term s:type="variable">o</s:term> (creating the directory if it does not
          already exist).
        </s:paragraph>
        <s:paragraph>
          The <s:term s:type="command">--require-glsl</s:term> and
          <s:term s:type="command">--require-glsl-es</s:term> options specify the GLSL
          and GLSL ES versions for which the compiler <s:term s:type="term">must</s:term>
          generate code. The compiler will raise an error if the program cannot
          be supported on one or more versions. The 
          <s:link s:target="jparasol-c.ranges">notation</s:link> for specifying versions
          is described below. If these options are not specified, the compiler will 
          attempt to generate code for all versions but will not raise an error if 
          code cannot be generated for one or more versions.
        </s:paragraph>
      </s:subsection>
      <s:subsection xml:id="jparasol-c.check">
        <s:subsection-title>Check</s:subsection-title>
        <s:paragraph>
          The <s:term s:type="command">--check</s:term> command accepts a list of one or more 
          <s:term s:type="package">Parasol</s:term> source files. 
          The files are parsed and type-checked and any errors are printed on the
          standard error stream.
        </s:paragraph>
      </s:subsection>
      <s:subsection xml:id="jparasol-c.compile-batch">
        <s:subsection-title>Compile Batch</s:subsection-title>
        <s:paragraph>
          The <s:term s:type="command">--compile-batch</s:term> command accepts a base directory 
          <s:term s:type="variable">b</s:term>,
          a file <s:term s:type="variable">f</s:term> containing a list of 
          <s:link s:target="jparasol-c.batches">batches</s:link>, 
          and a file <s:term s:type="variable">s</s:term> containing a list of
          source files with one file per line.
        </s:paragraph>
        <s:paragraph>
          For each program <s:term s:type="variable">p</s:term> in the list
          of batches, the compiler will produce a GLSL program in <s:term s:type="file">b/p</s:term>.
        </s:paragraph>
        <s:paragraph>
          The <s:term s:type="command">--require-glsl</s:term> and
          <s:term s:type="command">--require-glsl-es</s:term> options specify the GLSL
          and GLSL ES versions for which the compiler <s:term s:type="term">must</s:term>
          generate code. The compiler will raise an error if the program cannot
          be supported on one or more versions. The 
          <s:link s:target="jparasol-c.ranges">notation</s:link> for specifying versions
          is described below. If these options are not specified, the compiler will 
          attempt to generate code for all versions but will not raise an error if 
          code cannot be generated for one or more versions.
        </s:paragraph>
        <s:paragraph>
          The command is intended to be used to process thousands of
          programs. The compiler supports multi-threaded program processing
          and can, after parsing and type-checking, produce multiple GLSL
          programs from the resulting typed AST in parallel. The
          <s:term s:type="command">--threads</s:term> option specifies
          the number of threads that should be used during batch compilation,
          with <s:term s:type="constant">1</s:term> thread being the default.
        </s:paragraph>
      </s:subsection>
      <s:subsection xml:id="jparasol-c.zip">
        <s:subsection-title>Zip</s:subsection-title>
        <s:paragraph>
          When the <s:term s:type="parameter">--zip</s:term> parameter is
          specified, the output path is instead assumed to be an archive
          that will be created and populated with the resulting shading 
          programs.
        </s:paragraph>
        <s:paragraph>
          By default, any file that exists at the named output path will
          be replaced. When the <s:term s:type="parameter">--zip-append</s:term>
          option is specified, the output path is assumed to refer to an
          existing zip archive, which will be updated with the generated
          files.
        </s:paragraph>
      </s:subsection>
      <s:subsection xml:id="jparasol-c.compact">
        <s:subsection-title>Compaction</s:subsection-title>
        <s:paragraph>
          Normally, one source file will be emitted per version of GLSL. Often,
          these different source files will actually be identical in content
          apart from a <s:term s:type="keyword">#version</s:term> directive on
          the first line of the file.
        </s:paragraph>
        <s:paragraph>
          When the <s:term s:type="parameter">--compact</s:term> parameter is
          specified, shaders will be written in so-called 
          <s:term s:type="term">compacted</s:term> form. Essentially, source
          files are stripped of their version directives and then hashed with
          <s:term s:type="function">SHA256</s:term>. Then, each source file
          is renamed to its <s:term s:type="function">SHA256</s:term> hash
          with the addition of its original suffix, and a set of mappings
          from GLSL versions to <s:term s:type="function">SHA256</s:term> hashes
          are written into the program's <s:term s:type="function">meta.xml</s:term>
          file. The user is responsible for re-inserting the correct version
          directive upon passing the program to a GLSL compiler.
        </s:paragraph>
        <s:paragraph>
          The storage space savings of compaction are typically in the range 
          60-70%. In rendering systems that use thousands of shaders, this can
          be significant!
        </s:paragraph>
      </s:subsection>
      <s:subsection xml:id="jparasol-c.ranges">
        <s:subsection-title>Range notation</s:subsection-title>
        <s:paragraph>
          The notation for ranges is given by the following EBNF:
        </s:paragraph>
        <s:formal-item s:kind="specification">
          <s:formal-item-title>Range notation EBNF</s:formal-item-title>
          <s:verbatim><![CDATA[
version-set     := version-segment ( ',' version-segment )*
version-segment := version-exact | version-range
version-exact   := integer
version-range   := ('(' | '[') integer? ',' integer? (')' | ']')]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          The <s:term s:type="expression">[</s:term> and
          <s:term s:type="expression">]</s:term> characters indicate
          inclusive bounds. The <s:term s:type="expression">(</s:term> and
          <s:term s:type="expression">)</s:term> characters indicate
          exclusive bounds.
        </s:paragraph>
        <s:paragraph>
          Some examples from the <s:term s:type="command">jparasol-c</s:term>
          command line help, with <s:term s:type="keyword">x ⊢ y</s:term>
          indicating that the notation <s:term s:type="expression">x</s:term>
          denotes the set of versions <s:term s:type="expression">y</s:term>.
        </s:paragraph>
        <s:formal-item s:kind="example">
          <s:formal-item-title>Range notation examples</s:formal-item-title>
          <s:verbatim><![CDATA[
130               ⊢ {130}
[120, 150]        ⊢ {120, 130, 140, 150}
(120, 150]        ⊢ {130, 140, 150}
120,[140,330],430 ⊢ {120, 140, 150, 330, 430}]]></s:verbatim>
        </s:formal-item>
      </s:subsection>
      <s:subsection xml:id="jparasol-c.batches">
        <s:subsection-title>Batches</s:subsection-title>
        <s:paragraph>
          The syntax for batches is given by the following EBNF:
        </s:paragraph>
        <s:formal-item s:kind="specification">
          <s:formal-item-title>Batches EBNF</s:formal-item-title>
          <s:verbatim><![CDATA[batch := [ name ] , ":" , program_name]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          Where <s:term s:type="variable">name</s:term> is an optional
          output name, and
          <s:term s:type="variable">program_name</s:term> is the
          fully qualified name of a program (consisting of a package, module,
          and program name). An example
          <s:term s:type="variable">program_name</s:term> would
          be <s:term s:type="variable">com.io7m.examples.Example.p</s:term>,
          where <s:term s:type="variable">com.io7m.examples</s:term> is
          the package, <s:term s:type="variable">Example</s:term> is the
          module, and <s:term s:type="variable">p</s:term> is the program.
        </s:paragraph>
        <s:paragraph>
          A batch file contains a list of batches, one per line.
        </s:paragraph>
      </s:subsection>
      <s:subsection xml:id="jparasol-c.logging">
        <s:subsection-title>Logging</s:subsection-title>
        <s:paragraph>
          By default, the compiler remains silent except in the case of
          errors. It is possible to enable more logging for the purposes
          of debugging by providing a configuration file with
          the <s:term s:type="command">--log-properties</s:term> option.
          The configuration file is a set of Java properties that configure
          the <s:link-external s:target="http://io7m.com/software/jlog">jlog</s:link-external>
          package used internally by the compiler and so the documentation
          of that package should be examined for the precise formats of the
          properties.
        </s:paragraph>
        <s:paragraph>
          To save some time, an example file that enables absolutely all
          logging:
        </s:paragraph>
        <s:formal-item s:kind="example">
          <s:formal-item-title>Maximum logging</s:formal-item-title>
          <s:verbatim><![CDATA[
com.io7m.jparasol.logs.compiler = true
com.io7m.jparasol.level         = LOG_DEBUG]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          An example file that enables the minimum debug messages for
          the frontend by disabling logging for all of the main compiler
          components but leaving other messages enabled:
        </s:paragraph>
        <s:formal-item s:kind="example">
          <s:formal-item-title>Minimal logging</s:formal-item-title>
          <s:verbatim><![CDATA[
com.io7m.jparasol.logs.compiler                 = true
com.io7m.jparasol.logs.compiler.pipeline        = false
com.io7m.jparasol.logs.compiler.gpipeline       = false
com.io7m.jparasol.logs.compiler.compactor       = false
com.io7m.jparasol.logs.compiler.serializer-zip  = false
com.io7m.jparasol.logs.compiler.serializer-file = false
com.io7m.jparasol.level                         = LOG_DEBUG]]></s:verbatim>
        </s:formal-item>
      </s:subsection>
    </s:section>
  </s:part>

  <s:part>
    <s:part-title>API Reference</s:part-title>
    <s:part-contents/>
    <s:section>
      <s:section-title>Javadoc</s:section-title>
      <s:paragraph>
        API documentation for the package is provided via the
        included <s:link-external s:target="apidocs">Javadoc</s:link-external>.
      </s:paragraph>
    </s:section>
  </s:part>

</s:document>
