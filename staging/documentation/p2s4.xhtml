<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>io7m-jparasol 0.11.3 Documentation: 2.4. How?</title><link rel="stylesheet" type="text/css" href="jstructural-2.0.0-layout.css"/><link rel="stylesheet" type="text/css" href="jstructural-2.0.0-colour.css"/><link rel="stylesheet" type="text/css" href="documentation.css"/></head><body><div class="st200_body"><div class="brand">
  <div class="brand_left">
    <a href="http://io7m.com/">io7m</a>
  </div>
  <div class="brand_right">
    <a href="http://io7m.github.io/jparasol/">io7m-jparasol</a> 0.11.3
  </div>
</div><div class="st200_navbar st200_navbar_top"><table class="st200_navbar_table" summary="Navigation bar"><tr><td class="st200_navbar_prev_title_cell">2.3. What?</td><td class="st200_navbar_up_title_cell">2. Language Tutorial</td><td class="st200_navbar_next_title_cell">2.5. Where next?</td></tr><tr><td class="st200_navbar_prev_file_cell"><a href="p2s3.xhtml#st200_p2s3">Previous</a></td><td class="st200_navbar_up_file_cell"><a href="p2.xhtml#st200_p2">Up</a></td><td class="st200_navbar_next_file_cell"><a href="p2s5.xhtml#st200_p2s5">Next</a></td></tr></table><hr class="st200_hr"/></div><div class="st200_section_container"><div class="st200_section_title_number"><a id="st200_p2s4" href="#st200_p2s4">2.4</a></div><div class="st200_section_title">How?</div><div class="st200_subsection_container"><div class="st200_subsection_title_number"><a id="st200_p2s4ss1" href="#st200_p2s4ss1">2.4.1</a></div><div class="st200_subsection_title">Parasol â†” GLSL</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss1pg1" href="#st200_p2s4ss1pg1">1</a></div><div class="st200_paragraph">
          The <span class="st200_term package">Parasol</span> language
          takes a similar view of the world as a typical GLSL program. That is,
          a <span class="st200_term term">program</span> consists of exactly one 
          <span class="st200_term term">vertex shader</span>
          and exactly one <span class="st200_term term">fragment shader</span>.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss1pg2" href="#st200_p2s4ss1pg2">2</a></div><div class="st200_paragraph">
          In GLSL, the vertex shader is responsible for assigning values to
          a set of declared outputs, and additionally assigning a clip-space
          vertex position to a built-in variable named 
          <span class="st200_term expression">gl_Position</span>. 
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss1pg3" href="#st200_p2s4ss1pg3">3</a></div><div class="st200_paragraph">
          In <span class="st200_term package">Parasol</span>, a vertex shader
          declares a set of inputs, outputs, and parameters. One of the
          outputs is marked as being the <span class="st200_term term">vertex</span>
          output, to which the programmer is expected to assign a clip-space
          vertex position. There are no built-in names. Input, output, and
          parameter names in <span class="st200_term package">Parasol</span>
          programs will appear exactly as written in the resulting GLSL
          and are therefore subject to the same naming restrictions (and
          this is checked by the compiler).
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss1pg4" href="#st200_p2s4ss1pg4">4</a></div><div class="st200_paragraph">
          In early versions
          of GLSL, the fragment shader was responsible for calculating a single
          RGBA colour vector and assigning it to a built-in variable called
          <span class="st200_term expression">gl_FragColor</span>. In later versions
          of OpenGL, it became possible to have multiple colour attachments
          to framebuffers, and therefore it became necessary for the fragment
          shader to assign multiple outputs. The <span class="st200_term expression">gl_FragColor</span>
          variable was essentially replaced with the
          <span class="st200_term expression">gl_FragData</span> variable, which is
          of an array type. In modern OpenGL, the 
          <span class="st200_term expression">gl_FragColor</span> and
          <span class="st200_term expression">gl_FragData</span> variables have been
          removed, and programmers are required to explicitly declare named
          fragment shader outputs.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss1pg5" href="#st200_p2s4ss1pg5">5</a></div><div class="st200_paragraph">
          In <span class="st200_term package">Parasol</span>, a fragment shader
          declares a set of inputs, outputs, and parameters. All of the
          outputs must be named and numbered. This allows the compiler to
          map numbered outputs to the <span class="st200_term expression">gl_FragData</span>
          array in early versions of GLSL, and to correctly declare
          named outputs in modern GLSL. The compiler checks that output
          numbers start at <span class="st200_term constant">0</span> and
          increase monotonically.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss1pg6" href="#st200_p2s4ss1pg6">6</a></div><div class="st200_paragraph">
          As stated previously, in GLSL a vertex or fragment shader is 
          typically represented by a single file and execution begins 
          at a function called <span class="st200_term expression">main</span>.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss1pg7" href="#st200_p2s4ss1pg7">7</a></div><div class="st200_paragraph">
          The <span class="st200_term package">Parasol</span> language implements
          a simple module system to promote re-use of code, and all functions,
          types, and shaders must be declared inside of modules. Vertex
          and fragment shaders are declared inside of modules and then
          aggregated into <span class="st200_term term">programs</span>. When it
          comes time to produce GLSL, the programmer provides the
          <span class="st200_term term">fully-qualified</span> name of a
          declared <span class="st200_term term">program</span> and the compiler
          produces a set of GLSL shaders based on the selection.
        </div></div></div><div class="st200_subsection_container"><div class="st200_subsection_title_number"><a id="st200_p2s4ss2" href="#st200_p2s4ss2">2.4.2</a></div><div class="st200_subsection_title">Hello World GLSL</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss2pg1" href="#st200_p2s4ss2pg1">1</a></div><div class="st200_paragraph">
          A simple GLSL vertex shader in GLSL 1.40 that simply transforms
          the given object-space coordinates to clip-space by multiplying
          by a given modelview and projection matrix:
        </div></div><div class="st200_formal_item"><div class="st200_formal_item_title"><a id="st200_p2s4ss2fo1" href="#st200_p2s4ss2fo1">2.4.2.1. Hello World GLSL - Vertex shader</a></div><pre class="st200_verbatim">#version 140

in vec4 v_position;
uniform mat4 m_modelview;
uniform mat4 m_projection;

void
main ()
{
  gl_Position = m_projection * m_modelview * v_position;
}
</pre></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss2pg2" href="#st200_p2s4ss2pg2">2</a></div><div class="st200_paragraph">
          A simple fragment shader in GLSL 1.40 that declares a colour
          output and assigns a constant red colour to it:
        </div></div><div class="st200_formal_item"><div class="st200_formal_item_title"><a id="st200_p2s4ss2fo2" href="#st200_p2s4ss2fo2">2.4.2.2. Hello World GLSL - Fragment shader</a></div><pre class="st200_verbatim">#version 140

out vec4 out_rgba;

void
main ()
{
  out_rgba = vec4 (1.0, 0.0, 0.0, 1.0);
}</pre></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss2pg3" href="#st200_p2s4ss2pg3">3</a></div><div class="st200_paragraph">
          The programmer then compiles and loads each shader file from the
          OpenGL API, links them, and then uses them.
        </div></div></div><div class="st200_subsection_container"><div class="st200_subsection_title_number"><a id="st200_p2s4ss3" href="#st200_p2s4ss3">2.4.3</a></div><div class="st200_subsection_title">Hello World Parasol</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss3pg1" href="#st200_p2s4ss3pg1">1</a></div><div class="st200_paragraph">
          As stated, all terms, types, and shaders must be declared in
          modules. For this tutorial, a <span class="st200_term expression">HelloWorld</span>
          module suffices, declared in package
          <span class="st200_term expression">com.io7m.examples</span>.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss3pg2" href="#st200_p2s4ss3pg2">2</a></div><div class="st200_paragraph">
          The previous GLSL shaders translated to <span class="st200_term package">Parasol</span>
          become:
        </div></div><div class="st200_formal_item"><div class="st200_formal_item_title"><a id="st200_p2s4ss3fo1" href="#st200_p2s4ss3fo1">2.4.3.1. Hello World Parasol</a></div><pre class="st200_verbatim">package com.io7m.examples;

module HelloWorld is

  import com.io7m.parasol.Matrix4x4f as M4;

  shader vertex v is
    in         v_position   : vector_4f;
    parameter  m_modelview  : matrix_4x4f;
    parameter  m_projection : matrix_4x4f;
    out vertex o            : vector_4f;
  with
    value position_clip =
      M4.multiply_vector (M4.multiply (m_projection, m_modelview), v_position);
  as
    out o = position_clip;
  end;

  shader fragment f is
    out o : vector_4f as 0;
  with
    value red =
      new vector_4f (1.0, 0.0, 0.0, 1.0);
  as
    out o = red;
  end;

  shader program p is
    vertex v;
    fragment f;
  end;

end;</pre></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss3pg3" href="#st200_p2s4ss3pg3">3</a></div><div class="st200_paragraph">
          The module declares a vertex shader named <span class="st200_term type">v</span>,
          a fragment shader named <span class="st200_term type">p</span>, and combines the two
          into a program named <span class="st200_term type">p</span>. Any number of
          shaders and programs can be declared in a single module (but their names
          must obviously differ).
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss3pg4" href="#st200_p2s4ss3pg4">4</a></div><div class="st200_paragraph">
          The vertex shader declares an input <span class="st200_term expression">v_position</span>,
          two parameters <span class="st200_term expression">m_modelview</span> and
          <span class="st200_term expression">m_projection</span>, and an output named
          <span class="st200_term expression">o</span> which is marked as the main
          vertex output with the <span class="st200_term expression">vertex</span> keyword.
          The shader performs the same multiplication as the GLSL program, assigning
          the result to a local variable named <span class="st200_term expression">position_clip</span>.
          Variables in <span class="st200_term package">Parasol</span> are immutable
          and the programmer is not required to state the types of values because
          the language features local type inference. Finally, the shader writes
          the calculated value to the output
          <span class="st200_term expression">o</span> with an 
          <span class="st200_term term">output assignment</span>. The right-hand side of
          an <span class="st200_term term">output assignment</span> is required to be
          a name <span class="st200_footnote_reference"><a id="st200_fn_6_ref" href="#st200_fn_6">[6]</a></span>. The <span class="st200_term package">Parasol</span> compiler
          requires that all outputs be assigned.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss3pg5" href="#st200_p2s4ss3pg5">5</a></div><div class="st200_paragraph">
          Because the language only provides functions and not operators, the order
          of operations is completely unambiguous; the arguments to functions are
          evaluated eagerly from left to right and then substituted into the body
          of the function. Does the multiplication in the GLSL version mean
          <span class="st200_term expression">(p * m) * v</span> or
          <span class="st200_term expression">p * (m * v)</span>? In this case, it may
          not matter, but what about in more complicated expressions with
          overloading? Programmers get this wrong constantly. The 
          <span class="st200_term package">Parasol</span>
          language keeps things explicit - mistakes become difficult to make.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss3pg6" href="#st200_p2s4ss3pg6">6</a></div><div class="st200_paragraph">
          The fragment shader simply declares a value named <span class="st200_term expression">red</span>
          and assigns it to the single declared output named <span class="st200_term expression">o</span>.
          Note that <span class="st200_term expression">o</span> is assigned both a name
          and a number; this is required by the language.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss3pg7" href="#st200_p2s4ss3pg7">7</a></div><div class="st200_paragraph">
          The program <span class="st200_term type">p</span> states that it uses
          the vertex shader <span class="st200_term type">v</span> and the fragment
          shader <span class="st200_term type">f</span>. The compiler will check that
          the programs are <span class="st200_term term">compatible</span> when
          <span class="st200_term type">p</span> is declared. The rules for
          <span class="st200_term term">compatibility</span> are the same as they
          are for GLSL; the vertex shader must have a corresponding output
          with the same name and type as each of the fragment shader's
          inputs.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss3pg8" href="#st200_p2s4ss3pg8">8</a></div><div class="st200_paragraph">
          Assuming that the above is in a file named <span class="st200_term file">HelloWorld.txt</span>
          and that the resulting GLSL shaders should be written to a directory
          called <span class="st200_term file">/tmp/shaders</span>, the program can be compiled
          as follows:
        </div></div><div class="st200_formal_item"><div class="st200_formal_item_title"><a id="st200_p2s4ss3fo2" href="#st200_p2s4ss3fo2">2.4.3.2. Compilation</a></div><pre class="st200_verbatim">$ java -jar jparasol-c.jar --compile-one /tmp/shaders com.io7m.examples.HelloWorld.p HelloWorld.txt</pre></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss3pg9" href="#st200_p2s4ss3pg9">9</a></div><div class="st200_paragraph">
          The compiler says nothing unless an error occurs.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss3pg10" href="#st200_p2s4ss3pg10">10</a></div><div class="st200_paragraph">
          By default, the compiler will attempt to produce GLSL shaders for all
          known versions of GLSL. It will silently fail to produce a program for
          a version that cannot be supported. In the case of the above program,
          there are no versions of GLSL that cannot support the program. It is 
          usually more desirable to specify a range of required versions and have the
          compiler raise an error when it cannot produce code for one or more
          versions. To compile the same program but with the requirement that
          all versions of GLSL must be supported:
        </div></div><div class="st200_formal_item"><div class="st200_formal_item_title"><a id="st200_p2s4ss3fo3" href="#st200_p2s4ss3fo3">2.4.3.3. Compilation (versions)</a></div><pre class="st200_verbatim">$ java -jar jparasol-c.jar --require-glsl [,] --require-glsl-es [,] --compile-one /tmp/shaders com.io7m.examples.HelloWorld.p HelloWorld.txt</pre></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss3pg11" href="#st200_p2s4ss3pg11">11</a></div><div class="st200_paragraph">
          The <span class="st200_term expression">[,]</span> notation is standard
          mathematical range notation. This particular expression represents
          an inclusive upper and lower bound that effectively covers all versions.
          The notation is <a class="st200_link" href="p3s1.xhtml#st200_p3s1ss7">explained fully</a>
          in the documentation for the compiler frontend.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss3pg12" href="#st200_p2s4ss3pg12">12</a></div><div class="st200_paragraph">
          An examination of the output directory will show that the compiler
          has produced code for all of the GLSL versions:
        </div></div><div class="st200_formal_item"><div class="st200_formal_item_title"><a id="st200_p2s4ss3fo4" href="#st200_p2s4ss3fo4">2.4.3.4. Compilation output</a></div><pre class="st200_verbatim">$ ls -alF /tmp/shaders/
total 0
drwxr-xr-x  5 nobody nobody   100 2014-06-11 18:06 ./
drwxrwxrwt 66 root   root    6020 2014-06-11 18:06 ../
drwxr-xr-x  2 nobody nobody   320 2014-06-11 18:06 com.io7m.examples.HelloWorld.f/
drwxr-xr-x  2 nobody nobody    60 2014-06-11 18:06 com.io7m.examples.HelloWorld.p/
drwxr-xr-x  2 nobody nobody   320 2014-06-11 18:06 com.io7m.examples.HelloWorld.v/

$ cat /tmp/shaders/com.io7m.examples.HelloWorld.v/glsl-110.v
#version 110

attribute vec4 v_position;
uniform mat4 m_modelview;
uniform mat4 m_projection;
varying vec4 o;

void
main (void)
{
  vec4 pl_position_clip = ((m_projection * m_modelview) * v_position);
  gl_Position = pl_position_clip;
  o = pl_position_clip;
}

$ cat /tmp/shaders/com.io7m.examples.HelloWorld.f/glsl-110.f
#version 110

void
main (void)
{
  vec4 pl_red = vec4 (1.0, 0.0, 0.0, 1.0);
  gl_FragColor = pl_red;
}

$ cat /tmp/shaders/com.io7m.examples.HelloWorld.v/glsl-140.v
#version 140

in vec4 v_position;
uniform mat4 m_modelview;
uniform mat4 m_projection;
out vec4 o;

void
main (void)
{
  vec4 pl_position_clip = ((m_projection * m_modelview) * v_position);
  gl_Position = pl_position_clip;
  o = pl_position_clip;
}

$ cat /tmp/shaders/com.io7m.examples.HelloWorld.f/glsl-140.f
#version 140

out vec4 o;

void
main (void)
{
  vec4 pl_red = vec4 (1.0, 0.0, 0.0, 1.0);
  o = pl_red;
}

$ cat /tmp/shaders/com.io7m.examples.HelloWorld.v/glsl-es-100.v
#version 100

precision highp float;
precision highp int;

attribute vec4 v_position;
uniform mat4 m_modelview;
uniform mat4 m_projection;
varying vec4 o;

void
main (void)
{
  vec4 pl_position_clip = ((m_projection * m_modelview) * v_position);
  gl_Position = pl_position_clip;
  o = pl_position_clip;
}

$ cat /tmp/shaders/com.io7m.examples.HelloWorld.f/glsl-es-100.f
#version 100

precision highp float;
precision highp int;

void
main (void)
{
  vec4 pl_red = vec4 (1.0, 0.0, 0.0, 1.0);
  gl_FragColor = pl_red;
}</pre></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss3pg13" href="#st200_p2s4ss3pg13">13</a></div><div class="st200_paragraph">
          As can be seen, the resulting GLSL program is almost identical,
          with the added bonus that the <span class="st200_term package">Parasol</span>
          version provides code for all possible GLSL versions.
        </div></div></div></div><div class="st200_footnotes"><hr/><div class="st200_footnote_container"><div class="st200_footnote_number">[<a id="st200_fn_6" href="#st200_fn_6_ref">6</a>]</div><div class="st200_footnote_body">
            The reason for this is because the GLSL standard has various rules
            about how and when shader outputs must be assigned. <span class="st200_term package">Parasol</span>
            language programs <span class="st200_term term">syntactically</span> guarantee that either all outputs are
            assigned, or none of them are.
          </div></div></div><div class="st200_navbar st200_navbar_bottom"><hr class="st200_hr"/><table class="st200_navbar_table" summary="Navigation bar"><tr><td class="st200_navbar_prev_file_cell"><a href="p2s3.xhtml#st200_p2s3">Previous</a></td><td class="st200_navbar_up_file_cell"><a href="p2.xhtml#st200_p2">Up</a></td><td class="st200_navbar_next_file_cell"><a href="p2s5.xhtml#st200_p2s5">Next</a></td></tr><tr><td class="st200_navbar_prev_title_cell">2.3. What?</td><td class="st200_navbar_up_title_cell">2. Language Tutorial</td><td class="st200_navbar_next_title_cell">2.5. Where next?</td></tr></table></div></div></body></html>
