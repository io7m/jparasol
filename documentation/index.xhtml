<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>io7m-jparasol 0.11.3 Documentation</title><link rel="stylesheet" type="text/css" href="jstructural-2.0.0-layout.css"/><link rel="stylesheet" type="text/css" href="jstructural-2.0.0-colour.css"/><link rel="stylesheet" type="text/css" href="documentation.css"/></head><body><div class="st200_body"><div class="brand">
  <div class="brand_left">
    <a href="http://io7m.com/">io7m</a>
  </div>
  <div class="brand_right">
    <a href="http://io7m.github.io/jparasol/">io7m-jparasol</a> 0.11.3
  </div>
</div><div class="st200_document_title">io7m-jparasol 0.11.3 Documentation</div><ul class="st200_contents st200_document_contents"><li class="st200_contents_item st200_contents_item1 st200_contents_item_part"><a href="#st200_p1">1. Package Information</a><ul class="st200_contents st200_part_contents"><li class="st200_contents_item st200_contents_item2 st200_contents_item_section"><a href="#st200_p1s1">1.1. Orientation</a></li><li class="st200_contents_item st200_contents_item2 st200_contents_item_section"><a href="#st200_p1s2">1.2. Installation</a></li><li class="st200_contents_item st200_contents_item2 st200_contents_item_section"><a href="#st200_p1s3">1.3. Platform Specific Issues</a></li><li class="st200_contents_item st200_contents_item2 st200_contents_item_section"><a href="#st200_p1s4">1.4. License</a></li></ul></li><li class="st200_contents_item st200_contents_item1 st200_contents_item_part"><a href="#st200_p2">2. Language Tutorial</a><ul class="st200_contents st200_part_contents"><li class="st200_contents_item st200_contents_item2 st200_contents_item_section"><a href="#st200_p2s1">2.1. Prerequisites</a></li><li class="st200_contents_item st200_contents_item2 st200_contents_item_section"><a href="#st200_p2s2">2.2. Why?</a></li><li class="st200_contents_item st200_contents_item2 st200_contents_item_section"><a href="#st200_p2s3">2.3. What?</a></li><li class="st200_contents_item st200_contents_item2 st200_contents_item_section"><a href="#st200_p2s4">2.4. How?</a></li><li class="st200_contents_item st200_contents_item2 st200_contents_item_section"><a href="#st200_p2s5">2.5. Where next?</a></li></ul></li><li class="st200_contents_item st200_contents_item1 st200_contents_item_part"><a href="#st200_p3">3. Tools reference</a><ul class="st200_contents st200_part_contents"><li class="st200_contents_item st200_contents_item2 st200_contents_item_section"><a href="#st200_p3s1">3.1. jparasol-c</a></li></ul></li><li class="st200_contents_item st200_contents_item1 st200_contents_item_part"><a href="#st200_p4">4. API Reference</a><ul class="st200_contents st200_part_contents"><li class="st200_contents_item st200_contents_item2 st200_contents_item_section"><a href="#st200_p4s1">4.1. Javadoc</a></li></ul></li></ul><div class="st200_part_container"><div class="st200_part_title_number"><a id="st200_p1" href="#st200_p1">1</a></div><div class="st200_part_title">Package Information</div><ul class="st200_contents st200_part_contents_outer st200_part_contents"><li class="st200_contents_item st200_contents_item1 st200_contents_item_section"><a href="#st200_p1s1">1.1. Orientation</a><ul class="st200_contents st200_section_contents"><li class="st200_contents_item st200_contents_item2 st200_contents_item_subsection"><a href="#st200_p1s1ss1">1.1.1. Overview</a></li></ul></li><li class="st200_contents_item st200_contents_item1 st200_contents_item_section"><a href="#st200_p1s2">1.2. Installation</a><ul class="st200_contents st200_section_contents"><li class="st200_contents_item st200_contents_item2 st200_contents_item_subsection"><a href="#st200_p1s2ss1">1.2.1. Source compilation</a></li><li class="st200_contents_item st200_contents_item2 st200_contents_item_subsection"><a href="#st200_p1s2ss2">1.2.2. Maven</a></li></ul></li><li class="st200_contents_item st200_contents_item1 st200_contents_item_section"><a href="#st200_p1s3">1.3. Platform Specific Issues</a></li><li class="st200_contents_item st200_contents_item1 st200_contents_item_section"><a href="#st200_p1s4">1.4. License</a></li></ul><div class="st200_section_container"><div class="st200_section_title_number"><a id="st200_p1s1" href="#st200_p1s1">1.1</a></div><div class="st200_section_title">Orientation</div><div class="st200_subsection_container"><div class="st200_subsection_title_number"><a id="st200_p1s1ss1" href="#st200_p1s1ss1">1.1.1</a></div><div class="st200_subsection_title">Overview</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p1s1ss1pg1" href="#st200_p1s1ss1pg1">1</a></div><div class="st200_paragraph">
          The <span class="st200_term package">io7m-jparasol</span> package 
          implements a minimalist pure functional shading language.
        </div></div></div></div><div class="st200_section_container"><div class="st200_section_title_number"><a id="st200_p1s2" href="#st200_p1s2">1.2</a></div><div class="st200_section_title">Installation</div><div class="st200_subsection_container"><div class="st200_subsection_title_number"><a id="st200_p1s2ss1" href="#st200_p1s2ss1">1.2.1</a></div><div class="st200_subsection_title">Source compilation</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p1s2ss1pg1" href="#st200_p1s2ss1pg1">1</a></div><div class="st200_paragraph">
          The project can be compiled and installed with
          <a class="st200_link_external" href="http://maven.apache.org">Maven</a>:
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p1s2ss1pg2" href="#st200_p1s2ss1pg2">2</a></div><div class="st200_paragraph">
          <pre class="st200_verbatim example">$ mvn -C clean install</pre>
        </div></div></div><div class="st200_subsection_container"><div class="st200_subsection_title_number"><a id="st200_p1s2ss2" href="#st200_p1s2ss2">1.2.2</a></div><div class="st200_subsection_title">Maven</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p1s2ss2pg1" href="#st200_p1s2ss2pg1">1</a></div><div class="st200_paragraph">
          Regular releases are made to the
          <a class="st200_link_external" href="http://search.maven.org/#search%7Cga%7C1%7Cio7m-jparasol">Central Repository</a>,
          so it's possible to use the <span class="st200_term package">io7m-jparasol</span>
          package in your projects with the following Maven dependency:
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p1s2ss2pg2" href="#st200_p1s2ss2pg2">2</a></div><div class="st200_paragraph">
          <pre class="st200_verbatim example">&lt;dependency&gt;
  &lt;groupId&gt;com.io7m.jparasol&lt;/groupId&gt;
  &lt;artifactId&gt;io7m-jparasol-core&lt;/artifactId&gt;
  &lt;version&gt;0.11.3&lt;/version&gt;
&lt;/dependency&gt;</pre>
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p1s2ss2pg3" href="#st200_p1s2ss2pg3">3</a></div><div class="st200_paragraph">
          All <a class="st200_link_external" href="http://io7m.com">io7m.com</a>
          packages use Semantic Versioning
          <span class="st200_footnote_reference"><a id="st200_fn_0_ref" href="#st200_fn_0">[0]</a></span>, which implies that it is always safe to use version ranges
          with an exclusive upper bound equal to the next major version - the API of
          the package will not change in a backwards-incompatible manner before the
          next major version.
        </div></div></div></div><div class="st200_section_container"><div class="st200_section_title_number"><a id="st200_p1s3" href="#st200_p1s3">1.3</a></div><div class="st200_section_title">Platform Specific Issues</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p1s3pg1" href="#st200_p1s3pg1">1</a></div><div class="st200_paragraph">
        There are currently no known platform-specific issues.
      </div></div></div><div class="st200_section_container"><div class="st200_section_title_number"><a id="st200_p1s4" href="#st200_p1s4">1.4</a></div><div class="st200_section_title">License</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p1s4pg1" href="#st200_p1s4pg1">1</a></div><div class="st200_paragraph">
        All files distributed with the <span class="st200_term package">io7m-jparasol</span>
        package are placed under the following license:
        <pre class="st200_verbatim license">Copyright © 2014 &lt;code@io7m.com&gt; http://io7m.com

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
        </pre>
      </div></div></div></div><div class="st200_part_container"><div class="st200_part_title_number"><a id="st200_p2" href="#st200_p2">2</a></div><div class="st200_part_title">Language Tutorial</div><ul class="st200_contents st200_part_contents_outer st200_part_contents"><li class="st200_contents_item st200_contents_item1 st200_contents_item_section"><a href="#st200_p2s1">2.1. Prerequisites</a></li><li class="st200_contents_item st200_contents_item1 st200_contents_item_section"><a href="#st200_p2s2">2.2. Why?</a><ul class="st200_contents st200_section_contents"><li class="st200_contents_item st200_contents_item2 st200_contents_item_subsection"><a href="#st200_p2s2ss1">2.2.1. Versioning</a></li><li class="st200_contents_item st200_contents_item2 st200_contents_item_subsection"><a href="#st200_p2s2ss2">2.2.2. Correctness</a></li><li class="st200_contents_item st200_contents_item2 st200_contents_item_subsection"><a href="#st200_p2s2ss3">2.2.3. Modularity and re-use</a></li></ul></li><li class="st200_contents_item st200_contents_item1 st200_contents_item_section"><a href="#st200_p2s3">2.3. What?</a><ul class="st200_contents st200_section_contents"><li class="st200_contents_item st200_contents_item2 st200_contents_item_subsection"><a href="#st200_p2s3ss1">2.3.1. Parasol</a></li><li class="st200_contents_item st200_contents_item2 st200_contents_item_subsection"><a href="#st200_p2s3ss2">2.3.2. Limitations</a></li></ul></li><li class="st200_contents_item st200_contents_item1 st200_contents_item_section"><a href="#st200_p2s4">2.4. How?</a><ul class="st200_contents st200_section_contents"><li class="st200_contents_item st200_contents_item2 st200_contents_item_subsection"><a href="#st200_p2s4ss1">2.4.1. Parasol ↔ GLSL</a></li><li class="st200_contents_item st200_contents_item2 st200_contents_item_subsection"><a href="#st200_p2s4ss2">2.4.2. Hello World GLSL</a></li><li class="st200_contents_item st200_contents_item2 st200_contents_item_subsection"><a href="#st200_p2s4ss3">2.4.3. Hello World Parasol</a></li></ul></li><li class="st200_contents_item st200_contents_item1 st200_contents_item_section"><a href="#st200_p2s5">2.5. Where next?</a></li></ul><div class="st200_section_container"><div class="st200_section_title_number"><a id="st200_p2s1" href="#st200_p2s1">2.1</a></div><div class="st200_section_title">Prerequisites</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s1pg1" href="#st200_p2s1pg1">1</a></div><div class="st200_paragraph">
        The <span class="st200_term package">parasol</span> compiler is implemented
        as a set of APIs with a simple command-line frontend. The frontend
        is packaged into a convenient 
        <a class="st200_link_external" href="http://mvn-repository.io7m.com//com/io7m/jparasol/io7m-jparasol-compiler-frontend/0.11.3/io7m-jparasol-compiler-frontend-0.11.3-jparasol-c.jar">executable jar</a>
        containing all of the compiler's dependencies. The jar file can
        be executed in the usual manner:
      </div></div><div class="st200_formal_item"><div class="st200_formal_item_title"><a id="st200_p2s1fo1" href="#st200_p2s1fo1">2.1.1. Compiler example</a></div><pre class="st200_verbatim">$ java -jar io7m-jparasol-compiler-frontend-0.11.3-jparasol-c.jar
parasol-c: [options] --compile-one output shader file0 [file1 ... fileN]
        or [options] --compile-batch output batch-list source-list
        or [options] --check file0 [file1 ... fileN]
        or [options] --show-glsl-versions
        or [options] --version

  Where: output           is a directory (unless --zip is specified) that will be populated with GLSL shaders
         shader           is the fully-qualified name of a shading program
         batch-list       is a file containing (output , ':' , shader) tuples, separated by newlines
         source-list      is a file containing a set of filenames, separated by newlines
         file[0 .. N]     is a series of filenames containing source code

     --check                            Parse and type-check all source files, but do not produce GLSL source
     --compact                          Enable compaction (eliminates duplicate source files)
     --compile-batch                    Produce multiple GLSL programs from a set of sources
     --compile-one                      Compile a specific shader program to GLSL source
  -h,--help                             Show this help message
     --log-properties &lt;properties&gt;      Configure logging based on the given property file
     --log-stack-traces                 Enable logging of exception stack traces
     --require-glsl &lt;version-set&gt;       Require GLSL source code for the given set of GLSL versions, failing if any of
                                        the versions cannot be satisfied
     --require-glsl-es &lt;version-set&gt;    Require GLSL ES source code for the given set of GLSL ES versions, failing if
                                        any of the versions cannot be satisfied
     --show-glsl-versions               Show the available GLSL versions
     --threads &lt;count&gt;                  Set the number of threads to use during code generation
     --version                          Display compiler version
     --zip                              Write shaders to a zip archive instead of a directory

   Where: version-set     := version-segment ( ',' version-segment )*
          version-segment := version-exact | version-range
          version-exact   := integer
          version-range   := ('(' | '[') integer? ',' integer? (')' | ']')

     Where '[' and ']' denote inclusive bounds, and '(' ')' denote exclusive bounds.

     Example: 130 selects version 130
     Example: [120, 150] selects versions 120 to 150
     Example: (120, 150] selects versions 130 to 150
     Example: 120,[140,330],440 selects versions 120, 140, 150, 330, and 440

  Version: 0.11.3</pre></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s1pg2" href="#st200_p2s1pg2">2</a></div><div class="st200_paragraph">
        The name of the <span class="st200_term file">io7m-jparasol-compiler-frontend-0.11.3-jparasol-c.jar</span> file
        is actually selected by Maven. For the sake of brevity, it is assumed that the user
        has renamed this file to <span class="st200_term file">jparasol-c.jar</span> for this
        tutorial.
      </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s1pg3" href="#st200_p2s1pg3">3</a></div><div class="st200_paragraph">
        The programmer is expected to be familiar enough with GLSL to
        dislike the language.
      </div></div></div><div class="st200_section_container"><div class="st200_section_title_number"><a id="st200_p2s2" href="#st200_p2s2">2.2</a></div><div class="st200_section_title">Why?</div><div class="st200_subsection_container"><div class="st200_subsection_title_number"><a id="st200_p2s2ss1" href="#st200_p2s2ss1">2.2.1</a></div><div class="st200_subsection_title">Versioning</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s2ss1pg1" href="#st200_p2s2ss1pg1">1</a></div><div class="st200_paragraph">
          GLSL is a versioning and compatibility nightmare: There are, at the 
          time of writing, fourteen different versions of GLSL in use. The 
          versions of OpenGL and GLSL available are tied to hardware and to 
          OpenGL drivers. Different versions of GLSL differ wildly in syntax 
          and in the names of functions defined in the standard library. The 
          same program may have to be rewritten five or six times to deal 
          with trivial syntax differences between versions. The standard
          recommendation is for programs to explicitly mark the version of
          GLSL for which they're intended by including a 
          <span class="st200_term keyword">#version</span> directive at the start
          of the file. Without this directive, many GLSL implementations
          fall back to using the oldest available version, which then typically
          means that the compiler rejects the program as invalid. With a
          <span class="st200_term keyword">#version</span> directive included, the
          programmer is asserting that he/she wishes to use a specific version
          which, of course, may not be available. Certain versions of OpenGL
          (such as OpenGL ES 2), place arbitrary restrictions on programs
          (such as not being able to declare multiple fragment shader outputs).
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s2ss1pg2" href="#st200_p2s2ss1pg2">2</a></div><div class="st200_paragraph">
          Most programmers attempt to work around these problems by layering
          on hacks and preprocessor macros. This is obviously unacceptable to
          programmers that actually care about correctness.
        </div></div></div><div class="st200_subsection_container"><div class="st200_subsection_title_number"><a id="st200_p2s2ss2" href="#st200_p2s2ss2">2.2.2</a></div><div class="st200_subsection_title">Correctness</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s2ss2pg1" href="#st200_p2s2ss2pg1">1</a></div><div class="st200_paragraph">
          GLSL is a nightmare from the perspective of correctness: Programs
          are parsed and type-checked at runtime. The commitee that mismanages 
          OpenGL decided that all OpenGL drivers should implement their own compilers. 
          Apart from the inevitable correctness issues that stem from this requirement, 
          this also means that errors that should be entirely statically detectable 
          are signalled at the latest possible stage (run time). Systems that use 
          thousands of GLSL shaders are required to do obscene amounts of 
          testing to ensure that all of their shaders are valid GLSL.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s2ss2pg2" href="#st200_p2s2ss2pg2">2</a></div><div class="st200_paragraph">
          The language, on one hand, requires explicit type conversions. This is
          generally beneficial because there are none of magical implicit type 
          conversions that appear in somewhat more weakly-typed languages. The
          language then works hard to eliminate the beneficial aspects by overloading
          all functions and operators, so that the programmer really has no idea
          which particular overloaded variant is being used <span class="st200_footnote_reference"><a id="st200_fn_1_ref" href="#st200_fn_1">[1]</a></span>.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s2ss2pg3" href="#st200_p2s2ss2pg3">3</a></div><div class="st200_paragraph">
          The language has no module system and simply dumps its entire standard
          library into the same namespace as the programmer's code. The programmer
          must explicitly prefix the names of any defined functions or variables
          in order to avoid potential collisions. The OpenGL committee are free to
          introduce new name collisions at any time.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s2ss2pg4" href="#st200_p2s2ss2pg4">4</a></div><div class="st200_paragraph">
          There are also very limited facilities for inspecting programs that
          have been compiled. For example, the GLSL compiler is free to remove
          any program inputs or parameters that is has deemed to be unused (and
          has therefore optimized out). The programmer using the shading program
          wants to be able to assign values to inputs by name. Unfortunately,
          without the programmer manually parsing the original program, there
          is no way to tell the difference between an input or parameter that
          has been optimized out, and an input or parameter that never existed
          in the first place. There is no way to distinguish between "The compiler
          removed the parameter" and "I got the name of the parameter wrong".
          The GLSL compiler obviously has this information, but
          it is not made available to the programmer. In order to really guarantee
          correctness, it's necessary for the programmer to reimplement parts 
          of the GLSL compiler!
        </div></div></div><div class="st200_subsection_container"><div class="st200_subsection_title_number"><a id="st200_p2s2ss3" href="#st200_p2s2ss3">2.2.3</a></div><div class="st200_subsection_title">Modularity and re-use</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s2ss3pg1" href="#st200_p2s2ss3pg1">1</a></div><div class="st200_paragraph">
          A GLSL shader is represented by a single file. Code that is re-used
          between shaders must either be copied and pasted, or must be inserted
          automatically via some error-prone macro or preprocessor
          system. The GLSL language does not support
          <span class="st200_term keyword">#include</span> directives, so the programmer
          is forced to build their own system to manage pieces of shaders.
        </div></div></div></div><div class="st200_section_container"><div class="st200_section_title_number"><a id="st200_p2s3" href="#st200_p2s3">2.3</a></div><div class="st200_section_title">What?</div><div class="st200_subsection_container"><div class="st200_subsection_title_number"><a id="st200_p2s3ss1" href="#st200_p2s3ss1">2.3.1</a></div><div class="st200_subsection_title">Parasol</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s3ss1pg1" href="#st200_p2s3ss1pg1">1</a></div><div class="st200_paragraph">
          The <span class="st200_term package">Parasol</span> language is an aggressively
          minimalist pure-functional shading language. The intention is to provide
          a language with simple and predictable semantics that can then be
          compiled to all possible versions of GLSL, eliminating all of the versioning
          concerns previously expressed. On versions of GLSL that do not provide certain
          functions, the compiler silently provides emulations 
          <span class="st200_footnote_reference"><a id="st200_fn_2_ref" href="#st200_fn_2">[2]</a></span>. Essentially, the programmer provides a
          <span class="st200_term package">Parasol</span> program and a range of GLSL versions
          upon which the program is expected to run. The compiler produces GLSL for
          all of the possible versions and will raise errors if a valid program really cannot
          be produced for a particular GLSL version 
          <span class="st200_footnote_reference"><a id="st200_fn_3_ref" href="#st200_fn_3">[3]</a></span>.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s3ss1pg2" href="#st200_p2s3ss1pg2">2</a></div><div class="st200_paragraph">
          The <span class="st200_term package">Parasol</span> language is
          both pure-functional and <span class="st200_term term">total</span>. That
          is, programs do not have side effects and are guaranteed to
          terminate. The language statically rejects recursive and mutually
          recursive terms, and does not provide looping constructs or
          arrays.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s3ss1pg3" href="#st200_p2s3ss1pg3">3</a></div><div class="st200_paragraph">
          The <span class="st200_term package">Parasol</span> language categorically
          rejects operator and function overloading 
          <span class="st200_footnote_reference"><a id="st200_fn_4_ref" href="#st200_fn_4">[4]</a></span>; the programmer always knows exactly which function
          is being applied on sight. This eliminates the correctness issues
          caused by pervasive overloading.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s3ss1pg4" href="#st200_p2s3ss1pg4">4</a></div><div class="st200_paragraph">
          The language provides a simple non-hierarchical module and package
          system for controlling the namespace. <span class="st200_term package">Parasol</span>
          programs can be developed as sets of re-usable libraries without
          any fear of name collisions. The language works from the assumption
          that, although shader programs are likely to be short and linear, 
          there are also likely to be a large number of them, with significant 
          amounts of duplicated code. The <span class="st200_term package">Parasol</span>
          module system allows code to be imported and re-used safely, with full
          type checking and without requiring a complicated and error-prone
          preprocessor.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s3ss1pg5" href="#st200_p2s3ss1pg5">5</a></div><div class="st200_paragraph">
          The <span class="st200_term package">jparasol</span> compiler is a strictly
          offline compiler developed in Java. The compiler takes 
          <span class="st200_term package">Parasol</span>
          programs as input, and produces GLSL programs (and additional metadata)
          as output. The produced GLSL can then be loaded as normal in any OpenGL program
          and has no dependencies on <span class="st200_term package">Parasol</span>,
          the <span class="st200_term package">jparasol</span> compiler, or anything else.
          The additional metadata produced as output describes various properties
          of the program. This means that programmers are not required to 
          parse <span class="st200_term package">Parasol</span>
          programs to, for example, determine all of the declared inputs, 
          parameters, and outputs. The metadata is an optional component; 
          programmers are not required to use it in order to make use of
          compiled GLSL programs.
        </div></div></div><div class="st200_subsection_container"><div class="st200_subsection_title_number"><a id="st200_p2s3ss2" href="#st200_p2s3ss2">2.3.2</a></div><div class="st200_subsection_title">Limitations</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s3ss2pg1" href="#st200_p2s3ss2pg1">1</a></div><div class="st200_paragraph">
          The language considers portability and correctness
          to be more important than exposing the latest flashy 
          features of GLSL. The language therefore exposes 
          features roughly analogous
          to version <span class="st200_term constant">1.40</span> of
          GLSL in an attempt to provide the subset of OpenGL and
          GLSL that will work on as many implementations as possible. 
          The language does not support geometry shaders
          or tesselation shaders. The language does not support
          double-precision floating point. These features will
          likely be introduced as time moves on and older versions
          of OpenGL disappear into history.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s3ss2pg2" href="#st200_p2s3ss2pg2">2</a></div><div class="st200_paragraph">
          As described, the language is currently <span class="st200_term term">total</span>,
          meaning that all programs are guaranteed to terminate. This
          is both a desirable property (because non-terminating shader
          programs are extremely bad news on some OpenGL implementations), and
          a severe limitation (because programs that require loops cannot
          be expressed in <span class="st200_term package">Parasol</span>
          at all). In practice, this has not turned out to be much of
          a problem
          <span class="st200_footnote_reference"><a id="st200_fn_5_ref" href="#st200_fn_5">[5]</a></span>. The shading programs found in most
          game engines tend to be linear in nature and do 
          not require iterating over arrays of values.
        </div></div></div></div><div class="st200_section_container"><div class="st200_section_title_number"><a id="st200_p2s4" href="#st200_p2s4">2.4</a></div><div class="st200_section_title">How?</div><div class="st200_subsection_container"><div class="st200_subsection_title_number"><a id="st200_p2s4ss1" href="#st200_p2s4ss1">2.4.1</a></div><div class="st200_subsection_title">Parasol ↔ GLSL</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss1pg1" href="#st200_p2s4ss1pg1">1</a></div><div class="st200_paragraph">
          The <span class="st200_term package">Parasol</span> language
          takes a similar view of the world as a typical GLSL program. That is,
          a <span class="st200_term term">program</span> consists of exactly one 
          <span class="st200_term term">vertex shader</span>
          and exactly one <span class="st200_term term">fragment shader</span>.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss1pg2" href="#st200_p2s4ss1pg2">2</a></div><div class="st200_paragraph">
          In GLSL, the vertex shader is responsible for assigning values to
          a set of declared outputs, and additionally assigning a clip-space
          vertex position to a built-in variable named 
          <span class="st200_term expression">gl_Position</span>. 
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss1pg3" href="#st200_p2s4ss1pg3">3</a></div><div class="st200_paragraph">
          In <span class="st200_term package">Parasol</span>, a vertex shader
          declares a set of inputs, outputs, and parameters. One of the
          outputs is marked as being the <span class="st200_term term">vertex</span>
          output, to which the programmer is expected to assign a clip-space
          vertex position. There are no built-in names. Input, output, and
          parameter names in <span class="st200_term package">Parasol</span>
          programs will appear exactly as written in the resulting GLSL
          and are therefore subject to the same naming restrictions (and
          this is checked by the compiler).
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss1pg4" href="#st200_p2s4ss1pg4">4</a></div><div class="st200_paragraph">
          In early versions
          of GLSL, the fragment shader was responsible for calculating a single
          RGBA colour vector and assigning it to a built-in variable called
          <span class="st200_term expression">gl_FragColor</span>. In later versions
          of OpenGL, it became possible to have multiple colour attachments
          to framebuffers, and therefore it became necessary for the fragment
          shader to assign multiple outputs. The <span class="st200_term expression">gl_FragColor</span>
          variable was essentially replaced with the
          <span class="st200_term expression">gl_FragData</span> variable, which is
          of an array type. In modern OpenGL, the 
          <span class="st200_term expression">gl_FragColor</span> and
          <span class="st200_term expression">gl_FragData</span> variables have been
          removed, and programmers are required to explicitly declare named
          fragment shader outputs.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss1pg5" href="#st200_p2s4ss1pg5">5</a></div><div class="st200_paragraph">
          In <span class="st200_term package">Parasol</span>, a fragment shader
          declares a set of inputs, outputs, and parameters. All of the
          outputs must be named and numbered. This allows the compiler to
          map numbered outputs to the <span class="st200_term expression">gl_FragData</span>
          array in early versions of GLSL, and to correctly declare
          named outputs in modern GLSL. The compiler checks that output
          numbers start at <span class="st200_term constant">0</span> and
          increase monotonically.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss1pg6" href="#st200_p2s4ss1pg6">6</a></div><div class="st200_paragraph">
          As stated previously, in GLSL a vertex or fragment shader is 
          typically represented by a single file and execution begins 
          at a function called <span class="st200_term expression">main</span>.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss1pg7" href="#st200_p2s4ss1pg7">7</a></div><div class="st200_paragraph">
          The <span class="st200_term package">Parasol</span> language implements
          a simple module system to promote re-use of code, and all functions,
          types, and shaders must be declared inside of modules. Vertex
          and fragment shaders are declared inside of modules and then
          aggregated into <span class="st200_term term">programs</span>. When it
          comes time to produce GLSL, the programmer provides the
          <span class="st200_term term">fully-qualified</span> name of a
          declared <span class="st200_term term">program</span> and the compiler
          produces a set of GLSL shaders based on the selection.
        </div></div></div><div class="st200_subsection_container"><div class="st200_subsection_title_number"><a id="st200_p2s4ss2" href="#st200_p2s4ss2">2.4.2</a></div><div class="st200_subsection_title">Hello World GLSL</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss2pg1" href="#st200_p2s4ss2pg1">1</a></div><div class="st200_paragraph">
          A simple GLSL vertex shader in GLSL 1.40 that simply transforms
          the given object-space coordinates to clip-space by multiplying
          by a given modelview and projection matrix:
        </div></div><div class="st200_formal_item"><div class="st200_formal_item_title"><a id="st200_p2s4ss2fo1" href="#st200_p2s4ss2fo1">2.4.2.1. Hello World GLSL - Vertex shader</a></div><pre class="st200_verbatim">#version 140

in vec4 v_position;
uniform mat4 m_modelview;
uniform mat4 m_projection;

void
main ()
{
  gl_Position = m_projection * m_modelview * v_position;
}
</pre></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss2pg2" href="#st200_p2s4ss2pg2">2</a></div><div class="st200_paragraph">
          A simple fragment shader in GLSL 1.40 that declares a colour
          output and assigns a constant red colour to it:
        </div></div><div class="st200_formal_item"><div class="st200_formal_item_title"><a id="st200_p2s4ss2fo2" href="#st200_p2s4ss2fo2">2.4.2.2. Hello World GLSL - Fragment shader</a></div><pre class="st200_verbatim">#version 140

out vec4 out_rgba;

void
main ()
{
  out_rgba = vec4 (1.0, 0.0, 0.0, 1.0);
}</pre></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss2pg3" href="#st200_p2s4ss2pg3">3</a></div><div class="st200_paragraph">
          The programmer then compiles and loads each shader file from the
          OpenGL API, links them, and then uses them.
        </div></div></div><div class="st200_subsection_container"><div class="st200_subsection_title_number"><a id="st200_p2s4ss3" href="#st200_p2s4ss3">2.4.3</a></div><div class="st200_subsection_title">Hello World Parasol</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss3pg1" href="#st200_p2s4ss3pg1">1</a></div><div class="st200_paragraph">
          As stated, all terms, types, and shaders must be declared in
          modules. For this tutorial, a <span class="st200_term expression">HelloWorld</span>
          module suffices, declared in package
          <span class="st200_term expression">com.io7m.examples</span>.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss3pg2" href="#st200_p2s4ss3pg2">2</a></div><div class="st200_paragraph">
          The previous GLSL shaders translated to <span class="st200_term package">Parasol</span>
          become:
        </div></div><div class="st200_formal_item"><div class="st200_formal_item_title"><a id="st200_p2s4ss3fo1" href="#st200_p2s4ss3fo1">2.4.3.1. Hello World Parasol</a></div><pre class="st200_verbatim">package com.io7m.examples;

module HelloWorld is

  import com.io7m.parasol.Matrix4x4f as M4;

  shader vertex v is
    in         v_position   : vector_4f;
    parameter  m_modelview  : matrix_4x4f;
    parameter  m_projection : matrix_4x4f;
    out vertex o            : vector_4f;
  with
    value position_clip =
      M4.multiply_vector (M4.multiply (m_projection, m_modelview), v_position);
  as
    out o = position_clip;
  end;

  shader fragment f is
    out o : vector_4f as 0;
  with
    value red =
      new vector_4f (1.0, 0.0, 0.0, 1.0);
  as
    out o = red;
  end;

  shader program p is
    vertex v;
    fragment f;
  end;

end;</pre></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss3pg3" href="#st200_p2s4ss3pg3">3</a></div><div class="st200_paragraph">
          The module declares a vertex shader named <span class="st200_term type">v</span>,
          a fragment shader named <span class="st200_term type">p</span>, and combines the two
          into a program named <span class="st200_term type">p</span>. Any number of
          shaders and programs can be declared in a single module (but their names
          must obviously differ).
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss3pg4" href="#st200_p2s4ss3pg4">4</a></div><div class="st200_paragraph">
          The vertex shader declares an input <span class="st200_term expression">v_position</span>,
          two parameters <span class="st200_term expression">m_modelview</span> and
          <span class="st200_term expression">m_projection</span>, and an output named
          <span class="st200_term expression">o</span> which is marked as the main
          vertex output with the <span class="st200_term expression">vertex</span> keyword.
          The shader performs the same multiplication as the GLSL program, assigning
          the result to a local variable named <span class="st200_term expression">position_clip</span>.
          Variables in <span class="st200_term package">Parasol</span> are immutable
          and the programmer is not required to state the types of values because
          the language features local type inference. Finally, the shader writes
          the calculated value to the output
          <span class="st200_term expression">o</span> with an 
          <span class="st200_term term">output assignment</span>. The right-hand side of
          an <span class="st200_term term">output assignment</span> is required to be
          a name <span class="st200_footnote_reference"><a id="st200_fn_6_ref" href="#st200_fn_6">[6]</a></span>. The <span class="st200_term package">Parasol</span> compiler
          requires that all outputs be assigned.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss3pg5" href="#st200_p2s4ss3pg5">5</a></div><div class="st200_paragraph">
          Because the language only provides functions and not operators, the order
          of operations is completely unambiguous; the arguments to functions are
          evaluated eagerly from left to right and then substituted into the body
          of the function. Does the multiplication in the GLSL version mean
          <span class="st200_term expression">(p * m) * v</span> or
          <span class="st200_term expression">p * (m * v)</span>? In this case, it may
          not matter, but what about in more complicated expressions with
          overloading? Programmers get this wrong constantly. The 
          <span class="st200_term package">Parasol</span>
          language keeps things explicit - mistakes become difficult to make.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss3pg6" href="#st200_p2s4ss3pg6">6</a></div><div class="st200_paragraph">
          The fragment shader simply declares a value named <span class="st200_term expression">red</span>
          and assigns it to the single declared output named <span class="st200_term expression">o</span>.
          Note that <span class="st200_term expression">o</span> is assigned both a name
          and a number; this is required by the language.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss3pg7" href="#st200_p2s4ss3pg7">7</a></div><div class="st200_paragraph">
          The program <span class="st200_term type">p</span> states that it uses
          the vertex shader <span class="st200_term type">v</span> and the fragment
          shader <span class="st200_term type">f</span>. The compiler will check that
          the programs are <span class="st200_term term">compatible</span> when
          <span class="st200_term type">p</span> is declared. The rules for
          <span class="st200_term term">compatibility</span> are the same as they
          are for GLSL; the vertex shader must have a corresponding output
          with the same name and type as each of the fragment shader's
          inputs.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss3pg8" href="#st200_p2s4ss3pg8">8</a></div><div class="st200_paragraph">
          Assuming that the above is in a file named <span class="st200_term file">HelloWorld.txt</span>
          and that the resulting GLSL shaders should be written to a directory
          called <span class="st200_term file">/tmp/shaders</span>, the program can be compiled
          as follows:
        </div></div><div class="st200_formal_item"><div class="st200_formal_item_title"><a id="st200_p2s4ss3fo2" href="#st200_p2s4ss3fo2">2.4.3.2. Compilation</a></div><pre class="st200_verbatim">$ java -jar jparasol-c.jar --compile-one /tmp/shaders com.io7m.examples.HelloWorld.p HelloWorld.txt</pre></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss3pg9" href="#st200_p2s4ss3pg9">9</a></div><div class="st200_paragraph">
          The compiler says nothing unless an error occurs.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss3pg10" href="#st200_p2s4ss3pg10">10</a></div><div class="st200_paragraph">
          By default, the compiler will attempt to produce GLSL shaders for all
          known versions of GLSL. It will silently fail to produce a program for
          a version that cannot be supported. In the case of the above program,
          there are no versions of GLSL that cannot support the program. It is 
          usually more desirable to specify a range of required versions and have the
          compiler raise an error when it cannot produce code for one or more
          versions. To compile the same program but with the requirement that
          all versions of GLSL must be supported:
        </div></div><div class="st200_formal_item"><div class="st200_formal_item_title"><a id="st200_p2s4ss3fo3" href="#st200_p2s4ss3fo3">2.4.3.3. Compilation (versions)</a></div><pre class="st200_verbatim">$ java -jar jparasol-c.jar --require-glsl [,] --require-glsl-es [,] --compile-one /tmp/shaders com.io7m.examples.HelloWorld.p HelloWorld.txt</pre></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss3pg11" href="#st200_p2s4ss3pg11">11</a></div><div class="st200_paragraph">
          The <span class="st200_term expression">[,]</span> notation is standard
          mathematical range notation. This particular expression represents
          an inclusive upper and lower bound that effectively covers all versions.
          The notation is <a class="st200_link" href="#st200_p3s1ss7">explained fully</a>
          in the documentation for the compiler frontend.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss3pg12" href="#st200_p2s4ss3pg12">12</a></div><div class="st200_paragraph">
          An examination of the output directory will show that the compiler
          has produced code for all of the GLSL versions:
        </div></div><div class="st200_formal_item"><div class="st200_formal_item_title"><a id="st200_p2s4ss3fo4" href="#st200_p2s4ss3fo4">2.4.3.4. Compilation output</a></div><pre class="st200_verbatim">$ ls -alF /tmp/shaders/
total 0
drwxr-xr-x  5 nobody nobody   100 2014-06-11 18:06 ./
drwxrwxrwt 66 root   root    6020 2014-06-11 18:06 ../
drwxr-xr-x  2 nobody nobody   320 2014-06-11 18:06 com.io7m.examples.HelloWorld.f/
drwxr-xr-x  2 nobody nobody    60 2014-06-11 18:06 com.io7m.examples.HelloWorld.p/
drwxr-xr-x  2 nobody nobody   320 2014-06-11 18:06 com.io7m.examples.HelloWorld.v/

$ cat /tmp/shaders/com.io7m.examples.HelloWorld.v/glsl-110.v
#version 110

attribute vec4 v_position;
uniform mat4 m_modelview;
uniform mat4 m_projection;
varying vec4 o;

void
main (void)
{
  vec4 pl_position_clip = ((m_projection * m_modelview) * v_position);
  gl_Position = pl_position_clip;
  o = pl_position_clip;
}

$ cat /tmp/shaders/com.io7m.examples.HelloWorld.f/glsl-110.f
#version 110

void
main (void)
{
  vec4 pl_red = vec4 (1.0, 0.0, 0.0, 1.0);
  gl_FragColor = pl_red;
}

$ cat /tmp/shaders/com.io7m.examples.HelloWorld.v/glsl-140.v
#version 140

in vec4 v_position;
uniform mat4 m_modelview;
uniform mat4 m_projection;
out vec4 o;

void
main (void)
{
  vec4 pl_position_clip = ((m_projection * m_modelview) * v_position);
  gl_Position = pl_position_clip;
  o = pl_position_clip;
}

$ cat /tmp/shaders/com.io7m.examples.HelloWorld.f/glsl-140.f
#version 140

out vec4 o;

void
main (void)
{
  vec4 pl_red = vec4 (1.0, 0.0, 0.0, 1.0);
  o = pl_red;
}

$ cat /tmp/shaders/com.io7m.examples.HelloWorld.v/glsl-es-100.v
#version 100

precision highp float;
precision highp int;

attribute vec4 v_position;
uniform mat4 m_modelview;
uniform mat4 m_projection;
varying vec4 o;

void
main (void)
{
  vec4 pl_position_clip = ((m_projection * m_modelview) * v_position);
  gl_Position = pl_position_clip;
  o = pl_position_clip;
}

$ cat /tmp/shaders/com.io7m.examples.HelloWorld.f/glsl-es-100.f
#version 100

precision highp float;
precision highp int;

void
main (void)
{
  vec4 pl_red = vec4 (1.0, 0.0, 0.0, 1.0);
  gl_FragColor = pl_red;
}</pre></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s4ss3pg13" href="#st200_p2s4ss3pg13">13</a></div><div class="st200_paragraph">
          As can be seen, the resulting GLSL program is almost identical,
          with the added bonus that the <span class="st200_term package">Parasol</span>
          version provides code for all possible GLSL versions.
        </div></div></div></div><div class="st200_section_container"><div class="st200_section_title_number"><a id="st200_p2s5" href="#st200_p2s5">2.5</a></div><div class="st200_section_title">Where next?</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s5pg1" href="#st200_p2s5pg1">1</a></div><div class="st200_paragraph">
        The <a class="st200_link_external" href="http://io7m.github.io/jparasol//specification/index-m.xhtml">specification</a>
        gives the precise formal definitions for the language, and a complete listing
        of the standard libraries.
      </div></div></div></div><div class="st200_part_container"><div class="st200_part_title_number"><a id="st200_p3" href="#st200_p3">3</a></div><div class="st200_part_title">Tools reference</div><ul class="st200_contents st200_part_contents_outer st200_part_contents"><li class="st200_contents_item st200_contents_item1 st200_contents_item_section"><a href="#st200_p3s1">3.1. jparasol-c</a><ul class="st200_contents st200_section_contents"><li class="st200_contents_item st200_contents_item2 st200_contents_item_subsection"><a href="#st200_p3s1ss1">3.1.1. Overview</a></li><li class="st200_contents_item st200_contents_item2 st200_contents_item_subsection"><a href="#st200_p3s1ss2">3.1.2. Compile</a></li><li class="st200_contents_item st200_contents_item2 st200_contents_item_subsection"><a href="#st200_p3s1ss3">3.1.3. Check</a></li><li class="st200_contents_item st200_contents_item2 st200_contents_item_subsection"><a href="#st200_p3s1ss4">3.1.4. Compile Batch</a></li><li class="st200_contents_item st200_contents_item2 st200_contents_item_subsection"><a href="#st200_p3s1ss5">3.1.5. Zip</a></li><li class="st200_contents_item st200_contents_item2 st200_contents_item_subsection"><a href="#st200_p3s1ss6">3.1.6. Compaction</a></li><li class="st200_contents_item st200_contents_item2 st200_contents_item_subsection"><a href="#st200_p3s1ss7">3.1.7. Range notation</a></li><li class="st200_contents_item st200_contents_item2 st200_contents_item_subsection"><a href="#st200_p3s1ss8">3.1.8. Batches</a></li><li class="st200_contents_item st200_contents_item2 st200_contents_item_subsection"><a href="#st200_p3s1ss9">3.1.9. Logging</a></li></ul></li></ul><div class="st200_section_container"><div class="st200_section_title_number"><a id="st200_p3s1" href="#st200_p3s1">3.1</a></div><div class="st200_section_title">jparasol-c</div><ul class="st200_contents st200_section_contents_outer st200_section_contents"><li class="st200_contents_item st200_contents_item1 st200_contents_item_subsection"><a href="#st200_p3s1ss1">3.1.1. Overview</a></li><li class="st200_contents_item st200_contents_item1 st200_contents_item_subsection"><a href="#st200_p3s1ss2">3.1.2. Compile</a></li><li class="st200_contents_item st200_contents_item1 st200_contents_item_subsection"><a href="#st200_p3s1ss3">3.1.3. Check</a></li><li class="st200_contents_item st200_contents_item1 st200_contents_item_subsection"><a href="#st200_p3s1ss4">3.1.4. Compile Batch</a></li><li class="st200_contents_item st200_contents_item1 st200_contents_item_subsection"><a href="#st200_p3s1ss5">3.1.5. Zip</a></li><li class="st200_contents_item st200_contents_item1 st200_contents_item_subsection"><a href="#st200_p3s1ss6">3.1.6. Compaction</a></li><li class="st200_contents_item st200_contents_item1 st200_contents_item_subsection"><a href="#st200_p3s1ss7">3.1.7. Range notation</a></li><li class="st200_contents_item st200_contents_item1 st200_contents_item_subsection"><a href="#st200_p3s1ss8">3.1.8. Batches</a></li><li class="st200_contents_item st200_contents_item1 st200_contents_item_subsection"><a href="#st200_p3s1ss9">3.1.9. Logging</a></li></ul><div class="st200_subsection_container"><div class="st200_subsection_title_number"><a id="st200_p3s1ss1" href="#st200_p3s1ss1">3.1.1</a></div><div class="st200_subsection_title">Overview</div><div class="st200_formal_item"><div class="st200_formal_item_title"><a id="st200_p3s1ss1fo1" href="#st200_p3s1ss1fo1">3.1.1.1. Options</a></div><pre class="st200_verbatim">parasol-c: [options] --compile-one output shader file0 [file1 ... fileN]
  or [options] --compile-batch output batch-list source-list
  or [options] --check file0 [file1 ... fileN]
  or [options] --show-versions
  or [options] --version</pre></div></div><div class="st200_subsection_container"><div class="st200_subsection_title_number"><a id="st200_p3s1ss2" href="#st200_p3s1ss2">3.1.2</a></div><div class="st200_subsection_title">Compile</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s1ss2pg1" href="#st200_p3s1ss2pg1">1</a></div><div class="st200_paragraph">
          The <span class="st200_term command">--compile-one</span> command accepts an output directory 
          (or archive, see <a class="st200_link" href="#st200_p3s1ss5">--zip</a>)
          <span class="st200_term variable">o</span>,
          the fully-qualified name of a program <span class="st200_term variable">p</span>, 
          and a list of one or more <span class="st200_term package">Parasol</span> source files. 
          The files are parsed and type-checked and then 
          <span class="st200_term variable">p</span>, 
          and the constituent shaders of <span class="st200_term variable">p</span>,
          are transformed to GLSL and written
          to <span class="st200_term variable">o</span> (creating the directory if it does not
          already exist).
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s1ss2pg2" href="#st200_p3s1ss2pg2">2</a></div><div class="st200_paragraph">
          The <span class="st200_term command">--require-glsl</span> and
          <span class="st200_term command">--require-glsl-es</span> options specify the GLSL
          and GLSL ES versions for which the compiler <span class="st200_term term">must</span>
          generate code. The compiler will raise an error if the program cannot
          be supported on one or more versions. The 
          <a class="st200_link" href="#st200_p3s1ss7">notation</a> for specifying versions
          is described below. If these options are not specified, the compiler will 
          attempt to generate code for all versions but will not raise an error if 
          code cannot be generated for one or more versions.
        </div></div></div><div class="st200_subsection_container"><div class="st200_subsection_title_number"><a id="st200_p3s1ss3" href="#st200_p3s1ss3">3.1.3</a></div><div class="st200_subsection_title">Check</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s1ss3pg1" href="#st200_p3s1ss3pg1">1</a></div><div class="st200_paragraph">
          The <span class="st200_term command">--check</span> command accepts a list of one or more 
          <span class="st200_term package">Parasol</span> source files. 
          The files are parsed and type-checked and any errors are printed on the
          standard error stream.
        </div></div></div><div class="st200_subsection_container"><div class="st200_subsection_title_number"><a id="st200_p3s1ss4" href="#st200_p3s1ss4">3.1.4</a></div><div class="st200_subsection_title">Compile Batch</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s1ss4pg1" href="#st200_p3s1ss4pg1">1</a></div><div class="st200_paragraph">
          The <span class="st200_term command">--compile-batch</span> command accepts a base directory 
          <span class="st200_term variable">b</span>,
          a file <span class="st200_term variable">f</span> containing a list of 
          <a class="st200_link" href="#st200_p3s1ss8">batches</a>, 
          and a file <span class="st200_term variable">s</span> containing a list of
          source files with one file per line.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s1ss4pg2" href="#st200_p3s1ss4pg2">2</a></div><div class="st200_paragraph">
          For each program <span class="st200_term variable">p</span> in the list
          of batches, the compiler will produce a GLSL program in <span class="st200_term file">b/p</span>.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s1ss4pg3" href="#st200_p3s1ss4pg3">3</a></div><div class="st200_paragraph">
          The <span class="st200_term command">--require-glsl</span> and
          <span class="st200_term command">--require-glsl-es</span> options specify the GLSL
          and GLSL ES versions for which the compiler <span class="st200_term term">must</span>
          generate code. The compiler will raise an error if the program cannot
          be supported on one or more versions. The 
          <a class="st200_link" href="#st200_p3s1ss7">notation</a> for specifying versions
          is described below. If these options are not specified, the compiler will 
          attempt to generate code for all versions but will not raise an error if 
          code cannot be generated for one or more versions.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s1ss4pg4" href="#st200_p3s1ss4pg4">4</a></div><div class="st200_paragraph">
          The command is intended to be used to process thousands of
          programs. The compiler supports multi-threaded program processing
          and can, after parsing and type-checking, produce multiple GLSL
          programs from the resulting typed AST in parallel. The
          <span class="st200_term command">--threads</span> option specifies
          the number of threads that should be used during batch compilation,
          with <span class="st200_term constant">1</span> thread being the default.
        </div></div></div><div class="st200_subsection_container"><div class="st200_subsection_title_number"><a id="st200_p3s1ss5" href="#st200_p3s1ss5">3.1.5</a></div><div class="st200_subsection_title">Zip</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s1ss5pg1" href="#st200_p3s1ss5pg1">1</a></div><div class="st200_paragraph">
          When the <span class="st200_term parameter">--zip</span> parameter is
          specified, the output path is instead assumed to be an archive
          that will be created and populated with the resulting shading 
          programs.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s1ss5pg2" href="#st200_p3s1ss5pg2">2</a></div><div class="st200_paragraph">
          By default, any file that exists at the named output path will
          be replaced. When the <span class="st200_term parameter">--zip-append</span>
          option is specified, the output path is assumed to refer to an
          existing zip archive, which will be updated with the generated
          files.
        </div></div></div><div class="st200_subsection_container"><div class="st200_subsection_title_number"><a id="st200_p3s1ss6" href="#st200_p3s1ss6">3.1.6</a></div><div class="st200_subsection_title">Compaction</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s1ss6pg1" href="#st200_p3s1ss6pg1">1</a></div><div class="st200_paragraph">
          Normally, one source file will be emitted per version of GLSL. Often,
          these different source files will actually be identical in content
          apart from a <span class="st200_term keyword">#version</span> directive on
          the first line of the file.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s1ss6pg2" href="#st200_p3s1ss6pg2">2</a></div><div class="st200_paragraph">
          When the <span class="st200_term parameter">--compact</span> parameter is
          specified, shaders will be written in so-called 
          <span class="st200_term term">compacted</span> form. Essentially, source
          files are stripped of their version directives and then hashed with
          <span class="st200_term function">SHA256</span>. Then, each source file
          is renamed to its <span class="st200_term function">SHA256</span> hash
          with the addition of its original suffix, and a set of mappings
          from GLSL versions to <span class="st200_term function">SHA256</span> hashes
          are written into the program's <span class="st200_term function">meta.xml</span>
          file. The user is responsible for re-inserting the correct version
          directive upon passing the program to a GLSL compiler.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s1ss6pg3" href="#st200_p3s1ss6pg3">3</a></div><div class="st200_paragraph">
          The storage space savings of compaction are typically in the range 
          60-70%. In rendering systems that use thousands of shaders, this can
          be significant!
        </div></div></div><div class="st200_subsection_container"><div class="st200_subsection_title_number"><a id="st200_p3s1ss7" href="#st200_p3s1ss7">3.1.7</a></div><div class="st200_subsection_title">Range notation</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s1ss7pg1" href="#st200_p3s1ss7pg1">1</a></div><div class="st200_paragraph">
          The notation for ranges is given by the following EBNF:
        </div></div><div class="st200_formal_item"><div class="st200_formal_item_title"><a id="st200_p3s1ss7fo1" href="#st200_p3s1ss7fo1">3.1.7.1. Range notation EBNF</a></div><pre class="st200_verbatim">
version-set     := version-segment ( ',' version-segment )*
version-segment := version-exact | version-range
version-exact   := integer
version-range   := ('(' | '[') integer? ',' integer? (')' | ']')</pre></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s1ss7pg2" href="#st200_p3s1ss7pg2">2</a></div><div class="st200_paragraph">
          The <span class="st200_term expression">[</span> and
          <span class="st200_term expression">]</span> characters indicate
          inclusive bounds. The <span class="st200_term expression">(</span> and
          <span class="st200_term expression">)</span> characters indicate
          exclusive bounds.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s1ss7pg3" href="#st200_p3s1ss7pg3">3</a></div><div class="st200_paragraph">
          Some examples from the <span class="st200_term command">jparasol-c</span>
          command line help, with <span class="st200_term keyword">x ⊢ y</span>
          indicating that the notation <span class="st200_term expression">x</span>
          denotes the set of versions <span class="st200_term expression">y</span>.
        </div></div><div class="st200_formal_item"><div class="st200_formal_item_title"><a id="st200_p3s1ss7fo2" href="#st200_p3s1ss7fo2">3.1.7.2. Range notation examples</a></div><pre class="st200_verbatim">
130               ⊢ {130}
[120, 150]        ⊢ {120, 130, 140, 150}
(120, 150]        ⊢ {130, 140, 150}
120,[140,330],430 ⊢ {120, 140, 150, 330, 430}</pre></div></div><div class="st200_subsection_container"><div class="st200_subsection_title_number"><a id="st200_p3s1ss8" href="#st200_p3s1ss8">3.1.8</a></div><div class="st200_subsection_title">Batches</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s1ss8pg1" href="#st200_p3s1ss8pg1">1</a></div><div class="st200_paragraph">
          The syntax for batches is given by the following EBNF:
        </div></div><div class="st200_formal_item"><div class="st200_formal_item_title"><a id="st200_p3s1ss8fo1" href="#st200_p3s1ss8fo1">3.1.8.1. Batches EBNF</a></div><pre class="st200_verbatim">batch := [ name ] , ":" , program_name</pre></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s1ss8pg2" href="#st200_p3s1ss8pg2">2</a></div><div class="st200_paragraph">
          Where <span class="st200_term variable">name</span> is an optional
          output name, and
          <span class="st200_term variable">program_name</span> is the
          fully qualified name of a program (consisting of a package, module,
          and program name). An example
          <span class="st200_term variable">program_name</span> would
          be <span class="st200_term variable">com.io7m.examples.Example.p</span>,
          where <span class="st200_term variable">com.io7m.examples</span> is
          the package, <span class="st200_term variable">Example</span> is the
          module, and <span class="st200_term variable">p</span> is the program.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s1ss8pg3" href="#st200_p3s1ss8pg3">3</a></div><div class="st200_paragraph">
          A batch file contains a list of batches, one per line.
        </div></div></div><div class="st200_subsection_container"><div class="st200_subsection_title_number"><a id="st200_p3s1ss9" href="#st200_p3s1ss9">3.1.9</a></div><div class="st200_subsection_title">Logging</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s1ss9pg1" href="#st200_p3s1ss9pg1">1</a></div><div class="st200_paragraph">
          By default, the compiler remains silent except in the case of
          errors. It is possible to enable more logging for the purposes
          of debugging by providing a configuration file with
          the <span class="st200_term command">--log-properties</span> option.
          The configuration file is a set of Java properties that configure
          the <a class="st200_link_external" href="http://io7m.com/software/jlog">jlog</a>
          package used internally by the compiler and so the documentation
          of that package should be examined for the precise formats of the
          properties.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s1ss9pg2" href="#st200_p3s1ss9pg2">2</a></div><div class="st200_paragraph">
          To save some time, an example file that enables absolutely all
          logging:
        </div></div><div class="st200_formal_item"><div class="st200_formal_item_title"><a id="st200_p3s1ss9fo1" href="#st200_p3s1ss9fo1">3.1.9.1. Maximum logging</a></div><pre class="st200_verbatim">
com.io7m.jparasol.logs.compiler = true
com.io7m.jparasol.level         = LOG_DEBUG</pre></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s1ss9pg3" href="#st200_p3s1ss9pg3">3</a></div><div class="st200_paragraph">
          An example file that enables the minimum debug messages for
          the frontend by disabling logging for all of the main compiler
          components but leaving other messages enabled:
        </div></div><div class="st200_formal_item"><div class="st200_formal_item_title"><a id="st200_p3s1ss9fo2" href="#st200_p3s1ss9fo2">3.1.9.2. Minimal logging</a></div><pre class="st200_verbatim">
com.io7m.jparasol.logs.compiler                 = true
com.io7m.jparasol.logs.compiler.pipeline        = false
com.io7m.jparasol.logs.compiler.gpipeline       = false
com.io7m.jparasol.logs.compiler.compactor       = false
com.io7m.jparasol.logs.compiler.serializer-zip  = false
com.io7m.jparasol.logs.compiler.serializer-file = false
com.io7m.jparasol.level                         = LOG_DEBUG</pre></div></div></div></div><div class="st200_part_container"><div class="st200_part_title_number"><a id="st200_p4" href="#st200_p4">4</a></div><div class="st200_part_title">API Reference</div><ul class="st200_contents st200_part_contents_outer st200_part_contents"><li class="st200_contents_item st200_contents_item1 st200_contents_item_section"><a href="#st200_p4s1">4.1. Javadoc</a></li></ul><div class="st200_section_container"><div class="st200_section_title_number"><a id="st200_p4s1" href="#st200_p4s1">4.1</a></div><div class="st200_section_title">Javadoc</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p4s1pg1" href="#st200_p4s1pg1">1</a></div><div class="st200_paragraph">
        API documentation for the package is provided via the
        included <a class="st200_link_external" href="apidocs">Javadoc</a>.
      </div></div></div></div><div class="st200_footnotes"><hr/><div class="st200_footnote_container"><div class="st200_footnote_number">[<a id="st200_fn_0" href="#st200_fn_0_ref">0</a>]</div><div class="st200_footnote_body">
            <a class="st200_link_external" href="http://semver.org">http://semver.org</a>
          </div></div><div class="st200_footnote_container"><div class="st200_footnote_number">[<a id="st200_fn_1" href="#st200_fn_1_ref">1</a>]</div><div class="st200_footnote_body">
            This often causes serious performance problems. See
            <a class="st200_link_external" href="http://www.humus.name/Articles/Persson_LowlevelShaderOptimization.pdf">Low-level Thinking in High-Level Shading Language Programs</a>.
          </div></div><div class="st200_footnote_container"><div class="st200_footnote_number">[<a id="st200_fn_2" href="#st200_fn_2_ref">2</a>]</div><div class="st200_footnote_body">
            Consider the <span class="st200_term function">trunc</span> function. This
            function is not available on certain versions of GLSL, but is equivalent
            to the expression <span class="st200_term expression">sign(x) * floor(abs(x))</span>
            for some <span class="st200_term expression">x</span>.
            The compiler can provide a software emulation in this case, allowing the
            programmer to safely call <span class="st200_term package">Parasol</span>'s
            <span class="st200_term function">Float.truncate</span> function anywhere without
            issue.
          </div></div><div class="st200_footnote_container"><div class="st200_footnote_number">[<a id="st200_fn_3" href="#st200_fn_3_ref">3</a>]</div><div class="st200_footnote_body">
            For example, if the programmer writes a fragment shader that writes
            to multiple outputs, there is no way this program can run on OpenGL ES 2
            and there is no way that the compiler can provide any kind of emulation
            to work around the problem.
          </div></div><div class="st200_footnote_container"><div class="st200_footnote_number">[<a id="st200_fn_4" href="#st200_fn_4_ref">4</a>]</div><div class="st200_footnote_body">
            The language actually rejects operators entirely, to keep
            the language definition as simple as possible.
          </div></div><div class="st200_footnote_container"><div class="st200_footnote_number">[<a id="st200_fn_5" href="#st200_fn_5_ref">5</a>]</div><div class="st200_footnote_body">
            It is possible to express all of the shaders required
            to implement a renderer equal in capability to that of
            the
            <a class="st200_link_external" href="http://source.valvesoftware.com">Source</a>
            engine (circa 2014) without any loops or arrays.
          </div></div><div class="st200_footnote_container"><div class="st200_footnote_number">[<a id="st200_fn_6" href="#st200_fn_6_ref">6</a>]</div><div class="st200_footnote_body">
            The reason for this is because the GLSL standard has various rules
            about how and when shader outputs must be assigned. <span class="st200_term package">Parasol</span>
            language programs <span class="st200_term term">syntactically</span> guarantee that either all outputs are
            assigned, or none of them are.
          </div></div></div></div></body></html>
