<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>io7m-jparasol 0.11.3 Documentation: 2.3. What?</title><link rel="stylesheet" type="text/css" href="jstructural-2.0.0-layout.css"/><link rel="stylesheet" type="text/css" href="jstructural-2.0.0-colour.css"/><link rel="stylesheet" type="text/css" href="documentation.css"/></head><body><div class="st200_body"><div class="brand">
  <div class="brand_left">
    <a href="http://io7m.com/">io7m</a>
  </div>
  <div class="brand_right">
    <a href="http://io7m.github.io/jparasol/">io7m-jparasol</a> 0.11.3
  </div>
</div><div class="st200_navbar st200_navbar_top"><table class="st200_navbar_table" summary="Navigation bar"><tr><td class="st200_navbar_prev_title_cell">2.2. Why?</td><td class="st200_navbar_up_title_cell">2. Language Tutorial</td><td class="st200_navbar_next_title_cell">2.4. How?</td></tr><tr><td class="st200_navbar_prev_file_cell"><a href="p2s2.xhtml#st200_p2s2">Previous</a></td><td class="st200_navbar_up_file_cell"><a href="p2.xhtml#st200_p2">Up</a></td><td class="st200_navbar_next_file_cell"><a href="p2s4.xhtml#st200_p2s4">Next</a></td></tr></table><hr class="st200_hr"/></div><div class="st200_section_container"><div class="st200_section_title_number"><a id="st200_p2s3" href="#st200_p2s3">2.3</a></div><div class="st200_section_title">What?</div><div class="st200_subsection_container"><div class="st200_subsection_title_number"><a id="st200_p2s3ss1" href="#st200_p2s3ss1">2.3.1</a></div><div class="st200_subsection_title">Parasol</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s3ss1pg1" href="#st200_p2s3ss1pg1">1</a></div><div class="st200_paragraph">
          The <span class="st200_term package">Parasol</span> language is an aggressively
          minimalist pure-functional shading language. The intention is to provide
          a language with simple and predictable semantics that can then be
          compiled to all possible versions of GLSL, eliminating all of the versioning
          concerns previously expressed. On versions of GLSL that do not provide certain
          functions, the compiler silently provides emulations 
          <span class="st200_footnote_reference"><a id="st200_fn_2_ref" href="#st200_fn_2">[2]</a></span>. Essentially, the programmer provides a
          <span class="st200_term package">Parasol</span> program and a range of GLSL versions
          upon which the program is expected to run. The compiler produces GLSL for
          all of the possible versions and will raise errors if a valid program really cannot
          be produced for a particular GLSL version 
          <span class="st200_footnote_reference"><a id="st200_fn_3_ref" href="#st200_fn_3">[3]</a></span>.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s3ss1pg2" href="#st200_p2s3ss1pg2">2</a></div><div class="st200_paragraph">
          The <span class="st200_term package">Parasol</span> language is
          both pure-functional and <span class="st200_term term">total</span>. That
          is, programs do not have side effects and are guaranteed to
          terminate. The language statically rejects recursive and mutually
          recursive terms, and does not provide looping constructs or
          arrays.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s3ss1pg3" href="#st200_p2s3ss1pg3">3</a></div><div class="st200_paragraph">
          The <span class="st200_term package">Parasol</span> language categorically
          rejects operator and function overloading 
          <span class="st200_footnote_reference"><a id="st200_fn_4_ref" href="#st200_fn_4">[4]</a></span>; the programmer always knows exactly which function
          is being applied on sight. This eliminates the correctness issues
          caused by pervasive overloading.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s3ss1pg4" href="#st200_p2s3ss1pg4">4</a></div><div class="st200_paragraph">
          The language provides a simple non-hierarchical module and package
          system for controlling the namespace. <span class="st200_term package">Parasol</span>
          programs can be developed as sets of re-usable libraries without
          any fear of name collisions. The language works from the assumption
          that, although shader programs are likely to be short and linear, 
          there are also likely to be a large number of them, with significant 
          amounts of duplicated code. The <span class="st200_term package">Parasol</span>
          module system allows code to be imported and re-used safely, with full
          type checking and without requiring a complicated and error-prone
          preprocessor.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s3ss1pg5" href="#st200_p2s3ss1pg5">5</a></div><div class="st200_paragraph">
          The <span class="st200_term package">jparasol</span> compiler is a strictly
          offline compiler developed in Java. The compiler takes 
          <span class="st200_term package">Parasol</span>
          programs as input, and produces GLSL programs (and additional metadata)
          as output. The produced GLSL can then be loaded as normal in any OpenGL program
          and has no dependencies on <span class="st200_term package">Parasol</span>,
          the <span class="st200_term package">jparasol</span> compiler, or anything else.
          The additional metadata produced as output describes various properties
          of the program. This means that programmers are not required to 
          parse <span class="st200_term package">Parasol</span>
          programs to, for example, determine all of the declared inputs, 
          parameters, and outputs. The metadata is an optional component; 
          programmers are not required to use it in order to make use of
          compiled GLSL programs.
        </div></div></div><div class="st200_subsection_container"><div class="st200_subsection_title_number"><a id="st200_p2s3ss2" href="#st200_p2s3ss2">2.3.2</a></div><div class="st200_subsection_title">Limitations</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s3ss2pg1" href="#st200_p2s3ss2pg1">1</a></div><div class="st200_paragraph">
          The language considers portability and correctness
          to be more important than exposing the latest flashy 
          features of GLSL. The language therefore exposes 
          features roughly analogous
          to version <span class="st200_term constant">1.40</span> of
          GLSL in an attempt to provide the subset of OpenGL and
          GLSL that will work on as many implementations as possible. 
          The language does not support geometry shaders
          or tesselation shaders. The language does not support
          double-precision floating point. These features will
          likely be introduced as time moves on and older versions
          of OpenGL disappear into history.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s3ss2pg2" href="#st200_p2s3ss2pg2">2</a></div><div class="st200_paragraph">
          As described, the language is currently <span class="st200_term term">total</span>,
          meaning that all programs are guaranteed to terminate. This
          is both a desirable property (because non-terminating shader
          programs are extremely bad news on some OpenGL implementations), and
          a severe limitation (because programs that require loops cannot
          be expressed in <span class="st200_term package">Parasol</span>
          at all). In practice, this has not turned out to be much of
          a problem
          <span class="st200_footnote_reference"><a id="st200_fn_5_ref" href="#st200_fn_5">[5]</a></span>. The shading programs found in most
          game engines tend to be linear in nature and do 
          not require iterating over arrays of values.
        </div></div></div></div><div class="st200_footnotes"><hr/><div class="st200_footnote_container"><div class="st200_footnote_number">[<a id="st200_fn_2" href="#st200_fn_2_ref">2</a>]</div><div class="st200_footnote_body">
            Consider the <span class="st200_term function">trunc</span> function. This
            function is not available on certain versions of GLSL, but is equivalent
            to the expression <span class="st200_term expression">sign(x) * floor(abs(x))</span>
            for some <span class="st200_term expression">x</span>.
            The compiler can provide a software emulation in this case, allowing the
            programmer to safely call <span class="st200_term package">Parasol</span>'s
            <span class="st200_term function">Float.truncate</span> function anywhere without
            issue.
          </div></div><div class="st200_footnote_container"><div class="st200_footnote_number">[<a id="st200_fn_3" href="#st200_fn_3_ref">3</a>]</div><div class="st200_footnote_body">
            For example, if the programmer writes a fragment shader that writes
            to multiple outputs, there is no way this program can run on OpenGL ES 2
            and there is no way that the compiler can provide any kind of emulation
            to work around the problem.
          </div></div><div class="st200_footnote_container"><div class="st200_footnote_number">[<a id="st200_fn_4" href="#st200_fn_4_ref">4</a>]</div><div class="st200_footnote_body">
            The language actually rejects operators entirely, to keep
            the language definition as simple as possible.
          </div></div><div class="st200_footnote_container"><div class="st200_footnote_number">[<a id="st200_fn_5" href="#st200_fn_5_ref">5</a>]</div><div class="st200_footnote_body">
            It is possible to express all of the shaders required
            to implement a renderer equal in capability to that of
            the
            <a class="st200_link_external" href="http://source.valvesoftware.com">Source</a>
            engine (circa 2014) without any loops or arrays.
          </div></div></div><div class="st200_navbar st200_navbar_bottom"><hr class="st200_hr"/><table class="st200_navbar_table" summary="Navigation bar"><tr><td class="st200_navbar_prev_file_cell"><a href="p2s2.xhtml#st200_p2s2">Previous</a></td><td class="st200_navbar_up_file_cell"><a href="p2.xhtml#st200_p2">Up</a></td><td class="st200_navbar_next_file_cell"><a href="p2s4.xhtml#st200_p2s4">Next</a></td></tr><tr><td class="st200_navbar_prev_title_cell">2.2. Why?</td><td class="st200_navbar_up_title_cell">2. Language Tutorial</td><td class="st200_navbar_next_title_cell">2.4. How?</td></tr></table></div></div></body></html>
