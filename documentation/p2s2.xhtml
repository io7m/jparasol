<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>io7m-jparasol 0.11.3 Documentation: 2.2. Why?</title><link rel="stylesheet" type="text/css" href="jstructural-2.0.0-layout.css"/><link rel="stylesheet" type="text/css" href="jstructural-2.0.0-colour.css"/><link rel="stylesheet" type="text/css" href="documentation.css"/></head><body><div class="st200_body"><div class="brand">
  <div class="brand_left">
    <a href="http://io7m.com/">io7m</a>
  </div>
  <div class="brand_right">
    <a href="http://io7m.github.io/jparasol/">io7m-jparasol</a> 0.11.3
  </div>
</div><div class="st200_navbar st200_navbar_top"><table class="st200_navbar_table" summary="Navigation bar"><tr><td class="st200_navbar_prev_title_cell">2.1. Prerequisites</td><td class="st200_navbar_up_title_cell">2. Language Tutorial</td><td class="st200_navbar_next_title_cell">2.3. What?</td></tr><tr><td class="st200_navbar_prev_file_cell"><a href="p2s1.xhtml#st200_p2s1">Previous</a></td><td class="st200_navbar_up_file_cell"><a href="p2.xhtml#st200_p2">Up</a></td><td class="st200_navbar_next_file_cell"><a href="p2s3.xhtml#st200_p2s3">Next</a></td></tr></table><hr class="st200_hr"/></div><div class="st200_section_container"><div class="st200_section_title_number"><a id="st200_p2s2" href="#st200_p2s2">2.2</a></div><div class="st200_section_title">Why?</div><div class="st200_subsection_container"><div class="st200_subsection_title_number"><a id="st200_p2s2ss1" href="#st200_p2s2ss1">2.2.1</a></div><div class="st200_subsection_title">Versioning</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s2ss1pg1" href="#st200_p2s2ss1pg1">1</a></div><div class="st200_paragraph">
          GLSL is a versioning and compatibility nightmare: There are, at the 
          time of writing, fourteen different versions of GLSL in use. The 
          versions of OpenGL and GLSL available are tied to hardware and to 
          OpenGL drivers. Different versions of GLSL differ wildly in syntax 
          and in the names of functions defined in the standard library. The 
          same program may have to be rewritten five or six times to deal 
          with trivial syntax differences between versions. The standard
          recommendation is for programs to explicitly mark the version of
          GLSL for which they're intended by including a 
          <span class="st200_term keyword">#version</span> directive at the start
          of the file. Without this directive, many GLSL implementations
          fall back to using the oldest available version, which then typically
          means that the compiler rejects the program as invalid. With a
          <span class="st200_term keyword">#version</span> directive included, the
          programmer is asserting that he/she wishes to use a specific version
          which, of course, may not be available. Certain versions of OpenGL
          (such as OpenGL ES 2), place arbitrary restrictions on programs
          (such as not being able to declare multiple fragment shader outputs).
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s2ss1pg2" href="#st200_p2s2ss1pg2">2</a></div><div class="st200_paragraph">
          Most programmers attempt to work around these problems by layering
          on hacks and preprocessor macros. This is obviously unacceptable to
          programmers that actually care about correctness.
        </div></div></div><div class="st200_subsection_container"><div class="st200_subsection_title_number"><a id="st200_p2s2ss2" href="#st200_p2s2ss2">2.2.2</a></div><div class="st200_subsection_title">Correctness</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s2ss2pg1" href="#st200_p2s2ss2pg1">1</a></div><div class="st200_paragraph">
          GLSL is a nightmare from the perspective of correctness: Programs
          are parsed and type-checked at runtime. The commitee that mismanages 
          OpenGL decided that all OpenGL drivers should implement their own compilers. 
          Apart from the inevitable correctness issues that stem from this requirement, 
          this also means that errors that should be entirely statically detectable 
          are signalled at the latest possible stage (run time). Systems that use 
          thousands of GLSL shaders are required to do obscene amounts of 
          testing to ensure that all of their shaders are valid GLSL.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s2ss2pg2" href="#st200_p2s2ss2pg2">2</a></div><div class="st200_paragraph">
          The language, on one hand, requires explicit type conversions. This is
          generally beneficial because there are none of magical implicit type 
          conversions that appear in somewhat more weakly-typed languages. The
          language then works hard to eliminate the beneficial aspects by overloading
          all functions and operators, so that the programmer really has no idea
          which particular overloaded variant is being used <span class="st200_footnote_reference"><a id="st200_fn_1_ref" href="#st200_fn_1">[1]</a></span>.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s2ss2pg3" href="#st200_p2s2ss2pg3">3</a></div><div class="st200_paragraph">
          The language has no module system and simply dumps its entire standard
          library into the same namespace as the programmer's code. The programmer
          must explicitly prefix the names of any defined functions or variables
          in order to avoid potential collisions. The OpenGL committee are free to
          introduce new name collisions at any time.
        </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s2ss2pg4" href="#st200_p2s2ss2pg4">4</a></div><div class="st200_paragraph">
          There are also very limited facilities for inspecting programs that
          have been compiled. For example, the GLSL compiler is free to remove
          any program inputs or parameters that is has deemed to be unused (and
          has therefore optimized out). The programmer using the shading program
          wants to be able to assign values to inputs by name. Unfortunately,
          without the programmer manually parsing the original program, there
          is no way to tell the difference between an input or parameter that
          has been optimized out, and an input or parameter that never existed
          in the first place. There is no way to distinguish between "The compiler
          removed the parameter" and "I got the name of the parameter wrong".
          The GLSL compiler obviously has this information, but
          it is not made available to the programmer. In order to really guarantee
          correctness, it's necessary for the programmer to reimplement parts 
          of the GLSL compiler!
        </div></div></div><div class="st200_subsection_container"><div class="st200_subsection_title_number"><a id="st200_p2s2ss3" href="#st200_p2s2ss3">2.2.3</a></div><div class="st200_subsection_title">Modularity and re-use</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p2s2ss3pg1" href="#st200_p2s2ss3pg1">1</a></div><div class="st200_paragraph">
          A GLSL shader is represented by a single file. Code that is re-used
          between shaders must either be copied and pasted, or must be inserted
          automatically via some error-prone macro or preprocessor
          system. The GLSL language does not support
          <span class="st200_term keyword">#include</span> directives, so the programmer
          is forced to build their own system to manage pieces of shaders.
        </div></div></div></div><div class="st200_footnotes"><hr/><div class="st200_footnote_container"><div class="st200_footnote_number">[<a id="st200_fn_1" href="#st200_fn_1_ref">1</a>]</div><div class="st200_footnote_body">
            This often causes serious performance problems. See
            <a class="st200_link_external" href="http://www.humus.name/Articles/Persson_LowlevelShaderOptimization.pdf">Low-level Thinking in High-Level Shading Language Programs</a>.
          </div></div></div><div class="st200_navbar st200_navbar_bottom"><hr class="st200_hr"/><table class="st200_navbar_table" summary="Navigation bar"><tr><td class="st200_navbar_prev_file_cell"><a href="p2s1.xhtml#st200_p2s1">Previous</a></td><td class="st200_navbar_up_file_cell"><a href="p2.xhtml#st200_p2">Up</a></td><td class="st200_navbar_next_file_cell"><a href="p2s3.xhtml#st200_p2s3">Next</a></td></tr><tr><td class="st200_navbar_prev_title_cell">2.1. Prerequisites</td><td class="st200_navbar_up_title_cell">2. Language Tutorial</td><td class="st200_navbar_next_title_cell">2.3. What?</td></tr></table></div></div></body></html>
