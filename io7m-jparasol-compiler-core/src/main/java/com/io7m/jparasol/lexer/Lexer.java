/* The following code was generated by JFlex 1.4.3 on 12/12/13 17:19 */

/*
 * Copyright Â© 2013 <code@io7m.com> http://io7m.com
 * 
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
 * IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

package com.io7m.jparasol.lexer;

import java.io.File;
import java.io.IOException;

import javax.annotation.Nonnull;

import com.io7m.jaux.Constraints;
import com.io7m.jaux.Constraints.ConstraintError;

/**
 * This class is a scanner generated by <a
 * href="http://www.jflex.de/">JFlex</a> 1.4.3 on 12/12/13 17:19 from the
 * specification file
 * <tt>src/main/java/com/io7m/jparasol/lexer/Lexer.flex</tt>
 */
public final class Lexer
{

  /** This character denotes the end of file */
  private static final int    YYEOF              = -1;

  /** initial size of the lookahead buffer */
  private static final int    ZZ_BUFFERSIZE      = 16384;

  /** lexical states */
  private static final int    YYINITIAL          = 0;

  /**
   * ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l
   * ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l at the
   * beginning of a line l is of the form l = 2*k, k a non negative integer
   */
  private static final int    ZZ_LEXSTATE[]      = { 0, 0 };

  /**
   * Translates characters to character classes
   */
  private static final String ZZ_CMAP_PACKED     =
                                                   "\11\0\1\7\1\6\1\0\1\7\1\5\22\0\1\7\7\0\1\44"
                                                     + "\1\45\2\0\1\24\1\2\1\4\1\0\1\1\11\3\1\23\1\46"
                                                     + "\1\0\1\33\3\0\32\11\1\47\1\0\1\50\1\0\1\12\1\0"
                                                     + "\1\13\1\10\1\31\1\27\1\20\1\21\1\35\1\43\1\30\1\10"
                                                     + "\1\42\1\22\1\36\1\32\1\37\1\40\1\10\1\16\1\14\1\15"
                                                     + "\1\17\1\52\1\41\1\34\1\51\1\10\1\25\1\0\1\26\uff82\0";

  /**
   * Translates characters to character classes
   */
  private static final char[] ZZ_CMAP            =
                                                   Lexer
                                                     .zzUnpackCMap(Lexer.ZZ_CMAP_PACKED);

  /**
   * Translates DFA states to action switch labels.
   */
  private static final int[]  ZZ_ACTION          = Lexer.zzUnpackAction();

  private static final String ZZ_ACTION_PACKED_0 =
                                                   "\1\0\1\1\1\2\1\1\1\2\1\3\1\4\1\5"
                                                     + "\1\6\7\5\1\7\1\10\1\11\1\12\3\5\1\13"
                                                     + "\4\5\1\14\1\15\1\16\1\17\1\20\1\5\4\0"
                                                     + "\1\21\15\5\1\22\1\23\1\24\11\5\1\25\3\0"
                                                     + "\1\4\6\5\1\26\4\5\1\27\2\5\1\30\1\5"
                                                     + "\1\31\6\5\1\0\1\5\1\32\1\33\1\34\1\5"
                                                     + "\1\35\12\5\1\36\2\5\1\25\1\0\3\5\1\37"
                                                     + "\10\5\1\40\1\5\1\41\1\42\4\5\1\43\1\44"
                                                     + "\3\5\1\45\3\5\1\46\1\5\1\47\1\50\1\51"
                                                     + "\1\52\1\53\1\5\1\54";

  private static int[] zzUnpackAction()
  {
    final int[] result = new int[152];
    int offset = 0;
    offset = Lexer.zzUnpackAction(Lexer.ZZ_ACTION_PACKED_0, offset, result);
    return result;
  }

  private static int zzUnpackAction(
    final String packed,
    final int offset,
    final int[] result)
  {
    int i = 0; /* index in packed string */
    int j = offset; /* index in unpacked array */
    final int l = packed.length();
    while (i < l) {
      int count = packed.charAt(i++);
      final int value = packed.charAt(i++);
      do {
        result[j++] = value;
      } while (--count > 0);
    }
    return j;
  }

  /**
   * Translates a state to a row index in the transition table
   */
  private static final int[]  ZZ_ROWMAP          = Lexer.zzUnpackRowMap();

  private static final String ZZ_ROWMAP_PACKED_0 =
                                                   "\0\0\0\53\0\126\0\201\0\254\0\53\0\53\0\327"
                                                     + "\0\u0102\0\u012d\0\u0158\0\u0183\0\u01ae\0\u01d9\0\u0204\0\u022f"
                                                     + "\0\53\0\53\0\53\0\53\0\u025a\0\u0285\0\u02b0\0\53"
                                                     + "\0\u02db\0\u0306\0\u0331\0\u035c\0\53\0\53\0\53\0\53"
                                                     + "\0\53\0\u0387\0\126\0\u03b2\0\u03dd\0\u0408\0\327\0\u0433"
                                                     + "\0\u045e\0\u0489\0\u04b4\0\u04df\0\u050a\0\u0535\0\u0560\0\u058b"
                                                     + "\0\u05b6\0\u05e1\0\u060c\0\u0637\0\327\0\327\0\327\0\u0662"
                                                     + "\0\u068d\0\u06b8\0\u06e3\0\u070e\0\u0739\0\u0764\0\u078f\0\u07ba"
                                                     + "\0\u03dd\0\u07e5\0\u0810\0\u083b\0\u0866\0\u0891\0\u08bc\0\u08e7"
                                                     + "\0\u0912\0\u093d\0\u0968\0\327\0\u0993\0\u09be\0\u09e9\0\u0a14"
                                                     + "\0\327\0\u0a3f\0\u0a6a\0\327\0\u0a95\0\327\0\u0ac0\0\u0aeb"
                                                     + "\0\u0b16\0\u0b41\0\u0b6c\0\u0b97\0\u0bc2\0\u0bed\0\327\0\327"
                                                     + "\0\327\0\u0c18\0\327\0\u0c43\0\u0c6e\0\u0c99\0\u0cc4\0\u0cef"
                                                     + "\0\u0d1a\0\u0d45\0\u0d70\0\u0d9b\0\u0dc6\0\327\0\u0df1\0\u0e1c"
                                                     + "\0\u0bc2\0\u0e47\0\u0e72\0\u0e9d\0\u0ec8\0\327\0\u0ef3\0\u0f1e"
                                                     + "\0\u0f49\0\u0f74\0\u0f9f\0\u0fca\0\u0ff5\0\u1020\0\327\0\u104b"
                                                     + "\0\327\0\327\0\u1076\0\u10a1\0\u10cc\0\u10f7\0\327\0\327"
                                                     + "\0\u1122\0\u114d\0\u1178\0\327\0\u11a3\0\u11ce\0\u11f9\0\327"
                                                     + "\0\u1224\0\327\0\327\0\327\0\327\0\327\0\u124f\0\327";

  private static int[] zzUnpackRowMap()
  {
    final int[] result = new int[152];
    int offset = 0;
    offset = Lexer.zzUnpackRowMap(Lexer.ZZ_ROWMAP_PACKED_0, offset, result);
    return result;
  }

  private static int zzUnpackRowMap(
    final String packed,
    final int offset,
    final int[] result)
  {
    int i = 0; /* index in packed string */
    int j = offset; /* index in unpacked array */
    final int l = packed.length();
    while (i < l) {
      final int high = packed.charAt(i++) << 16;
      result[j++] = high | packed.charAt(i++);
    }
    return j;
  }

  /**
   * The transition table of the DFA
   */
  private static final int[]  ZZ_TRANS          = Lexer.zzUnpackTrans();

  private static final String ZZ_TRANS_PACKED_0 =
                                                  "\1\2\1\3\1\4\1\5\1\6\3\7\1\10\1\11"
                                                    + "\1\2\1\12\1\13\1\14\1\15\1\10\1\16\1\17"
                                                    + "\1\20\1\21\1\22\1\23\1\24\1\25\1\26\1\10"
                                                    + "\1\27\1\30\2\10\1\31\1\32\1\33\1\34\2\10"
                                                    + "\1\35\1\36\1\37\1\40\1\41\1\10\1\42\54\0"
                                                    + "\1\43\1\44\1\43\1\45\47\0\1\43\1\46\1\5"
                                                    + "\50\0\1\5\1\44\1\5\1\45\47\0\1\10\1\0"
                                                    + "\1\10\4\0\13\10\4\0\4\10\1\0\10\10\5\0"
                                                    + "\2\10\1\0\1\11\1\0\1\11\4\0\13\11\4\0"
                                                    + "\4\11\1\0\10\11\5\0\2\11\1\0\1\10\1\0"
                                                    + "\1\10\4\0\4\10\1\47\6\10\4\0\4\10\1\0"
                                                    + "\10\10\5\0\2\10\1\0\1\10\1\0\1\10\4\0"
                                                    + "\13\10\4\0\4\10\1\0\7\10\1\50\5\0\2\10"
                                                    + "\1\0\1\10\1\0\1\10\4\0\6\10\1\51\4\10"
                                                    + "\4\0\4\10\1\0\7\10\1\52\5\0\1\53\1\10"
                                                    + "\1\0\1\10\1\0\1\10\4\0\10\10\1\54\2\10"
                                                    + "\4\0\4\10\1\0\10\10\5\0\2\10\1\0\1\10"
                                                    + "\1\0\1\10\4\0\12\10\1\55\4\0\3\10\1\56"
                                                    + "\1\0\1\57\7\10\5\0\2\10\1\0\1\10\1\0"
                                                    + "\1\10\4\0\3\10\1\60\2\10\1\61\1\62\3\10"
                                                    + "\4\0\4\10\1\0\10\10\5\0\2\10\1\0\1\10"
                                                    + "\1\0\1\10\4\0\10\10\1\63\2\10\4\0\4\10"
                                                    + "\1\0\10\10\5\0\2\10\1\0\1\10\1\0\1\10"
                                                    + "\4\0\13\10\4\0\1\10\1\64\2\10\1\0\10\10"
                                                    + "\5\0\2\10\1\0\1\10\1\0\1\10\4\0\4\10"
                                                    + "\1\65\4\10\1\66\1\10\4\0\3\10\1\67\1\0"
                                                    + "\2\10\1\70\5\10\5\0\2\10\1\0\1\10\1\0"
                                                    + "\1\10\4\0\10\10\1\71\2\10\4\0\4\10\1\0"
                                                    + "\10\10\5\0\2\10\1\0\1\10\1\0\1\10\4\0"
                                                    + "\13\10\4\0\4\10\1\0\3\10\1\72\4\10\5\0"
                                                    + "\2\10\1\0\1\10\1\0\1\10\4\0\7\10\1\73"
                                                    + "\3\10\4\0\4\10\1\0\10\10\5\0\2\10\1\0"
                                                    + "\1\10\1\0\1\10\4\0\3\10\1\74\2\10\1\75"
                                                    + "\4\10\4\0\4\10\1\0\10\10\5\0\2\10\1\0"
                                                    + "\1\10\1\0\1\10\4\0\13\10\4\0\1\10\1\76"
                                                    + "\2\10\1\0\10\10\5\0\2\10\1\0\1\10\1\0"
                                                    + "\1\10\4\0\3\10\1\77\4\10\1\100\2\10\4\0"
                                                    + "\4\10\1\0\10\10\5\0\2\10\3\0\1\43\50\0"
                                                    + "\1\101\1\102\1\101\47\0\3\103\1\104\1\103\1\105"
                                                    + "\1\7\44\103\1\0\1\10\1\0\1\10\4\0\3\10"
                                                    + "\1\106\7\10\4\0\4\10\1\0\10\10\5\0\2\10"
                                                    + "\1\0\1\10\1\0\1\10\4\0\7\10\1\107\3\10"
                                                    + "\4\0\4\10\1\0\10\10\5\0\2\10\1\0\1\10"
                                                    + "\1\0\1\10\4\0\10\10\1\110\2\10\4\0\4\10"
                                                    + "\1\0\10\10\5\0\2\10\1\0\1\10\1\0\1\10"
                                                    + "\4\0\13\10\4\0\4\10\1\0\4\10\1\111\3\10"
                                                    + "\5\0\2\10\1\0\1\10\1\0\1\10\4\0\13\10"
                                                    + "\4\0\2\10\1\112\1\10\1\0\10\10\5\0\2\10"
                                                    + "\1\0\1\10\1\0\1\10\4\0\4\10\1\113\6\10"
                                                    + "\4\0\4\10\1\0\10\10\5\0\2\10\1\0\1\10"
                                                    + "\1\0\1\10\4\0\13\10\4\0\1\114\3\10\1\0"
                                                    + "\10\10\5\0\2\10\1\0\1\10\1\0\1\10\4\0"
                                                    + "\5\10\1\115\5\10\4\0\4\10\1\0\10\10\5\0"
                                                    + "\2\10\1\0\1\10\1\0\1\10\4\0\12\10\1\116"
                                                    + "\4\0\4\10\1\0\10\10\5\0\2\10\1\0\1\10"
                                                    + "\1\0\1\10\4\0\3\10\1\117\7\10\4\0\4\10"
                                                    + "\1\0\10\10\5\0\2\10\1\0\1\10\1\0\1\10"
                                                    + "\4\0\13\10\4\0\3\10\1\120\1\0\10\10\5\0"
                                                    + "\2\10\1\0\1\10\1\0\1\10\4\0\5\10\1\121"
                                                    + "\5\10\4\0\4\10\1\0\10\10\5\0\2\10\1\0"
                                                    + "\1\10\1\0\1\10\4\0\4\10\1\122\6\10\4\0"
                                                    + "\4\10\1\0\10\10\5\0\2\10\1\0\1\10\1\0"
                                                    + "\1\10\4\0\13\10\4\0\4\10\1\0\4\10\1\123"
                                                    + "\3\10\5\0\2\10\1\0\1\10\1\0\1\10\4\0"
                                                    + "\13\10\4\0\4\10\1\0\5\10\1\124\2\10\5\0"
                                                    + "\2\10\1\0\1\10\1\0\1\10\4\0\13\10\4\0"
                                                    + "\1\125\3\10\1\0\10\10\5\0\2\10\1\0\1\10"
                                                    + "\1\0\1\10\4\0\5\10\1\126\5\10\4\0\4\10"
                                                    + "\1\0\10\10\5\0\2\10\1\0\1\10\1\0\1\10"
                                                    + "\4\0\6\10\1\127\4\10\4\0\2\10\1\130\1\10"
                                                    + "\1\0\10\10\5\0\2\10\1\0\1\10\1\0\1\10"
                                                    + "\4\0\13\10\4\0\4\10\1\0\3\10\1\131\4\10"
                                                    + "\5\0\2\10\1\0\1\10\1\0\1\10\4\0\5\10"
                                                    + "\1\132\5\10\4\0\4\10\1\0\10\10\5\0\2\10"
                                                    + "\1\0\1\10\1\0\1\10\4\0\12\10\1\133\4\0"
                                                    + "\4\10\1\0\10\10\5\0\2\10\1\0\1\10\1\0"
                                                    + "\1\10\4\0\6\10\1\134\4\10\4\0\4\10\1\0"
                                                    + "\10\10\5\0\2\10\3\0\1\101\47\0\5\103\1\105"
                                                    + "\1\7\45\103\1\104\1\46\1\104\1\135\1\105\1\7"
                                                    + "\44\103\6\0\1\7\45\0\1\10\1\0\1\10\4\0"
                                                    + "\13\10\4\0\1\136\3\10\1\0\10\10\5\0\2\10"
                                                    + "\1\0\1\10\1\0\1\10\4\0\10\10\1\137\2\10"
                                                    + "\4\0\4\10\1\0\10\10\5\0\2\10\1\0\1\10"
                                                    + "\1\0\1\10\4\0\13\10\4\0\3\10\1\140\1\0"
                                                    + "\10\10\5\0\2\10\1\0\1\10\1\0\1\10\4\0"
                                                    + "\10\10\1\141\2\10\4\0\4\10\1\0\10\10\5\0"
                                                    + "\2\10\1\0\1\10\1\0\1\10\4\0\13\10\4\0"
                                                    + "\4\10\1\0\3\10\1\142\4\10\5\0\2\10\1\0"
                                                    + "\1\10\1\0\1\10\4\0\10\10\1\143\2\10\4\0"
                                                    + "\4\10\1\0\10\10\5\0\2\10\1\0\1\10\1\0"
                                                    + "\1\10\4\0\10\10\1\144\2\10\4\0\4\10\1\0"
                                                    + "\10\10\5\0\2\10\1\0\1\10\1\0\1\10\4\0"
                                                    + "\4\10\1\145\6\10\4\0\4\10\1\0\10\10\5\0"
                                                    + "\2\10\1\0\1\10\1\0\1\10\4\0\13\10\4\0"
                                                    + "\4\10\1\0\1\10\1\146\6\10\5\0\2\10\1\0"
                                                    + "\1\10\1\0\1\10\4\0\13\10\4\0\2\10\1\147"
                                                    + "\1\10\1\0\10\10\5\0\2\10\1\0\1\10\1\0"
                                                    + "\1\10\4\0\13\10\4\0\2\10\1\150\1\10\1\0"
                                                    + "\10\10\5\0\2\10\1\0\1\10\1\0\1\10\4\0"
                                                    + "\13\10\4\0\4\10\1\0\3\10\1\151\4\10\5\0"
                                                    + "\2\10\1\0\1\10\1\0\1\10\4\0\7\10\1\152"
                                                    + "\3\10\4\0\4\10\1\0\10\10\5\0\2\10\1\0"
                                                    + "\1\10\1\0\1\10\4\0\3\10\1\153\7\10\4\0"
                                                    + "\4\10\1\0\10\10\5\0\2\10\1\0\1\10\1\0"
                                                    + "\1\10\4\0\13\10\4\0\4\10\1\0\6\10\1\154"
                                                    + "\1\10\5\0\2\10\1\0\1\10\1\0\1\10\4\0"
                                                    + "\13\10\4\0\4\10\1\0\1\10\1\155\6\10\5\0"
                                                    + "\2\10\1\0\1\10\1\0\1\10\4\0\13\10\4\0"
                                                    + "\4\10\1\0\7\10\1\156\5\0\2\10\1\0\1\10"
                                                    + "\1\0\1\10\4\0\7\10\1\157\3\10\4\0\4\10"
                                                    + "\1\0\10\10\5\0\2\10\1\0\1\10\1\0\1\10"
                                                    + "\4\0\5\10\1\160\5\10\4\0\4\10\1\0\10\10"
                                                    + "\5\0\2\10\1\103\1\161\1\162\1\161\1\103\1\105"
                                                    + "\1\7\44\103\1\0\1\10\1\0\1\10\4\0\10\10"
                                                    + "\1\163\2\10\4\0\4\10\1\0\10\10\5\0\2\10"
                                                    + "\1\0\1\10\1\0\1\10\4\0\6\10\1\164\4\10"
                                                    + "\4\0\4\10\1\0\10\10\5\0\2\10\1\0\1\10"
                                                    + "\1\0\1\10\4\0\6\10\1\165\4\10\4\0\4\10"
                                                    + "\1\0\10\10\5\0\2\10\1\0\1\10\1\0\1\10"
                                                    + "\4\0\10\10\1\166\2\10\4\0\4\10\1\0\10\10"
                                                    + "\5\0\2\10\1\0\1\10\1\0\1\10\4\0\13\10"
                                                    + "\4\0\4\10\1\0\2\10\1\167\5\10\5\0\2\10"
                                                    + "\1\0\1\10\1\0\1\10\4\0\5\10\1\170\5\10"
                                                    + "\4\0\4\10\1\0\10\10\5\0\2\10\1\0\1\10"
                                                    + "\1\0\1\10\4\0\3\10\1\171\7\10\4\0\4\10"
                                                    + "\1\0\10\10\5\0\2\10\1\0\1\10\1\0\1\10"
                                                    + "\4\0\6\10\1\172\4\10\4\0\4\10\1\0\10\10"
                                                    + "\5\0\2\10\1\0\1\10\1\0\1\10\4\0\12\10"
                                                    + "\1\173\4\0\4\10\1\0\10\10\5\0\2\10\1\0"
                                                    + "\1\10\1\0\1\10\4\0\13\10\4\0\4\10\1\0"
                                                    + "\2\10\1\174\5\10\5\0\2\10\1\0\1\10\1\0"
                                                    + "\1\10\4\0\3\10\1\175\7\10\4\0\4\10\1\0"
                                                    + "\10\10\5\0\2\10\1\0\1\10\1\0\1\10\4\0"
                                                    + "\6\10\1\176\4\10\4\0\4\10\1\0\10\10\5\0"
                                                    + "\2\10\1\0\1\10\1\0\1\10\4\0\10\10\1\177"
                                                    + "\2\10\4\0\4\10\1\0\10\10\5\0\2\10\1\0"
                                                    + "\1\10\1\0\1\10\4\0\10\10\1\200\2\10\4\0"
                                                    + "\4\10\1\0\10\10\5\0\2\10\3\103\1\161\1\103"
                                                    + "\1\105\1\7\44\103\1\0\1\10\1\0\1\10\4\0"
                                                    + "\6\10\1\201\4\10\4\0\4\10\1\0\10\10\5\0"
                                                    + "\2\10\1\0\1\10\1\0\1\10\4\0\13\10\4\0"
                                                    + "\1\202\3\10\1\0\10\10\5\0\2\10\1\0\1\10"
                                                    + "\1\0\1\10\4\0\13\10\4\0\3\10\1\203\1\0"
                                                    + "\10\10\5\0\2\10\1\0\1\10\1\0\1\10\4\0"
                                                    + "\10\10\1\204\2\10\4\0\4\10\1\0\10\10\5\0"
                                                    + "\2\10\1\0\1\10\1\0\1\10\4\0\13\10\4\0"
                                                    + "\1\10\1\205\2\10\1\0\10\10\5\0\2\10\1\0"
                                                    + "\1\10\1\0\1\10\4\0\6\10\1\206\4\10\4\0"
                                                    + "\4\10\1\0\10\10\5\0\2\10\1\0\1\10\1\0"
                                                    + "\1\10\4\0\5\10\1\207\5\10\4\0\4\10\1\0"
                                                    + "\10\10\5\0\2\10\1\0\1\10\1\0\1\10\4\0"
                                                    + "\10\10\1\210\2\10\4\0\4\10\1\0\10\10\5\0"
                                                    + "\2\10\1\0\1\10\1\0\1\10\4\0\10\10\1\211"
                                                    + "\2\10\4\0\4\10\1\0\10\10\5\0\2\10\1\0"
                                                    + "\1\10\1\0\1\10\4\0\13\10\4\0\4\10\1\0"
                                                    + "\1\10\1\212\6\10\5\0\2\10\1\0\1\10\1\0"
                                                    + "\1\10\4\0\3\10\1\213\7\10\4\0\4\10\1\0"
                                                    + "\10\10\5\0\2\10\1\0\1\10\1\0\1\10\4\0"
                                                    + "\13\10\4\0\4\10\1\0\1\214\7\10\5\0\2\10"
                                                    + "\1\0\1\10\1\0\1\10\4\0\3\10\1\215\7\10"
                                                    + "\4\0\4\10\1\0\10\10\5\0\2\10\1\0\1\10"
                                                    + "\1\0\1\10\4\0\13\10\4\0\3\10\1\216\1\0"
                                                    + "\10\10\5\0\2\10\1\0\1\10\1\0\1\10\4\0"
                                                    + "\13\10\4\0\4\10\1\0\3\10\1\217\4\10\5\0"
                                                    + "\2\10\1\0\1\10\1\0\1\10\4\0\13\10\4\0"
                                                    + "\1\220\3\10\1\0\10\10\5\0\2\10\1\0\1\10"
                                                    + "\1\0\1\10\4\0\5\10\1\221\5\10\4\0\4\10"
                                                    + "\1\0\10\10\5\0\2\10\1\0\1\10\1\0\1\10"
                                                    + "\4\0\10\10\1\222\2\10\4\0\4\10\1\0\10\10"
                                                    + "\5\0\2\10\1\0\1\10\1\0\1\10\4\0\13\10"
                                                    + "\4\0\4\10\1\0\2\10\1\223\5\10\5\0\2\10"
                                                    + "\1\0\1\10\1\0\1\10\4\0\12\10\1\224\4\0"
                                                    + "\4\10\1\0\10\10\5\0\2\10\1\0\1\10\1\0"
                                                    + "\1\10\4\0\5\10\1\225\5\10\4\0\4\10\1\0"
                                                    + "\10\10\5\0\2\10\1\0\1\10\1\0\1\10\4\0"
                                                    + "\13\10\4\0\3\10\1\226\1\0\10\10\5\0\2\10"
                                                    + "\1\0\1\10\1\0\1\10\4\0\10\10\1\227\2\10"
                                                    + "\4\0\4\10\1\0\10\10\5\0\2\10\1\0\1\10"
                                                    + "\1\0\1\10\4\0\6\10\1\230\4\10\4\0\4\10"
                                                    + "\1\0\10\10\5\0\2\10";

  private static int[] zzUnpackTrans()
  {
    final int[] result = new int[4730];
    int offset = 0;
    offset = Lexer.zzUnpackTrans(Lexer.ZZ_TRANS_PACKED_0, offset, result);
    return result;
  }

  private static int zzUnpackTrans(
    final String packed,
    final int offset,
    final int[] result)
  {
    int i = 0; /* index in packed string */
    int j = offset; /* index in unpacked array */
    final int l = packed.length();
    while (i < l) {
      int count = packed.charAt(i++);
      int value = packed.charAt(i++);
      value--;
      do {
        result[j++] = value;
      } while (--count > 0);
    }
    return j;
  }

  /* error codes */
  private static final int    ZZ_UNKNOWN_ERROR      = 0;
  private static final int    ZZ_NO_MATCH           = 1;
  private static final int    ZZ_PUSHBACK_2BIG      = 2;

  /* error messages for the codes above */
  private static final String ZZ_ERROR_MSG[]        = {
    "Unkown internal scanner error",
    "Error: could not match input",
    "Error: pushback value was too large"          };

  /**
   * ZZ_ATTRIBUTE[aState] contains the attributes of state <code>aState</code>
   */
  private static final int[]  ZZ_ATTRIBUTE          = Lexer
                                                      .zzUnpackAttribute();

  private static final String ZZ_ATTRIBUTE_PACKED_0 =
                                                      "\1\0\1\11\3\1\2\11\11\1\4\11\3\1\1\11"
                                                        + "\4\1\5\11\1\1\4\0\33\1\3\0\30\1\1\0"
                                                        + "\24\1\1\0\46\1";

  private static int[] zzUnpackAttribute()
  {
    final int[] result = new int[152];
    int offset = 0;
    offset =
      Lexer.zzUnpackAttribute(Lexer.ZZ_ATTRIBUTE_PACKED_0, offset, result);
    return result;
  }

  private static int zzUnpackAttribute(
    final String packed,
    final int offset,
    final int[] result)
  {
    int i = 0; /* index in packed string */
    int j = offset; /* index in unpacked array */
    final int l = packed.length();
    while (i < l) {
      int count = packed.charAt(i++);
      final int value = packed.charAt(i++);
      do {
        result[j++] = value;
      } while (--count > 0);
    }
    return j;
  }

  /** the input device */
  private java.io.Reader zzReader;

  /** the current state of the DFA */
  private int            zzState;

  /** the current lexical state */
  private int            zzLexicalState = Lexer.YYINITIAL;

  /**
   * this buffer contains the current text to be matched and is the source of
   * the yytext() string
   */
  private char           zzBuffer[]     = new char[Lexer.ZZ_BUFFERSIZE];

  /** the textposition at the last accepting state */
  private int            zzMarkedPos;

  /** the current text position in the buffer */
  private int            zzCurrentPos;

  /** startRead marks the beginning of the yytext() string in the buffer */
  private int            zzStartRead;

  /**
   * endRead marks the last character in the buffer, that has been read from
   * input
   */
  private int            zzEndRead;

  /** number of newlines encountered up to the start of the matched text */
  private int            yyline;

  /** the number of characters up to the start of the matched text */
  private int            yychar;

  /**
   * the number of characters from the last newline up to the start of the
   * matched text
   */
  private int            yycolumn;

  /**
   * zzAtBOL == true <=> the scanner is currently at the beginning of a line
   */
  private boolean        zzAtBOL        = true;

  /** zzAtEOF == true <=> the scanner is at the EOF */
  private boolean        zzAtEOF;

  /** denotes if the user-EOF-code has already been executed */
  private boolean        zzEOFDone;

  /* user code: */

  public Token token()
    throws IOException,
      LexerError,
      ConstraintError
  {
    return this.yylex();
  }

  private @Nonnull File file = new File("<stdin>");

  public void setFile(
    final @Nonnull File file)
    throws ConstraintError
  {
    this.file = Constraints.constrainNotNull(file, "File name");
  }

  public @Nonnull File getFile()
  {
    return this.file;
  }

  private Position position()
  {
    return new Position(this.yyline + 1, this.yycolumn);
  }

  /**
   * Creates a new scanner There is also a java.io.InputStream version of this
   * constructor.
   * 
   * @param in
   *          the java.io.Reader to read input from.
   */
  public Lexer(
    final java.io.Reader in)
  {
    this.zzReader = in;
  }

  /**
   * Creates a new scanner. There is also java.io.Reader version of this
   * constructor.
   * 
   * @param in
   *          the java.io.Inputstream to read input from.
   */
  public Lexer(
    final java.io.InputStream in)
  {
    this(new java.io.InputStreamReader(in));
  }

  /**
   * Unpacks the compressed character translation table.
   * 
   * @param packed
   *          the packed character translation table
   * @return the unpacked character translation table
   */
  private static char[] zzUnpackCMap(
    final String packed)
  {
    final char[] map = new char[0x10000];
    int i = 0; /* index in packed string */
    int j = 0; /* index in unpacked array */
    while (i < 120) {
      int count = packed.charAt(i++);
      final char value = packed.charAt(i++);
      do {
        map[j++] = value;
      } while (--count > 0);
    }
    return map;
  }

  /**
   * Refills the input buffer.
   * 
   * @return <code>false</code>, iff there was new input.
   * 
   * @exception java.io.IOException
   *              if any I/O-Error occurs
   */
  private boolean zzRefill()
    throws java.io.IOException
  {

    /* first: make room (if you can) */
    if (this.zzStartRead > 0) {
      System.arraycopy(
        this.zzBuffer,
        this.zzStartRead,
        this.zzBuffer,
        0,
        this.zzEndRead - this.zzStartRead);

      /* translate stored positions */
      this.zzEndRead -= this.zzStartRead;
      this.zzCurrentPos -= this.zzStartRead;
      this.zzMarkedPos -= this.zzStartRead;
      this.zzStartRead = 0;
    }

    /* is the buffer big enough? */
    if (this.zzCurrentPos >= this.zzBuffer.length) {
      /* if not: blow it up */
      final char newBuffer[] = new char[this.zzCurrentPos * 2];
      System.arraycopy(this.zzBuffer, 0, newBuffer, 0, this.zzBuffer.length);
      this.zzBuffer = newBuffer;
    }

    /* finally: fill the buffer with new input */
    final int numRead =
      this.zzReader.read(this.zzBuffer, this.zzEndRead, this.zzBuffer.length
        - this.zzEndRead);

    if (numRead > 0) {
      this.zzEndRead += numRead;
      return false;
    }
    // unlikely but not impossible: read 0 characters, but not at end of
    // stream
    if (numRead == 0) {
      final int c = this.zzReader.read();
      if (c == -1) {
        return true;
      }
      this.zzBuffer[this.zzEndRead++] = (char) c;
      return false;
    }

    // numRead < 0
    return true;
  }

  /**
   * Closes the input stream.
   */
  private final void yyclose()
    throws java.io.IOException
  {
    this.zzAtEOF = true; /* indicate end of file */
    this.zzEndRead = this.zzStartRead; /* invalidate buffer */

    if (this.zzReader != null) {
      this.zzReader.close();
    }
  }

  /**
   * Resets the scanner to read from a new input stream. Does not close the
   * old reader.
   * 
   * All internal variables are reset, the old input stream <b>cannot</b> be
   * reused (internal buffer is discarded and lost). Lexical state is set to
   * <tt>ZZ_INITIAL</tt>.
   * 
   * @param reader
   *          the new input stream
   */
  private final void yyreset(
    final java.io.Reader reader)
  {
    this.zzReader = reader;
    this.zzAtBOL = true;
    this.zzAtEOF = false;
    this.zzEOFDone = false;
    this.zzEndRead = this.zzStartRead = 0;
    this.zzCurrentPos = this.zzMarkedPos = 0;
    this.yyline = this.yychar = this.yycolumn = 0;
    this.zzLexicalState = Lexer.YYINITIAL;
  }

  /**
   * Returns the current lexical state.
   */
  private final int yystate()
  {
    return this.zzLexicalState;
  }

  /**
   * Enters a new lexical state
   * 
   * @param newState
   *          the new lexical state
   */
  private final void yybegin(
    final int newState)
  {
    this.zzLexicalState = newState;
  }

  /**
   * Returns the text matched by the current regular expression.
   */
  private final String yytext()
  {
    return new String(this.zzBuffer, this.zzStartRead, this.zzMarkedPos
      - this.zzStartRead);
  }

  /**
   * Returns the character at position <tt>pos</tt> from the matched text.
   * 
   * It is equivalent to yytext().charAt(pos), but faster
   * 
   * @param pos
   *          the position of the character to fetch. A value from 0 to
   *          yylength()-1.
   * 
   * @return the character at position pos
   */
  private final char yycharat(
    final int pos)
  {
    return this.zzBuffer[this.zzStartRead + pos];
  }

  /**
   * Returns the length of the matched text region.
   */
  private final int yylength()
  {
    return this.zzMarkedPos - this.zzStartRead;
  }

  /**
   * Reports an error that occured while scanning.
   * 
   * In a wellformed scanner (no or only correct usage of yypushback(int) and
   * a match-all fallback rule) this method will only be called with things
   * that "Can't Possibly Happen". If this method is called, something is
   * seriously wrong (e.g. a JFlex bug producing a faulty scanner etc.).
   * 
   * Usual syntax/scanner level error handling should be done in error
   * fallback rules.
   * 
   * @param errorCode
   *          the code of the errormessage to display
   */
  private void zzScanError(
    final int errorCode)
  {
    String message;
    try {
      message = Lexer.ZZ_ERROR_MSG[errorCode];
    } catch (final ArrayIndexOutOfBoundsException e) {
      message = Lexer.ZZ_ERROR_MSG[Lexer.ZZ_UNKNOWN_ERROR];
    }

    throw new Error(message);
  }

  /**
   * Pushes the specified amount of characters back into the input stream.
   * 
   * They will be read again by then next call of the scanning method
   * 
   * @param number
   *          the number of characters to be read again. This number must not
   *          be greater than yylength()!
   */
  private void yypushback(
    final int number)
  {
    if (number > this.yylength()) {
      this.zzScanError(Lexer.ZZ_PUSHBACK_2BIG);
    }

    this.zzMarkedPos -= number;
  }

  /**
   * Resumes scanning until the next regular expression is matched, the end of
   * input is encountered or an I/O-Error occurs.
   * 
   * @return the next token
   * @exception java.io.IOException
   *              if any I/O-Error occurs
   * @throws ConstraintError
   * @throws LexerError
   */
  private Token yylex()
    throws java.io.IOException,
      ConstraintError,
      LexerError
  {
    int zzInput;
    int zzAction;

    // cached fields:
    int zzCurrentPosL;
    int zzMarkedPosL;
    int zzEndReadL = this.zzEndRead;
    char[] zzBufferL = this.zzBuffer;
    final char[] zzCMapL = Lexer.ZZ_CMAP;

    final int[] zzTransL = Lexer.ZZ_TRANS;
    final int[] zzRowMapL = Lexer.ZZ_ROWMAP;
    final int[] zzAttrL = Lexer.ZZ_ATTRIBUTE;

    while (true) {
      zzMarkedPosL = this.zzMarkedPos;

      boolean zzR = false;
      for (zzCurrentPosL = this.zzStartRead; zzCurrentPosL < zzMarkedPosL; zzCurrentPosL++) {
        switch (zzBufferL[zzCurrentPosL]) {
          case '\u000B':
          case '\u000C':
          case '\u0085':
          case '\u2028':
          case '\u2029':
            this.yyline++;
            this.yycolumn = 0;
            zzR = false;
            break;
          case '\r':
            this.yyline++;
            this.yycolumn = 0;
            zzR = true;
            break;
          case '\n':
            if (zzR) {
              zzR = false;
            } else {
              this.yyline++;
              this.yycolumn = 0;
            }
            break;
          default:
            zzR = false;
            this.yycolumn++;
        }
      }

      if (zzR) {
        // peek one character ahead if it is \n (if we have counted one line
        // too much)
        boolean zzPeek;
        if (zzMarkedPosL < zzEndReadL) {
          zzPeek = zzBufferL[zzMarkedPosL] == '\n';
        } else if (this.zzAtEOF) {
          zzPeek = false;
        } else {
          final boolean eof = this.zzRefill();
          zzEndReadL = this.zzEndRead;
          zzMarkedPosL = this.zzMarkedPos;
          zzBufferL = this.zzBuffer;
          if (eof) {
            zzPeek = false;
          } else {
            zzPeek = zzBufferL[zzMarkedPosL] == '\n';
          }
        }
        if (zzPeek) {
          this.yyline--;
        }
      }
      zzAction = -1;

      zzCurrentPosL = this.zzCurrentPos = this.zzStartRead = zzMarkedPosL;

      this.zzState = Lexer.ZZ_LEXSTATE[this.zzLexicalState];

      zzForAction:
      {
        while (true) {

          if (zzCurrentPosL < zzEndReadL) {
            zzInput = zzBufferL[zzCurrentPosL++];
          } else if (this.zzAtEOF) {
            zzInput = Lexer.YYEOF;
            break zzForAction;
          } else {
            // store back cached positions
            this.zzCurrentPos = zzCurrentPosL;
            this.zzMarkedPos = zzMarkedPosL;
            final boolean eof = this.zzRefill();
            // get translated positions and possibly new buffer
            zzCurrentPosL = this.zzCurrentPos;
            zzMarkedPosL = this.zzMarkedPos;
            zzBufferL = this.zzBuffer;
            zzEndReadL = this.zzEndRead;
            if (eof) {
              zzInput = Lexer.YYEOF;
              break zzForAction;
            }
            zzInput = zzBufferL[zzCurrentPosL++];
          }
          final int zzNext =
            zzTransL[zzRowMapL[this.zzState] + zzCMapL[zzInput]];
          if (zzNext == -1) {
            break zzForAction;
          }
          this.zzState = zzNext;

          final int zzAttributes = zzAttrL[this.zzState];
          if ((zzAttributes & 1) == 1) {
            zzAction = this.zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ((zzAttributes & 8) == 8) {
              break zzForAction;
            }
          }

        }
      }

      // store back cached position
      this.zzMarkedPos = zzMarkedPosL;

      switch (zzAction < 0 ? zzAction : Lexer.ZZ_ACTION[zzAction]) {
        case 15:
        {
          return new Token.TokenSquareLeft(this.getFile(), this.position());
        }
        case 45:
          break;
        case 6:
        {
          return new Token.TokenIdentifierUpper(
            this.getFile(),
            this.position(),
            this.yytext());
        }
        case 46:
          break;
        case 40:
        {
          return new Token.TokenProgram(this.getFile(), this.position());
        }
        case 47:
          break;
        case 30:
        {
          return new Token.TokenWith(this.getFile(), this.position());
        }
        case 48:
          break;
        case 18:
        {
          return new Token.TokenIs(this.getFile(), this.position());
        }
        case 49:
          break;
        case 28:
        {
          return new Token.TokenType(this.getFile(), this.position());
        }
        case 50:
          break;
        case 39:
        {
          return new Token.TokenPackage(this.getFile(), this.position());
        }
        case 51:
          break;
        case 31:
        {
          return new Token.TokenLiteralBoolean(
            this.getFile(),
            this.position(),
            false);
        }
        case 52:
          break;
        case 13:
        {
          return new Token.TokenRoundRight(this.getFile(), this.position());
        }
        case 53:
          break;
        case 2:
        {
          return Token.TokenLiteralIntegerDecimal.newIntegerDecimal(
            this.getFile(),
            this.position(),
            this.yytext());
        }
        case 54:
          break;
        case 41:
        {
          return new Token.TokenExternal(this.getFile(), this.position());
        }
        case 55:
          break;
        case 44:
        {
          return new Token.TokenParameter(this.getFile(), this.position());
        }
        case 56:
          break;
        case 1:
        {
          throw new LexerError(
            "Illegal character <" + this.yytext() + ">",
            this.getFile(),
            this.position());
        }
        case 57:
          break;
        case 27:
        {
          return new Token.TokenThen(this.getFile(), this.position());
        }
        case 58:
          break;
        case 5:
        {
          return new Token.TokenIdentifierLower(
            this.getFile(),
            this.position(),
            this.yytext());
        }
        case 59:
          break;
        case 4:
        { /* Ignore */
        }
        case 60:
          break;
        case 26:
        {
          return new Token.TokenLiteralBoolean(
            this.getFile(),
            this.position(),
            true);
        }
        case 61:
          break;
        case 36:
        {
          return new Token.TokenModule(this.getFile(), this.position());
        }
        case 62:
          break;
        case 14:
        {
          return new Token.TokenSemicolon(this.getFile(), this.position());
        }
        case 63:
          break;
        case 17:
        {
          return new Token.TokenAs(this.getFile(), this.position());
        }
        case 64:
          break;
        case 37:
        {
          return new Token.TokenVertex(this.getFile(), this.position());
        }
        case 65:
          break;
        case 10:
        {
          return new Token.TokenCurlyRight(this.getFile(), this.position());
        }
        case 66:
          break;
        case 3:
        {
          return new Token.TokenDot(this.getFile(), this.position());
        }
        case 67:
          break;
        case 33:
        {
          return new Token.TokenShader(this.getFile(), this.position());
        }
        case 68:
          break;
        case 38:
        {
          return new Token.TokenDiscard(this.getFile(), this.position());
        }
        case 69:
          break;
        case 12:
        {
          return new Token.TokenRoundLeft(this.getFile(), this.position());
        }
        case 70:
          break;
        case 19:
        {
          return new Token.TokenIf(this.getFile(), this.position());
        }
        case 71:
          break;
        case 16:
        {
          return new Token.TokenSquareRight(this.getFile(), this.position());
        }
        case 72:
          break;
        case 35:
        {
          return new Token.TokenImport(this.getFile(), this.position());
        }
        case 73:
          break;
        case 29:
        {
          return new Token.TokenElse(this.getFile(), this.position());
        }
        case 74:
          break;
        case 42:
        {
          return new Token.TokenFragment(this.getFile(), this.position());
        }
        case 75:
          break;
        case 11:
        {
          return new Token.TokenEquals(this.getFile(), this.position());
        }
        case 76:
          break;
        case 34:
        {
          return new Token.TokenRecord(this.getFile(), this.position());
        }
        case 77:
          break;
        case 21:
        {
          return Token.TokenLiteralReal.newReal(
            this.getFile(),
            this.position(),
            this.yytext());
        }
        case 78:
          break;
        case 24:
        {
          return new Token.TokenNew(this.getFile(), this.position());
        }
        case 79:
          break;
        case 32:
        {
          return new Token.TokenValue(this.getFile(), this.position());
        }
        case 80:
          break;
        case 23:
        {
          return new Token.TokenLet(this.getFile(), this.position());
        }
        case 81:
          break;
        case 43:
        {
          return new Token.TokenFunction(this.getFile(), this.position());
        }
        case 82:
          break;
        case 20:
        {
          return new Token.TokenIn(this.getFile(), this.position());
        }
        case 83:
          break;
        case 25:
        {
          return new Token.TokenOut(this.getFile(), this.position());
        }
        case 84:
          break;
        case 8:
        {
          return new Token.TokenComma(this.getFile(), this.position());
        }
        case 85:
          break;
        case 7:
        {
          return new Token.TokenColon(this.getFile(), this.position());
        }
        case 86:
          break;
        case 9:
        {
          return new Token.TokenCurlyLeft(this.getFile(), this.position());
        }
        case 87:
          break;
        case 22:
        {
          return new Token.TokenEnd(this.getFile(), this.position());
        }
        case 88:
          break;
        default:
          if ((zzInput == Lexer.YYEOF)
            && (this.zzStartRead == this.zzCurrentPos)) {
            this.zzAtEOF = true;
            {
              return new Token.TokenEOF(this.getFile(), this.position());
            }
          }
          this.zzScanError(Lexer.ZZ_NO_MATCH);
      }
    }
  }

}
