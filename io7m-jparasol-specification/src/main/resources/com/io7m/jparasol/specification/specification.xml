<?xml version="1.0" encoding="UTF-8"?>

<!--
  Copyright ¬© 2014 <code@io7m.com> http://io7m.com

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  -->

<s:document
  xmlns:s="http://schemas.io7m.com/structural/2.0.0"
  xmlns:xi="http://www.w3.org/2001/XInclude">
  <s:document-title>Parasol Language ${project.version} Specification</s:document-title>
  <s:document-style>specification.css</s:document-style>
  <s:document-contents/>

  <s:part xml:id="spec.notation">
    <s:part-title>Notational Conventions</s:part-title>
    <s:part-contents/>

    <s:section>
      <s:section-title>Unicode</s:section-title>
      <s:paragraph>
        The specification makes reference to the
        <s:link-external s:target="http://unicode.org">Unicode</s:link-external>
        character set which, at the time of writing, is at version
        <s:term s:type="constant">6.2.0</s:term>. The specification
        often references specific Unicode characters, and does so using
        the standard notation <s:term s:type="expression">U+NNNN</s:term>,
        where <s:term s:type="variable">N</s:term> represents a hexadecimal
        digit. For example, <s:term s:type="constant">U+03BB</s:term>
        corresponds to the lowercase lambda symbol <s:term s:type="constant">Œª</s:term>.
      </s:paragraph>
    </s:section>

    <s:section>
      <s:section-title>EBNF</s:section-title>
      <s:paragraph>
        The specification gives grammar definitions in
        <s:term s:type="package">ISO/IEC 14977:1996</s:term> Extended Backus-Naur
        form.
      </s:paragraph>
    </s:section>

    <s:section>
      <s:section-title>Logic</s:section-title>
      <s:paragraph>
        The specification uses the following notation from
        propositional logic <s:footnote>
          <s:link-external s:target="http://en.wikipedia.org/wiki/Propositional_logic">http://en.wikipedia.org/wiki/Propositional_logic</s:link-external>
        </s:footnote>.
        A summary of the notation used is as follows:
      </s:paragraph>
      <s:formal-item s:kind="notations" s:type="notations">
        <s:formal-item-title>Set notations</s:formal-item-title>
        <s:table>
          <s:table-summary>Set notations</s:table-summary>
          <s:table-head>
            <s:table-column-name>Notation</s:table-column-name>
            <s:table-column-name>Description</s:table-column-name>
          </s:table-head>
          <s:table-body>
            <s:table-row>
              <s:table-cell><s:term s:type="expression">‚àÄx. P x</s:term></s:table-cell>
              <s:table-cell>Universal quantification; for all <s:term s:type="expression">x</s:term> the proposition <s:term s:type="expression">P</s:term> holds for <s:term s:type="expression">x</s:term></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term s:type="expression">‚àÉx. P x</s:term></s:table-cell>
              <s:table-cell>Existential quantification; there exists some <s:term s:type="expression">x</s:term> such that the proposition <s:term s:type="expression">P</s:term> holds for <s:term s:type="expression">x</s:term></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term s:type="expression">P ‚áí Q</s:term></s:table-cell>
              <s:table-cell>Implication; <s:term s:type="expression">P</s:term> implies <s:term s:type="expression">Q</s:term></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term s:type="expression">P ‚ãÄ Q</s:term></s:table-cell>
              <s:table-cell>Conjunction; <s:term s:type="expression">P</s:term> and <s:term s:type="expression">Q</s:term></s:table-cell>
            </s:table-row>
          </s:table-body>
        </s:table>
      </s:formal-item>
    </s:section>

    <s:section>
      <s:section-title>Sets</s:section-title>
      <s:paragraph>
        Where the specification refers to <s:term s:type="term">sets</s:term>, it
        is referring to sets as defined in ZFC<s:footnote>
          <s:link-external s:target="http://en.wikipedia.org/wiki/Zermelo-Fraenkel_set_theory">http://en.wikipedia.org/wiki/Zermelo-Fraenkel_set_theory</s:link-external>
        </s:footnote>.
      </s:paragraph>

      <s:formal-item s:kind="notations" s:type="notations">
        <s:formal-item-title>Set notations</s:formal-item-title>
        <s:table>
          <s:table-summary>Set notations</s:table-summary>
          <s:table-head>
            <s:table-column-name>Notation</s:table-column-name>
            <s:table-column-name>Description</s:table-column-name>
          </s:table-head>
          <s:table-body>
            <s:table-row>
              <s:table-cell><s:term s:type="expression">e ‚àà A</s:term></s:table-cell>
              <s:table-cell><s:term s:type="expression">e</s:term> is an element of the set <s:term s:type="expression">A</s:term></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term s:type="expression">e ‚àâ A</s:term></s:table-cell>
              <s:table-cell><s:term s:type="expression">e</s:term> is not an element of the set <s:term s:type="expression">A</s:term></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term s:type="expression">{ x‚ÇÄ, x‚ÇÅ, ... x‚Çô }</s:term></s:table-cell>
              <s:table-cell>A set consisting of values from <s:term s:type="expression">x‚ÇÄ</s:term> to <s:term s:type="expression">x‚Çô</s:term></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term s:type="expression">{ e ‚àà A | p(e) }</s:term></s:table-cell>
              <s:table-cell>A set consisting of the elements of <s:term s:type="expression">A</s:term> for which the proposition <s:term s:type="expression">p</s:term> holds</s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term s:type="expression">|A|</s:term></s:table-cell>
              <s:table-cell>The cardinality of the set <s:term s:type="expression">A</s:term>; a measure of the number of elements in <s:term s:type="expression">A</s:term></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term s:type="expression">‚àÖ</s:term></s:table-cell>
              <s:table-cell>The empty set</s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term s:type="expression">ùîπ</s:term></s:table-cell>
              <s:table-cell>The booleans</s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term s:type="expression">‚Ñï</s:term></s:table-cell>
              <s:table-cell>The natural numbers</s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term s:type="expression">‚Ñù</s:term></s:table-cell>
              <s:table-cell>The real numbers</s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term s:type="expression">‚Ñ§</s:term></s:table-cell>
              <s:table-cell>The integers</s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term s:type="expression">[a, b]</s:term></s:table-cell>
              <s:table-cell>A closed interval in a set (given separately or implicit from the types of <s:term s:type="expression">a</s:term> and <s:term s:type="expression">b</s:term>), from <s:term s:type="expression">a</s:term> to <s:term s:type="expression">b</s:term>, including <s:term s:type="expression">a</s:term> and <s:term s:type="expression">b</s:term></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term s:type="expression">(a, b]</s:term></s:table-cell>
              <s:table-cell>A closed interval in a set (given separately or implicit from the types of <s:term s:type="expression">a</s:term> and <s:term s:type="expression">b</s:term>), from <s:term s:type="expression">a</s:term> to <s:term s:type="expression">b</s:term>, excluding <s:term s:type="expression">a</s:term> but including <s:term s:type="expression">b</s:term></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term s:type="expression">[a, b)</s:term></s:table-cell>
              <s:table-cell>A closed interval in a set (given separately or implicit from the types of <s:term s:type="expression">a</s:term> and <s:term s:type="expression">b</s:term>), from <s:term s:type="expression">a</s:term> to <s:term s:type="expression">b</s:term>, including <s:term s:type="expression">a</s:term> but excluding <s:term s:type="expression">b</s:term></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term s:type="expression">(a, b)</s:term></s:table-cell>
              <s:table-cell>A closed interval in a set (given separately or implicit from the types of <s:term s:type="expression">a</s:term> and <s:term s:type="expression">b</s:term>), from <s:term s:type="expression">a</s:term> to <s:term s:type="expression">b</s:term>, excluding <s:term s:type="expression">a</s:term> and <s:term s:type="expression">b</s:term></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term s:type="expression">A ‚äÇ B</s:term></s:table-cell>
              <s:table-cell><s:term s:type="expression">A</s:term> is a subset of, and is not equal to, <s:term s:type="expression">B</s:term></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term s:type="expression">A ‚äÜ B</s:term></s:table-cell>
              <s:table-cell><s:term s:type="expression">A</s:term> is a subset of, or is equal to, <s:term s:type="expression">B</s:term></s:table-cell>
            </s:table-row>
          </s:table-body>
        </s:table>
      </s:formal-item>
    </s:section>

    <s:section>
      <s:section-title>Tuples</s:section-title>
      <s:paragraph>
        The notation <s:term s:type="expression">tuples(S, N)</s:term> denotes the
        set of n-tuples of length <s:term s:type="variable">N</s:term> of elements
        taken from the set <s:term s:type="variable">S</s:term>, where
        <s:term s:type="variable">N</s:term> is non-negative. For a given set
        <s:term s:type="variable">S</s:term>, the set of n-tuples may be defined
        inductively as follows:
      </s:paragraph>
      <s:formal-item s:kind="specifications" s:type="specifications">
        <s:formal-item-title>Tuples</s:formal-item-title>
        <s:list-unordered>
          <s:list-item>
            <s:term s:type="expression">tuples(S, 0)</s:term> is the set of
            0-tuples, containing one element denoted <s:term s:type="expression">()</s:term>.
          </s:list-item>
          <s:list-item>
            <s:term s:type="expression">tuples(S, N)</s:term> is an ordered pair
            <s:term s:type="expression">(x, tuples(S, N - 1))</s:term> where
            <s:term s:type="expression">x ‚àà S</s:term>.
          </s:list-item>
        </s:list-unordered>
      </s:formal-item>
      <s:paragraph>
        Some example sets of n-tuples are as follows:
      </s:paragraph>
      <s:formal-item s:kind="examples" s:type="examples">
        <s:formal-item-title>Example n-tuple sets</s:formal-item-title>
        <s:verbatim><![CDATA[S = { 1, 2, 3 }

tuples(S, 0) = { () }

tuples(S, 1) = {
  (1, ()),
  (2, ()),
  (3, ())
}

tuples(S, 2) = {
  (1, (1, ())),
  (2, (1, ())),
  (3, (1, ())),
  (1, (2, ())),
  (2, (2, ())),
  (3, (2, ())),
  (1, (3, ())),
  (2, (3, ())),
  (3, (3, ()))
}]]></s:verbatim>
      </s:formal-item>
      <s:paragraph>
        Specific n-tuples are denoted <s:term s:type="expression">P = (x‚ÇÄ, x‚ÇÅ, ..., x‚Çô)</s:term>,
        which is essentially shorthand for <s:term s:type="expression">P = (x‚ÇÄ, (x‚ÇÅ, (... (x‚Çô, ()))))</s:term>,
        with the <s:term s:type="expression">0th</s:term> element of
        <s:term s:type="expression">P</s:term> being <s:term s:type="expression">x‚ÇÄ</s:term> and
        the <s:term s:type="expression">nth</s:term> element being
        <s:term s:type="expression">x‚Çô</s:term>.
      </s:paragraph>
    </s:section>

    <s:section>
      <s:section-title>Types</s:section-title>
      <s:paragraph>
        The specification (and the <s:term s:type="package">parasol</s:term> language itself)
        uses notation and concepts taken from type theory
        <s:footnote>
          <s:link-external s:target="http://en.wikipedia.org/wiki/Type_theory">https://en.wikipedia.org/wiki/Type_theory</s:link-external>
        </s:footnote>.
        A summary of the notation used is as follows:
      </s:paragraph>
      <s:formal-item s:kind="notations" s:type="notations">
        <s:formal-item-title>Type notation</s:formal-item-title>
        <s:table>
          <s:table-summary>Type notation</s:table-summary>
          <s:table-head>
            <s:table-column-name>Notation</s:table-column-name>
            <s:table-column-name>Description</s:table-column-name>
            <s:table-column-name>Example</s:table-column-name>
          </s:table-head>
          <s:table-body>
            <s:table-row>
              <s:table-cell><s:term s:type="expression">x : A</s:term></s:table-cell>
              <s:table-cell>The term <s:term s:type="variable">x</s:term> is of type <s:term s:type="variable">A</s:term></s:table-cell>
              <s:table-cell><s:term s:type="expression">23 : ‚Ñï</s:term></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term s:type="expression">A ‚Üí B</s:term></s:table-cell>
              <s:table-cell>The type of functions from values of type <s:term s:type="variable">A</s:term> to values of type <s:term s:type="variable">B</s:term></s:table-cell>
              <s:table-cell><s:term s:type="expression">even : ‚Ñï ‚Üí ùîπ</s:term></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term s:type="expression">A √ó B</s:term></s:table-cell>
              <s:table-cell>The type of products of <s:term s:type="variable">A</s:term> and <s:term s:type="variable">B</s:term></s:table-cell>
              <s:table-cell><s:term s:type="expression">(23, true) : ‚Ñï √ó ùîπ</s:term></s:table-cell>
            </s:table-row>
          </s:table-body>
        </s:table>
      </s:formal-item>
      <s:paragraph>
        Product types are typically used to encode the notion of
        <s:term s:type="term">n-ary functions</s:term>,
        where <s:term s:type="expression">(A √ó B √ó C) ‚Üí D</s:term>
        is the type of functions that take three arguments of types
        <s:term s:type="expression">A</s:term>, <s:term s:type="expression">B</s:term>,
        and <s:term s:type="expression">C</s:term>, respectively, and return
        values of type <s:term s:type="expression">D</s:term>.
      </s:paragraph>
    </s:section>

    <s:section xml:id="spec.notation.type_rules">
      <s:section-title>Type rules</s:section-title>
      <s:paragraph>
        Declarative type rules describe the precise rules for assigning
        <s:term s:type="term">types</s:term> to <s:term s:type="term">terms</s:term>.
        If no type rule matches a term, then that term is considered ill-typed.
      </s:paragraph>
      <s:paragraph>
        Type rules are given as zero or more <s:term s:type="term">premises</s:term>,
        and a single <s:term s:type="term">conclusion</s:term>, separated by a horizontal
        line. For a given rule, when all of the <s:term s:type="term">premises</s:term>
        are true, then the <s:term s:type="term">conclusion</s:term> is true. If a rule
        has no <s:term s:type="term">premises</s:term> then the rule is taken as an
        <s:term s:type="term">axiom</s:term>.
      </s:paragraph>
      <s:paragraph>
        The <s:term s:type="term">gamma</s:term> symbol <s:term s:type="constant">Œì</s:term>
        (<s:term s:type="constant">U+0393</s:term>)
        represents the current <s:term s:type="term">typing environment</s:term> and
        can be thought of as a mapping from distinct variables to their types, with
        the set of variables in environment denoted by <s:term s:type="expression">dom(Œì)</s:term>
        (the domain of <s:term s:type="constant">Œì</s:term>). The notation
        <s:term s:type="expression">Œì ‚ä¢ P</s:term> reads "<s:term s:type="expression">Œì</s:term>
        <s:term s:type="term">implies</s:term>
        <s:term s:type="expression">P</s:term>" and is used in type rules to assign types to terms.
        The empty typing environment is represented by <s:term s:type="constant">‚àÖ</s:term>
        (<s:term s:type="constant">U+2205</s:term>). The <s:term s:type="term">diamond</s:term> symbol
        <s:term s:type="constant">‚óá</s:term> (<s:term s:type="constant">U+25C7</s:term>)
        should be read as "is well-formed", so <s:term s:type="expression">Œì ‚ä¢ ‚óá</s:term>
        should be read as "the current typing environment is well-formed". The concept
        of well-formedness is often type-system-specific and is usually described when
        the rules are given. A summary of the notation is as follows:
      </s:paragraph>
      <s:formal-item s:kind="notations" s:type="notations">
        <s:formal-item-title>Type rule notation</s:formal-item-title>
        <s:table>
          <s:table-summary>Type rule notation</s:table-summary>
          <s:table-head>
            <s:table-column-name>Notation</s:table-column-name>
            <s:table-column-name>Description</s:table-column-name>
            <s:table-column-name>Example</s:table-column-name>
          </s:table-head>
          <s:table-body>
            <s:table-row>
              <s:table-cell><s:term s:type="constant">Œì</s:term></s:table-cell>
              <s:table-cell>The current typing environment</s:table-cell>
              <s:table-cell><s:term s:type="expression">Œì</s:term></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term s:type="constant">‚àÖ</s:term></s:table-cell>
              <s:table-cell>The empty typing environment</s:table-cell>
              <s:table-cell><s:term s:type="expression">‚àÖ</s:term></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term s:type="expression">Œì, x</s:term></s:table-cell>
              <s:table-cell>The typing environment <s:term s:type="constant">Œì</s:term>
                extended with the variable <s:term s:type="expression">x</s:term>
                <s:footnote>
                  Usually accompanied with a side condition that
                  <s:term s:type="variable">x</s:term> does not appear in
                  <s:term s:type="expression">dom(Œì)</s:term>)
                </s:footnote>
              </s:table-cell>
              <s:table-cell><s:term s:type="expression">Œì, x</s:term> where <s:term s:type="expression">x ‚àâ dom(Œì)</s:term></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term s:type="expression">dom(Œì)</s:term></s:table-cell>
              <s:table-cell>The set of distinct variables in <s:term s:type="constant">Œì</s:term></s:table-cell>
              <s:table-cell><s:term s:type="expression">dom((‚àÖ, x, y)) = { x, y }</s:term></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term s:type="expression">Œì ‚ä¢ P</s:term></s:table-cell>
              <s:table-cell>The environment <s:term s:type="constant">Œì</s:term> implies <s:term s:type="expression">P</s:term></s:table-cell>
              <s:table-cell><s:term s:type="expression">Œì ‚ä¢ 23 : ‚Ñï</s:term> (in the current typing environment, <s:term s:type="expression">23</s:term> is of type <s:term s:type="expression">‚Ñï</s:term>)</s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term s:type="expression">Œì ‚ä¢ ‚óá</s:term></s:table-cell>
              <s:table-cell>The environment <s:term s:type="constant">Œì</s:term> is <s:term s:type="term">well-formed</s:term></s:table-cell>
              <s:table-cell><s:term s:type="expression">‚àÖ ‚ä¢ ‚óá</s:term> (the empty typing environment is well-formed)</s:table-cell>
            </s:table-row>
          </s:table-body>
        </s:table>
      </s:formal-item>
      <s:paragraph>
        An example of typing rules for natural number addition:
      </s:paragraph>
      <s:formal-item s:kind="examples">
        <s:formal-item-title>Natural number addition typing</s:formal-item-title>
        <s:image s:source="png/tyex_typing_example.png">Natural number addition typing</s:image>
      </s:formal-item>
      <s:paragraph>
        The <s:term s:type="element">empty</s:term> rule states that the empty
        typing environment is well-formed. Because there are no premises above
        the horizontal line, this is taken as an <s:term s:type="term">axiom</s:term>.
        The <s:term s:type="element">extension</s:term> rule states that adding
        a term to the typing environment that is not already in that environment,
        results in a well-formed environment.
        The <s:term s:type="element">natural_intro</s:term> rule states that,
        given a well-formed typing environment, any expression that is
        syntactically a natural number (represented by
        <s:term s:type="variable">‚Ñï</s:term>) has type
        <s:term s:type="type">natural</s:term>. The
        <s:term s:type="element">natural_plus</s:term> rule states that, if variables
        <s:term s:type="variable">m</s:term> and <s:term s:type="variable">n</s:term>
        have type <s:term s:type="type">natural</s:term> in the current typing
        environment, then <s:term s:type="expression">m + n</s:term> has type
        <s:term s:type="type">natural</s:term>. When checking the type of the
        expression <s:term s:type="expression">m + n</s:term>, the rules are used
        to construct a <s:term s:type="term">derivation tree</s:term> as follows:
      </s:paragraph>
      <s:formal-item s:kind="examples">
        <s:formal-item-title>Natural number addition derivation</s:formal-item-title>
        <s:image s:source="png/tyex_typing_example_derivation.png">Natural number addition derivation</s:image>
      </s:formal-item>
      <s:paragraph>
        Intuitively, a term only has a valid type if there is a sequence of rules
        from the empty environment that can assign a type to the term.
      </s:paragraph>
    </s:section>

    <s:section xml:id="spec.notation.op_semantics">
      <s:section-title>Operational Semantics</s:section-title>
      <s:paragraph>
        Operational semantics describe the precise rules for the evaluation
        of expressions in a given language. The rules make up the description
        of an <s:term s:type="term">abstract machine</s:term> which passes
        through different states, one rule (or <s:term s:type="term">step</s:term>)
        at a time, until the machine <s:term s:type="term">halts</s:term>
        and produces a <s:term s:type="term">value</s:term>.
      </s:paragraph>
      <s:paragraph>
        Typically, operational semantics begin by first giving a set of
        <s:term s:type="term">values</s:term>, indicating the final results
        of evaluation, and a set of identifiers syntactically identifying
        the set of evaluable <s:term s:type="term">expressions</s:term>. The
        evaluation rules themselves are given in a style similar to
        <s:link s:target="spec.notation.type_rules">type rules</s:link>,
        where a rule applies if the
        <s:term s:type="term">premises</s:term> above the horizontal line are
        true, and the <s:term s:type="term">conclusion</s:term> indicates how
        the state of the abstract machine changes when the rule is applied.
      </s:paragraph>
      <s:paragraph>
        As an example, assume a language of conditional expressions.
        An example expression in this language would be:
      </s:paragraph>
      <s:formal-item s:kind="examples">
        <s:formal-item-title>Conditionals example</s:formal-item-title>
        <s:verbatim><![CDATA[if true then
  if false then
    true
  else
    if
      if true then
        false
      else
        true
      end
    then
      false
    else
      true
    end
  end
else
  true
end]]></s:verbatim>
      </s:formal-item>
      <s:paragraph>
        The <s:term s:type="term">values</s:term> of this language are
        <s:term s:type="constant">true</s:term> and <s:term s:type="constant">false</s:term>.
        The <s:term s:type="term">expressions</s:term> in this language
        include the <s:term s:type="term">values</s:term>, and the form
        <s:term s:type="expression">if e‚ÇÄ then e‚ÇÅ else e‚ÇÇ end</s:term>, where
        <s:term s:type="expression">e‚ÇÄ</s:term>,
        <s:term s:type="expression">e‚ÇÅ</s:term> and
        <s:term s:type="expression">e‚ÇÇ</s:term> are expressions. There
        are clearly multiple ways to evaluate expressions in this language,
        but in order to produce an algorithm that will execute on a computer,
        the evaluation rules should be:
      </s:paragraph>
      <s:formal-item s:kind="specifications">
        <s:formal-item-title>Evaluation characteristics</s:formal-item-title>
        <s:list-unordered>
          <s:list-item>
            Deterministic. That is, given a non-<s:term s:type="term">value</s:term> expression
            <s:term s:type="expression">e</s:term>,
            there must be <s:term s:type="term">at most</s:term> one evaluation rule that
            applies in order to work towards producing a value from
            <s:term s:type="expression">e</s:term>. If multiple rules apply, then
            evaluation is nondeterministic.
          </s:list-item>
          <s:list-item>
            Complete. That is, given a non-<s:term s:type="term">value</s:term> expression
            <s:term s:type="expression">e</s:term>,
            there must be <s:term s:type="term">at least</s:term> one evaluation rule that
            applies in order to work towards producing a value from
            <s:term s:type="expression">e</s:term>. If no rule applies, then
            evaluation is said to be <s:term s:type="term">stuck</s:term>.
          </s:list-item>
        </s:list-unordered>
      </s:formal-item>
      <s:paragraph>
        The operational semantics for the language could be written as
        follows:
      </s:paragraph>
      <s:formal-item s:kind="examples">
        <s:formal-item-title>Conditional semantics</s:formal-item-title>
        <s:image s:source="png/semantics_example.png">Conditional semantics</s:image>
      </s:formal-item>
      <s:paragraph>
        Expressions are assigned the identifiers
        <s:term s:type="expression">e‚ÇÄ</s:term> to
        <s:term s:type="expression">e‚Çô</s:term>, so terms of those forms
        are assumed to be evaluable expressions when they appear in rules.
      </s:paragraph>
      <s:paragraph>
        The notation <s:term s:type="expression">e ‚Üí e'</s:term> should be
        read "<s:term s:type="expression">e</s:term> evaluates to <s:term s:type="expression">e'</s:term>
        in a single step".
      </s:paragraph>
      <s:paragraph>
        The <s:term s:type="variable">if_true</s:term> rule states that
        if the condition of an <s:term s:type="keyword">if</s:term> expression
        is exactly <s:term s:type="constant">true</s:term>, then the expression
        evaluates to the expression given in the left branch, in one step.
      </s:paragraph>
      <s:paragraph>
        The <s:term s:type="variable">if_false</s:term> rule states that
        if the condition of an <s:term s:type="keyword">if</s:term> expression
        is exactly <s:term s:type="constant">false</s:term>, then the expression
        evaluates to the expression given in the right branch, in one step.
      </s:paragraph>
      <s:paragraph>
        The <s:term s:type="variable">if_condition</s:term> rule states that
        if the condition of an <s:term s:type="keyword">if</s:term> expression
        is not a value, then the condition is evaluated first.
      </s:paragraph>
      <s:paragraph>
        The example expression given earlier can now be evaluated completely
        and deterministically by following the given rules:
      </s:paragraph>
      <s:formal-item s:kind="examples">
        <s:formal-item-title>Conditionals example evaluation</s:formal-item-title>
        <s:verbatim><![CDATA[if true then
  if false then
    true
  else
    if
      if true then
        false
      else
        true
      end
    then
      false
    else
      true
    end
  end
else
  true
end

‚Üí by if_true to:

if false then
  true
else
  if
    if true then
      false
    else
      true
    end
  then
    false
  else
    true
  end
end

‚Üí by if_false to:

if
  if true then
    false
  else
    true
  end
then
  false
else
  true
end

‚Üí by if_condition to:

if
  false
then
  false
else
  true
end

‚Üí by if_false to:

true
]]></s:verbatim>
      </s:formal-item>
      <s:paragraph>
        The <s:term s:type="term">substitution</s:term> notation
        <s:term s:type="expression">e [x := y]</s:term> denotes
        the expression <s:term s:type="expression">e</s:term> where all
        occurences (if any) of the variable <s:term s:type="variable">x</s:term>
        have been replaced with <s:term s:type="variable">y</s:term>. This
        is used, for example, to describe function evaluation:
      </s:paragraph>
      <s:formal-item s:kind="examples">
        <s:formal-item-title>Function semantics</s:formal-item-title>
        <s:image s:source="png/semantics_example2.png">Function semantics</s:image>
      </s:formal-item>
      <s:paragraph>
        The <s:term s:type="variable">function_eval_0</s:term> and
        <s:term s:type="variable">function_eval_1</s:term> rules state that
        expressions are evaluated from left-to-right when applying
        <s:term s:type="expression">f</s:term> to a pair of arguments.
      </s:paragraph>
      <s:paragraph>
        The <s:term s:type="variable">function_eval_2</s:term> rule states
        that when all of the expressions passed to <s:term s:type="expression">f</s:term>
        have been reduced to values, the expression as a whole evaluates to
        the body of <s:term s:type="expression">f</s:term>, called
        <s:term s:type="expression">e</s:term>, with occurrences of
        the arguments <s:term s:type="variable">x</s:term> and
        <s:term s:type="variable">y</s:term> in
        <s:term s:type="expression">e</s:term> substituted with their
        values.
      </s:paragraph>
    </s:section>

    <s:section>
      <s:section-title>OpenGL</s:section-title>
      <s:paragraph>
        As the <s:term s:type="package">parasol</s:term> language is intended
        to be executed on programmable GPUs, familiarity with OpenGL and
        the OpenGL shading language is assumed.
      </s:paragraph>
    </s:section>
  </s:part>

  <s:part xml:id="spec.lex">
    <s:part-title>Lexical Conventions</s:part-title>
    <s:part-contents/>

    <s:section xml:id="spec.lex.units">
      <s:section-title>Units</s:section-title>
      <s:paragraph>
        The text of a <s:term s:type="package">parasol</s:term> program is a combination
        of the texts of separate <s:term s:type="term">units</s:term>, where a
        <s:term s:type="term">unit</s:term> typically corresponds to a file in the
        operating system under which the compiler is running.
      </s:paragraph>
      <s:paragraph>
        Units consist of a series of lexical <s:term s:type="term">tokens</s:term>
        separated by
        <s:link s:target="spec.lex.whitespace">whitespace</s:link>.
        What constitutes a <s:term s:type="term">token</s:term> is the subject of
        the following sections.
      </s:paragraph>
    </s:section>

    <s:section xml:id="spec.lex.charset">
      <s:section-title>Character set</s:section-title>
      <s:paragraph>
        The character set used for <s:term s:type="package">parasol</s:term>
        program source code is UTF-8. Inside of
        <s:link s:target="spec.lex.comments">comments</s:link>,
        any Unicode character is permitted. Outside of comments, the subset
        of UTF-8 permitted for use in programs is detailed in the following
        sections.
      </s:paragraph>
    </s:section>

    <s:section xml:id="spec.lex.whitespace">
      <s:section-title>Whitespace</s:section-title>
      <s:paragraph>
        The following characters are considered to be whitespace:
      </s:paragraph>
      <s:formal-item s:kind="specifications" s:type="specifications">
        <s:formal-item-title>Whitespace</s:formal-item-title>
        <s:table>
          <s:table-summary>Whitespace characters</s:table-summary>
          <s:table-head>
            <s:table-column-name>Codepoint</s:table-column-name>
            <s:table-column-name>Name</s:table-column-name>
          </s:table-head>
          <s:table-body>
            <s:table-row><s:table-cell>U+0009</s:table-cell><s:table-cell>Horizontal tab</s:table-cell></s:table-row>
            <s:table-row><s:table-cell>U+000A</s:table-cell><s:table-cell>Line feed</s:table-cell></s:table-row>
            <s:table-row><s:table-cell>U+000C</s:table-cell><s:table-cell>Form feed</s:table-cell></s:table-row>
            <s:table-row><s:table-cell>U+000D</s:table-cell><s:table-cell>Carriage return</s:table-cell></s:table-row>
            <s:table-row><s:table-cell>U+0020</s:table-cell><s:table-cell>Space</s:table-cell></s:table-row>
          </s:table-body>
        </s:table>
      </s:formal-item>
      <s:paragraph>
        Lines of source are separated with <s:term s:type="term">line_separator</s:term>, which
        may be any of the following:
      </s:paragraph>
      <s:formal-item s:kind="specifications" s:type="specifications">
        <s:formal-item-title>Line separators</s:formal-item-title>
        <s:table>
          <s:table-summary>Line separators</s:table-summary>
          <s:table-head>
            <s:table-column-name>Codepoint(s)</s:table-column-name>
            <s:table-column-name>Name</s:table-column-name>
          </s:table-head>
          <s:table-body>
            <s:table-row><s:table-cell>U+000A</s:table-cell><s:table-cell>Line feed</s:table-cell></s:table-row>
            <s:table-row><s:table-cell>U+000D</s:table-cell><s:table-cell>Carriage return</s:table-cell></s:table-row>
            <s:table-row><s:table-cell>U+000D U+000A</s:table-cell><s:table-cell>Carriage return immediately followed by line feed</s:table-cell></s:table-row>
          </s:table-body>
        </s:table>
      </s:formal-item>
    </s:section>

    <s:section xml:id="spec.lex.comments">
      <s:section-title>Comments</s:section-title>
      <s:paragraph>
        A <s:term s:type="term">comment</s:term> starts with <s:term s:type="constant">--</s:term>
        (two adjacent <s:term s:type="constant">U+002D</s:term> characters) and extends to
        the end of the line. Comments may appear on any line in a
        <s:link s:target="spec.lex.units">unit</s:link>.
        The contents of comments have no effect whatsoever on the semantics of
        <s:term s:type="package">parasol</s:term> programs.
      </s:paragraph>
    </s:section>

    <s:section xml:id="spec.lex.tokens">
    <s:section-title>Tokens</s:section-title>

    <s:subsection xml:id="spec.lex.tokens.integer-literal">
      <s:subsection-title>Integer literals</s:subsection-title>
      <s:paragraph>
        An <s:term s:type="term">integer_literal</s:term> is a sequence
        of one or more digits, optionally preceded by a minus sign
        (<s:term s:type="constant">U+002D</s:term>), representing
        a decimal integer. The precise syntax is given by the following EBNF:
      </s:paragraph>
      <s:formal-item s:kind="specifications" s:type="specifications">
        <s:formal-item-title>Integer literals</s:formal-item-title>
        <s:verbatim><![CDATA[digit_nonzero =
  "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;

digit =
  "0" | digit_nonzero ;

integer =
  "0" | ( ["-"] , digit_nonzero , { digit } ) ;]]></s:verbatim>
      </s:formal-item>
    </s:subsection>

    <s:subsection xml:id="spec.lex.tokens.real-literal">
      <s:subsection-title>Real literals</s:subsection-title>
      <s:paragraph>
        A <s:term s:type="term">real_literal</s:term> consists of
        an integral and fractional part, separated by a dot
        (<s:term s:type="constant">U+002E</s:term>) and optionally
        preceded by a minus sign (<s:term s:type="constant">U+002D</s:term>),
        and represents a real number. The precise syntax is given by
        the following EBNF:
      </s:paragraph>
      <s:formal-item s:kind="specifications" s:type="specifications">
        <s:formal-item-title>Real literals</s:formal-item-title>
        <s:verbatim><![CDATA[real =
  ["-"] , digit , { digit } , "." , digit , { digit } ;]]></s:verbatim>
      </s:formal-item>
    </s:subsection>

    <s:subsection xml:id="spec.lex.tokens.boolean-literal">
      <s:subsection-title>Boolean literals</s:subsection-title>
      <s:paragraph>
        A <s:term s:type="term">boolean_literal</s:term> is either
        <s:term s:type="constant">true</s:term> or
        <s:term s:type="constant">false</s:term>. The precise syntax is
        given by  the following EBNF:
      </s:paragraph>
      <s:formal-item s:kind="specifications" s:type="specifications">
        <s:formal-item-title>Boolean literals</s:formal-item-title>
        <s:verbatim><![CDATA[boolean_literal =
  "true" | "false" ;]]></s:verbatim>
      </s:formal-item>
    </s:subsection>

    <s:subsection xml:id="spec.lex.tokens.identifier">
      <s:subsection-title>Identifiers</s:subsection-title>
      <s:paragraph>
        Identifiers are sequences of uppercase letters
        (<s:term s:type="constant">[U+0041, U+005A]</s:term>), lowercase
        letters (<s:term s:type="constant">[U+0061, U+007A]</s:term>),
        and underscores (<s:term s:type="constant">U+005F</s:term>). An
        identifier is uppercase iff its first character is an uppercase
        letter, or lowercase iff its first character is a lowercase letter.
        Identifiers cannot begin with underscores or digits. The precise
        syntax is given by the following EBNF:
      </s:paragraph>
      <s:formal-item s:kind="specifications" s:type="specifications">
        <s:formal-item-title>Identifiers</s:formal-item-title>
        <s:verbatim><![CDATA[letter_lower =
  "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" |
  "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" |
  "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" |
  "y" | "z" ;

letter_upper =
  "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" |
  "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" |
  "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" |
  "Y" | "Z" ;

letter =
  letter_lower | letter_upper ;

name_lower =
  letter_lower , { letter | digit | "-" | "_" } ;

name_upper =
  letter_upper , { letter | digit | "-" | "_" } ;]]></s:verbatim>
      </s:formal-item>
    </s:subsection>

    <s:subsection xml:id="spec.lex.tokens.keywords">
      <s:subsection-title>Keywords</s:subsection-title>
      <s:paragraph>
        All of the following character sequences are reserved as keywords
        and cannot be used otherwise:
      </s:paragraph>
      <s:formal-item s:kind="specifications" s:type="specifications">
        <s:formal-item-title>Keywords</s:formal-item-title>
        <s:list-unordered>
<s:list-item><s:term s:type="keyword">:</s:term> (<s:term s:type="constant">U+003A</s:term>)</s:list-item>
<s:list-item><s:term s:type="keyword">,</s:term> (<s:term s:type="constant">U+002C</s:term>)</s:list-item>
<s:list-item><s:term s:type="keyword">{</s:term> (<s:term s:type="constant">U+007B</s:term>)</s:list-item>
<s:list-item><s:term s:type="keyword">}</s:term> (<s:term s:type="constant">U+007D</s:term>)</s:list-item>
<s:list-item><s:term s:type="keyword">.</s:term> (<s:term s:type="constant">U+002E</s:term>)</s:list-item>
<s:list-item><s:term s:type="keyword">=</s:term> (<s:term s:type="constant">U+003D</s:term>)</s:list-item>
<s:list-item><s:term s:type="keyword">(</s:term> (<s:term s:type="constant">U+0028</s:term>)</s:list-item>
<s:list-item><s:term s:type="keyword">)</s:term> (<s:term s:type="constant">U+0029</s:term>)</s:list-item>
<s:list-item><s:term s:type="keyword">;</s:term> (<s:term s:type="constant">U+003B</s:term>)</s:list-item>
<s:list-item><s:term s:type="keyword">[</s:term> (<s:term s:type="constant">U+005B</s:term>)</s:list-item>
<s:list-item><s:term s:type="keyword">]</s:term> (<s:term s:type="constant">U+005D</s:term>)</s:list-item>

<s:list-item><s:term s:type="keyword">as</s:term></s:list-item>
<s:list-item><s:term s:type="keyword">discard</s:term></s:list-item>
<s:list-item><s:term s:type="keyword">else</s:term></s:list-item>
<s:list-item><s:term s:type="keyword">end</s:term></s:list-item>
<s:list-item><s:term s:type="keyword">false</s:term></s:list-item>
<s:list-item><s:term s:type="keyword">fragment</s:term></s:list-item>
<s:list-item><s:term s:type="keyword">function</s:term></s:list-item>
<s:list-item><s:term s:type="keyword">if</s:term></s:list-item>
<s:list-item><s:term s:type="keyword">import</s:term></s:list-item>
<s:list-item><s:term s:type="keyword">in</s:term></s:list-item>
<s:list-item><s:term s:type="keyword">is</s:term></s:list-item>
<s:list-item><s:term s:type="keyword">let</s:term></s:list-item>
<s:list-item><s:term s:type="keyword">module</s:term></s:list-item>
<s:list-item><s:term s:type="keyword">new</s:term></s:list-item>
<s:list-item><s:term s:type="keyword">out</s:term></s:list-item>
<s:list-item><s:term s:type="keyword">package</s:term></s:list-item>
<s:list-item><s:term s:type="keyword">parameter</s:term></s:list-item>
<s:list-item><s:term s:type="keyword">program</s:term></s:list-item>
<s:list-item><s:term s:type="keyword">record</s:term></s:list-item>
<s:list-item><s:term s:type="keyword">shader</s:term></s:list-item>
<s:list-item><s:term s:type="keyword">then</s:term></s:list-item>
<s:list-item><s:term s:type="keyword">true</s:term></s:list-item>
<s:list-item><s:term s:type="keyword">type</s:term></s:list-item>
<s:list-item><s:term s:type="keyword">value</s:term></s:list-item>
<s:list-item><s:term s:type="keyword">vertex</s:term></s:list-item>
<s:list-item><s:term s:type="keyword">with</s:term></s:list-item>
        </s:list-unordered>
      </s:formal-item>
    </s:subsection>
    </s:section>
  </s:part>

  <s:part xml:id="spec.declarations">
    <s:part-title>Declarations</s:part-title>
    <s:part-contents/>

    <s:section>
      <s:section-title>Overview</s:section-title>
      <s:paragraph>
        The <s:term s:type="package">parasol</s:term> language
        consists of <s:link s:target="spec.declarations.terms">terms</s:link>,
        <s:link s:target="spec.declarations.types">types</s:link>, and
        <s:link s:target="spec.declarations.shaders">shaders</s:link>, which are
        organized into
        <s:link s:target="spec.declarations.modules">modules</s:link>
        (which are further organized into
        <s:link s:target="spec.declarations.packages">packages</s:link>).
      </s:paragraph>
    </s:section>

    <s:section xml:id="spec.declarations.terms">
      <s:section-title>Terms</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          <s:term s:type="term">Terms</s:term> are the computational elements
          of the <s:term s:type="package">parasol</s:term> language. They consist
          of <s:link s:target="spec.declarations.terms.values">values</s:link>,
          which effectively give names to expressions, and
          <s:link s:target="spec.declarations.terms.functions">functions</s:link>,
          which are named computational rules in the mathematical sense.
        </s:paragraph>
      </s:subsection>

      <s:subsection>
        <s:subsection-title>Declarations</s:subsection-title>
        <s:paragraph>
          A <s:term s:type="term">term_declaration</s:term> may either be a
          <s:link s:target="spec.declarations.terms.values">value_declaration</s:link>
          or a
          <s:link s:target="spec.declarations.terms.functions">function_declaration</s:link>.
        </s:paragraph>
      </s:subsection>

      <s:subsection xml:id="spec.declarations.terms.names">
        <s:subsection-title>Names</s:subsection-title>
        <s:paragraph>
          The names selected for terms must be unique with respect to
          other terms within the <s:link s:target="spec.declarations.modules">module</s:link>
          in which they are defined. That is, there cannot be two terms with the same name
          in the same module. Terms do not share a name space with
          <s:link s:target="spec.declarations.types">types</s:link>
          or <s:link s:target="spec.declarations.shaders">shaders</s:link>.
        </s:paragraph>
        <s:paragraph>
          The following restrictions apply when naming terms:
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Name restrictions</s:formal-item-title>
          <s:list-unordered>
            <s:list-item>
              Term names must begin with a <s:term s:type="term">lowercase</s:term>
              letter. This is directly implied by the
              <s:link s:target="spec.declarations.terms.syntax">grammar</s:link>.
            </s:list-item>
            <s:list-item>
              Names cannot contain two adjacent underscores (<s:term s:type="constant">U+005F</s:term>).
            </s:list-item>
            <s:list-item>
              Names cannot end with underscores (<s:term s:type="constant">U+005F</s:term>).
            </s:list-item>
            <s:list-item>
              Names cannot start with the character sequence "<s:term s:type="constant">gl_</s:term>"
              (<s:term s:type="constant">U+0067</s:term>,
               <s:term s:type="constant">U+006C</s:term>,
               <s:term s:type="constant">U+005F</s:term>).
            </s:list-item>
            <s:list-item>
              Names cannot match any of the keywords or reserved words defined in
              any version of the OpenGL shading language. See the
              <s:link s:target="spec.glsl-identifiers">GLSL identifiers</s:link>
              section for the complete list.
            </s:list-item>
          </s:list-unordered>
        </s:formal-item>
      </s:subsection>

      <s:subsection xml:id="spec.declarations.terms.recursion">
        <s:subsection-title>Recursion</s:subsection-title>
        <s:paragraph>
          No <s:term s:type="term">term_declaration</s:term> can be <s:term s:type="term">recursive</s:term>
          with respect to itself or any other <s:term s:type="term">term_declaration</s:term>
          in the <s:link s:target="spec.declarations.modules">module</s:link>
          in which it appears.
        </s:paragraph>
        <s:paragraph>
          A term <s:term s:type="variable">d‚ÇÄ</s:term> is said to
          <s:term s:type="term">refer statically</s:term> to a
          term <s:term s:type="variable">d‚ÇÅ</s:term> if
          the <s:term s:type="term">free variables</s:term> of <s:term s:type="variable">d‚ÇÄ</s:term>
          contain the name of <s:term s:type="variable">d‚ÇÅ</s:term>.
        </s:paragraph>
        <s:paragraph>
          A <s:term s:type="term">term_declaration</s:term> <s:term s:type="variable">d</s:term>
          is (mutually) <s:term s:type="term">recursive</s:term> iff:
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Recursion conditions</s:formal-item-title>
          <s:list-unordered>
            <s:list-item>
              <s:term s:type="variable">d</s:term> refers statically to itself.
            </s:list-item>
            <s:list-item>
              There is a sequence of terms <s:term s:type="expression">t‚ÇÄ, t‚ÇÅ, ..., t‚Çô</s:term>
              such that <s:term s:type="variable">d</s:term> refers statically to
              <s:term s:type="variable">t‚ÇÄ</s:term>, and
              for all <s:term s:type="variable">m</s:term> where <s:term s:type="expression">0 &lt;= m &lt; n</s:term>,
              <s:term s:type="variable">t‚Çò</s:term> refers statically
              <s:term s:type="expression">t‚Çç‚Çò‚Çä‚ÇÅ‚Çé</s:term>, and
              <s:term s:type="variable">t‚Çô</s:term> refers statically to
              <s:term s:type="variable">d</s:term>.
            </s:list-item>
          </s:list-unordered>
        </s:formal-item>
      </s:subsection>

      <s:subsection xml:id="spec.declarations.terms.ordering">
        <s:subsection-title>Order of declarations</s:subsection-title>
        <s:paragraph>
          For the purposes of sorting term declarations based on their
          dependencies, terms can be <s:term s:type="term">partially ordered</s:term>
          based on the terms to which they refer statically. That is, if
          a term <s:term s:type="variable">t‚ÇÄ</s:term> refers statically to
          term <s:term s:type="variable">t‚ÇÅ</s:term>, then
          <s:term s:type="expression">t‚ÇÅ &lt; t‚ÇÄ</s:term>.
        </s:paragraph>
        <s:paragraph>
          Terms do not have to be declared in any given order. That is,
          if a term <s:term s:type="variable">t‚ÇÄ</s:term> refers statically
          to term <s:term s:type="variable">t‚ÇÅ</s:term> in the same module,
          there is no requirement that <s:term s:type="variable">t‚ÇÅ</s:term>
          be declared before <s:term s:type="variable">t‚ÇÄ</s:term>.
        </s:paragraph>
        <s:paragraph>
          Terms are sorted topologically prior to any evaluation based
          on the given partial order relation, and the
          restrictions on
          <s:link s:target="spec.declarations.terms.recursion">recursion</s:link>
          ensure that it is always possible to sort terms in the order
          of their dependencies.
        </s:paragraph>
      </s:subsection>

      <s:subsection xml:id="spec.declarations.terms.values">
        <s:subsection-title>Values</s:subsection-title>
        <s:paragraph>
          A <s:term s:type="term">value_declaration</s:term> binds an
          <s:link s:target="spec.expressions">expression</s:link>
          to a name.
        </s:paragraph>
        <s:paragraph>
          The <s:link s:target="spec.types">type</s:link> of
          the <s:term s:type="term">value_declaration</s:term> will be inferred
          from the given expression, but the declaration can be optionally ascribed
          with the name of a type, in which case the type of the expression will be
          checked against the ascription and an error raised in the case of a
          mismatch.
        </s:paragraph>
      </s:subsection>

      <s:subsection xml:id="spec.declarations.terms.functions">
        <s:subsection-title>Functions</s:subsection-title>
        <s:paragraph>
          A <s:term s:type="term">function_declaration</s:term> binds an
          <s:link s:target="spec.expressions">expression</s:link>
          <s:term s:type="variable">e</s:term> to a name along with a given
          <s:term s:type="term">return type</s:term>
          <s:term s:type="variable">t</s:term>
          and a set of <s:term s:type="term">formal parameters</s:term>,
          where <s:term s:type="variable">e</s:term> contains zero or more
          variables bound by the formal parameters and which, when
          evaluated, will result in a value of type <s:term s:type="variable">t</s:term>.
        </s:paragraph>
      </s:subsection>

      <s:subsection xml:id="spec.declarations.terms.type_rules">
        <s:subsection-title>Type rules</s:subsection-title>
        <s:paragraph>
          A <s:term s:type="term">value_declaration</s:term> of type
          <s:term s:type="variable">t</s:term> introduces a term of type
          <s:term s:type="variable">t</s:term> into the environment:
        </s:paragraph>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>Value declaration type rule (value_declaration)</s:formal-item-title>
          <s:image s:source="png/ty_value_declaration.png">Value declaration type rule (value_declaration)</s:image>
        </s:formal-item>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>Value declaration (ascribed) type rule (value_declaration_ascribed)</s:formal-item-title>
          <s:image s:source="png/ty_value_declaration_ascribed.png">Value declaration (ascribed) type rule (value_declaration_ascribed)</s:image>
        </s:formal-item>
        <s:paragraph>
          A <s:term s:type="term">function_declaration</s:term> with parameters of type
          <s:term s:type="expression">(s‚ÇÄ ‚úï s‚ÇÅ ‚úï ... s‚Çô)</s:term> that returns type
          <s:term s:type="variable">u</s:term> introduces a term of type
          <s:term s:type="variable">(s‚ÇÄ ‚úï s‚ÇÅ ‚úï ... s‚Çô) ‚Üí u</s:term> into the environment:
        </s:paragraph>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>Function declaration type rule (function_declaration)</s:formal-item-title>
          <s:image s:source="png/ty_function_declaration.png">Function declaration type rule (function_declaration)</s:image>
        </s:formal-item>
      </s:subsection>

      <s:subsection xml:id="spec.declarations.terms.semantics">
        <s:subsection-title>Operational semantics</s:subsection-title>
        <s:paragraph>
          With terms sorted according to their
          <s:link s:target="spec.declarations.terms.ordering">partial order</s:link>,
          evaluation of <s:term s:type="term">value_declarations</s:term>
          in the current <s:link s:target="spec.declarations.modules">module</s:link>
          proceeds from top-to-bottom, with the value of each evaluated
          <s:term s:type="term">value_declaration</s:term> being
          substituted into the terms that follow it:
        </s:paragraph>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>Top level evaluation (top_level)</s:formal-item-title>
          <s:image s:source="png/op_top_level.png">Top level evaluation (top_level)</s:image>
        </s:formal-item>
      </s:subsection>

      <s:subsection xml:id="spec.declarations.terms.syntax">
        <s:subsection-title>Syntax</s:subsection-title>
        <s:paragraph>
          The precise syntax of <s:term s:type="term">term_declarations</s:term>
          is given by the following EBNF:
        </s:paragraph>
      <s:formal-item s:kind="specifications" s:type="specifications">
        <s:formal-item-title>Term declaration syntax</s:formal-item-title>
        <s:verbatim><![CDATA[type_path =
    name_lower
  | name_upper , "." , name_lower ;

value_declaration =
  "value" , name_lower , [ ":" , type_path ] , "=" , expression ;

function_formal_parameter =
  name_lower , ":" , type_path ;

function_formal_parameters =
  "(" , function_formal_parameter, { "," , function_formal_parameter } , ")" ;

function_declaration =
  "function" , name_lower , function_formal_parameters , ":" , type_path , "=" , expression ;

term_declaration =
  value_declaration | function_declaration ;]]></s:verbatim>
        </s:formal-item>
      </s:subsection>

      <s:subsection xml:id="spec.declarations.terms.examples">
        <s:subsection-title>Examples</s:subsection-title>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Examples</s:formal-item-title>
          <s:verbatim><![CDATA[value x = 23;

value y = I.plus x 24;

function identity (
  x : integer
) : integer = x;]]></s:verbatim>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="spec.declarations.types">
      <s:section-title>Types</s:section-title>

      <s:subsection>
        <s:subsection-title>Declarations</s:subsection-title>
        <s:paragraph>
          A <s:term s:type="term">type_declaration</s:term> declares
          a new
          <s:link s:target="spec.declarations.types.records">record type</s:link>.
          This section documents the declarations themselves, while the
          <s:link s:target="spec.types">types</s:link>
          section documents the actual type system itself.
        </s:paragraph>
      </s:subsection>

      <s:subsection xml:id="spec.declarations.types.names">
        <s:subsection-title>Names</s:subsection-title>
        <s:paragraph>
          The names selected for types must be unique with respect to
          other types within the <s:link s:target="spec.declarations.modules">module</s:link>
          in which they are defined. That is, there cannot be two types with the same name
          in the same module. Types do not share a name space with
          <s:link s:target="spec.declarations.terms">terms</s:link>
          or <s:link s:target="spec.declarations.shaders">shaders</s:link>.
        </s:paragraph>
        <s:paragraph>
          The following restrictions apply when naming types:
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Name restrictions</s:formal-item-title>
          <s:list-unordered>
            <s:list-item>
              Type names must begin with a <s:term s:type="term">lowercase</s:term>
              letter. This is directly implied by the
              <s:link s:target="spec.declarations.types.syntax">grammar</s:link>.
            </s:list-item>
            <s:list-item>
              Names cannot contain two adjacent underscores (<s:term s:type="constant">U+005F</s:term>).
            </s:list-item>
            <s:list-item>
              Names cannot end with underscores (<s:term s:type="constant">U+005F</s:term>).
            </s:list-item>
            <s:list-item>
              Names cannot start with the character sequence "<s:term s:type="constant">gl_</s:term>"
              (<s:term s:type="constant">U+0067</s:term>,
               <s:term s:type="constant">U+006C</s:term>,
               <s:term s:type="constant">U+005F</s:term>).
            </s:list-item>
            <s:list-item>
              Names cannot match any of the keywords or reserved words defined in
              any version of the OpenGL shading language. See the
              <s:link s:target="spec.glsl-identifiers">GLSL identifiers</s:link>
              section for the complete list.
            </s:list-item>
          </s:list-unordered>
        </s:formal-item>
      </s:subsection>

      <s:subsection xml:id="spec.declarations.types.recursion">
        <s:subsection-title>Recursion</s:subsection-title>
        <s:paragraph>
          No <s:term s:type="term">type_declaration</s:term> can be <s:term s:type="term">recursive</s:term>
          with respect to itself or any other <s:term s:type="term">type_declaration</s:term>
          in the <s:link s:target="spec.declarations.modules">module</s:link>
          in which it appears.
        </s:paragraph>
        <s:paragraph>
          A type <s:term s:type="variable">d‚ÇÄ</s:term> is said to
          <s:term s:type="term">refer statically</s:term> to a
          type <s:term s:type="variable">d‚ÇÅ</s:term> if
          <s:term s:type="variable">d‚ÇÄ</s:term> appears anywhere in the
          definition of <s:term s:type="variable">d‚ÇÅ</s:term>.
        </s:paragraph>
        <s:paragraph>
          A <s:term s:type="term">type_declaration</s:term> <s:term s:type="variable">d</s:term>
          is (mutually) <s:term s:type="term">recursive</s:term> iff:
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Recursion conditions</s:formal-item-title>
          <s:list-unordered>
            <s:list-item>
              <s:term s:type="variable">d</s:term> refers statically to itself.
            </s:list-item>
            <s:list-item>
              There is a sequence of types <s:term s:type="expression">t‚ÇÄ, t‚ÇÅ, ..., t‚Çô</s:term>
              such that <s:term s:type="variable">d</s:term> refers statically to
              <s:term s:type="variable">t‚ÇÄ</s:term>, and
              for all <s:term s:type="variable">m</s:term> where <s:term s:type="expression">0 &lt;= m &lt; n</s:term>,
              <s:term s:type="variable">t‚Çò</s:term> refers statically
              <s:term s:type="expression">t‚Çç‚Çò‚Çä‚ÇÅ‚Çé</s:term>, and
              <s:term s:type="variable">t‚Çô</s:term> refers statically to
              <s:term s:type="variable">d</s:term>.
            </s:list-item>
          </s:list-unordered>
        </s:formal-item>
      </s:subsection>

      <s:subsection xml:id="spec.declarations.types.records">
        <s:subsection-title>Records</s:subsection-title>
        <s:paragraph>
          A <s:term s:type="term">type_declaration</s:term> binds a
          <s:term s:type="term">record_type_expression</s:term> to a name.
          A <s:term s:type="term">record_type_expression</s:term> declares
          a set of named <s:term s:type="term">fields</s:term> and types.
        </s:paragraph>
        <s:paragraph>
          A <s:term s:type="term">record_type_expression</s:term> cannot
          contain two <s:term s:type="term">fields</s:term> with the
          same name, but two distinct
          <s:term s:type="term">record_type_expressions</s:term> can have
          <s:term s:type="term">fields</s:term> with the same names. To
          clarify, these are valid <s:term s:type="term">type_declarations</s:term>:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Valid type declarations</s:formal-item-title>
          <s:verbatim><![CDATA[type t is record
  x : integer,
  y : integer
end;

type u is record
  x : integer,
  y : integer
end;]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          However, this is not:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Invalid type declarations (duplicate field)</s:formal-item-title>
          <s:verbatim><![CDATA[type t is record
  x : integer,
  x : integer
end;]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          As described in the <s:link s:target="spec.types">types</s:link>
          section, types have <s:term s:type="term">by-name equivalence</s:term> and
          therefore two identical <s:term s:type="term">record_type_expressions</s:term>
          bound to different names are not type-compatible.
        </s:paragraph>
      </s:subsection>

      <s:subsection xml:id="spec.declarations.types.type_rules">
        <s:subsection-title>Type rules</s:subsection-title>
        <s:paragraph>
          A <s:term s:type="term">type_declaration</s:term> introduces a new record
          type into the typing environment. See the rules for
          <s:link s:target="spec.types.records">record types</s:link>
          for the effects that this has on typing rules.
        </s:paragraph>
      </s:subsection>

      <s:subsection xml:id="spec.declarations.types.syntax">
        <s:subsection-title>Syntax</s:subsection-title>
        <s:paragraph>
          The precise syntax of type declarations is given by the following
          EBNF:
        </s:paragraph>
      <s:formal-item s:kind="specifications" s:type="specifications">
        <s:formal-item-title>Type declaration syntax</s:formal-item-title>
        <s:verbatim><![CDATA[record_type_field =
  name_lower , ":" , type_path ;

record_type_expression =
  "record" , record_type_field , { "," , record_type_field } , "end" ;

type_declaration =
  "type" , name_lower , "is" , type_expression ;

type_expression =
  record_type_expression
  ;
        ]]></s:verbatim>
        </s:formal-item>
      </s:subsection>

      <s:subsection xml:id="spec.declarations.types.examples">
        <s:subsection-title>Examples</s:subsection-title>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Examples</s:formal-item-title>
          <s:verbatim><![CDATA[
type t is record
  x : integer,
  y : integer,
  z : integer
end;

type u is record
  v0 : t,
  v1 : t,
  v2 : t
end;]]></s:verbatim>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="spec.declarations.shaders">
      <s:section-title>Shaders</s:section-title>

      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          <s:term s:type="term">Shaders</s:term> represent programs
          that will execute on the targeted graphics hardware. They
          are divided into
          <s:link s:target="spec.declarations.shaders.vertex">vertex shaders</s:link>,
          <s:link s:target="spec.declarations.shaders.fragment">fragment shaders</s:link>,
          and
          <s:link s:target="spec.declarations.shaders.program">programs</s:link>,
          (which essentially aggregate other shaders into usable programs).
        </s:paragraph>
      </s:subsection>

      <s:subsection xml:id="spec.declarations.shaders.declarations">
        <s:subsection-title>Declarations</s:subsection-title>
        <s:paragraph>
          A <s:term s:type="term">shader_declaration</s:term> may either be a
          <s:link s:target="spec.declarations.shaders.vertex">shader_vertex_declaration</s:link>,
          a
          <s:link s:target="spec.declarations.shaders.fragment">shader_fragment_declaration</s:link>,
          or a
          <s:link s:target="spec.declarations.shaders.program">shader_program_declaration</s:link>.
        </s:paragraph>
      </s:subsection>

      <s:subsection xml:id="spec.declarations.shaders.names">
        <s:subsection-title>Names</s:subsection-title>
        <s:paragraph>
          The names selected for shaders must be unique with respect to
          other shaders within the <s:link s:target="spec.declarations.modules">module</s:link>
          in which they are defined. That is, there cannot be two shaders with the same name
          in the same module. Shaders do not share a name space with
          <s:link s:target="spec.declarations.terms">terms</s:link>
          or <s:link s:target="spec.declarations.types">types</s:link>.
        </s:paragraph>
        <s:paragraph>
          The following restrictions apply when naming shaders:
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Name restrictions</s:formal-item-title>
          <s:list-unordered>
            <s:list-item>
              Shader names must begin with a <s:term s:type="term">lowercase</s:term>
              letter. This is directly implied by the
              <s:link s:target="spec.declarations.shaders.syntax">grammar</s:link>.
            </s:list-item>
            <s:list-item>
              Names cannot contain two adjacent underscores (<s:term s:type="constant">U+005F</s:term>).
            </s:list-item>
            <s:list-item>
              Names cannot end with underscores (<s:term s:type="constant">U+005F</s:term>).
            </s:list-item>
            <s:list-item>
              Names cannot start with the character sequence "<s:term s:type="constant">gl_</s:term>"
              (<s:term s:type="constant">U+0067</s:term>,
               <s:term s:type="constant">U+006C</s:term>,
               <s:term s:type="constant">U+005F</s:term>).
            </s:list-item>
            <s:list-item>
              Names cannot match any of the keywords or reserved words defined in
              any version of the OpenGL shading language. See the
              <s:link s:target="spec.glsl-identifiers">GLSL identifiers</s:link>
              section for the complete list.
            </s:list-item>
          </s:list-unordered>
        </s:formal-item>
      </s:subsection>

      <s:subsection xml:id="spec.declarations.shaders.io">
        <s:subsection-title>Inputs/Outputs/Parameters</s:subsection-title>
        <s:paragraph>
          Shaders consume data from <s:term s:type="term">inputs</s:term>
          and <s:term s:type="term">parameters</s:term>, and produce data
          on <s:term s:type="term">outputs</s:term>.
        </s:paragraph>
        <s:paragraph>
          <s:term s:type="term">Inputs</s:term> are data sources that produce
          values that may change every time the shader is executed (once
          per vertex for <s:term s:type="term">vertex shaders</s:term> and
          once per fragment for
          <s:term s:type="term">fragment shaders</s:term>).
        </s:paragraph>
        <s:paragraph>
          <s:term s:type="term">Parameters</s:term> are data sources that
          produce values that may be constant over the entire lifetime
          of the program.
        </s:paragraph>
        <s:paragraph>
          <s:term s:type="term">Outputs</s:term> are data sinks that, when
          assigned values, pass those values to the next stage of the
          rendering pipeline. Typically,
          <s:term s:type="term">vertex shaders</s:term> linearly interpolate
          values written to <s:term s:type="term">outputs</s:term> and pass
          them on to the <s:term s:type="term">fragment shader</s:term>,
          and <s:term s:type="term">fragment shaders</s:term> send values
          written to <s:term s:type="term">outputs</s:term> to the
          <s:term s:type="term">framebuffer</s:term> for display.
        </s:paragraph>
        <s:paragraph>
          The following restrictions apply when naming
          <s:term s:type="term">inputs</s:term>, <s:term s:type="term">outputs</s:term>,
          and <s:term s:type="term">parameters</s:term>:
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Name restrictions</s:formal-item-title>
          <s:list-unordered>
            <s:list-item>
              Names must begin with a <s:term s:type="term">lowercase</s:term>
              letter. This is directly implied by the
              <s:link s:target="spec.declarations.shaders.syntax">grammar</s:link>.
            </s:list-item>
            <s:list-item>
              Names cannot contain two adjacent underscores (<s:term s:type="constant">U+005F</s:term>).
            </s:list-item>
            <s:list-item>
              Names cannot end with underscores (<s:term s:type="constant">U+005F</s:term>).
            </s:list-item>
            <s:list-item>
              Names cannot start with the character sequence "<s:term s:type="constant">gl_</s:term>"
              (<s:term s:type="constant">U+0067</s:term>,
               <s:term s:type="constant">U+006C</s:term>,
               <s:term s:type="constant">U+005F</s:term>).
            </s:list-item>
            <s:list-item>
              Names cannot match any of the keywords or reserved words defined in
              any version of the OpenGL shading language. See the
              <s:link s:target="spec.glsl-identifiers">GLSL identifiers</s:link>
              section for the complete list.
            </s:list-item>
          </s:list-unordered>
        </s:formal-item>
      </s:subsection>

      <s:subsection xml:id="spec.declarations.shaders.type_rules">
        <s:subsection-title>Type rules</s:subsection-title>
        <s:paragraph>
          Only a subset of the available types are permitted
          for <s:term s:type="term">inputs</s:term>, and
          <s:term s:type="term">outputs</s:term>:
        </s:paragraph>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>Input/Output types</s:formal-item-title>
          <s:list-unordered>
            <s:list-item><s:link s:target="spec.types.integer">integer</s:link></s:list-item>
            <s:list-item><s:link s:target="spec.types.float">float</s:link></s:list-item>
            <s:list-item><s:link s:target="spec.types.vector">vector_NT</s:link></s:list-item>
          </s:list-unordered>
        </s:formal-item>
        <s:paragraph>
          <s:term s:type="term">Parameters</s:term> may be of any type
          <s:footnote>
            Notably, <s:term s:type="term">parameters</s:term> are the
            <s:term s:type="emphasis">only</s:term> means by which values
            of the <s:link s:target="spec.types.samplers">sampler</s:link>
            types can be introduced into a program.
          </s:footnote>.
        </s:paragraph>
      </s:subsection>

      <s:subsection xml:id="spec.declarations.shaders.syntax">
        <s:subsection-title>Syntax</s:subsection-title>
        <s:paragraph>
          The precise syntax of shader declarations is given by the following
          EBNF:
        </s:paragraph>
      <s:formal-item s:kind="specifications" s:type="specifications">
        <s:formal-item-title>Shader declaration syntax</s:formal-item-title>
        <s:verbatim><![CDATA[shader_parameter_declaration =
  "parameter" , name_lower , ":" , type_path ;

shader_vertex_input_declaration =
  "in" , name_lower , ":" , type_path ;

shader_vertex_output_declaration =
  "out" , name_lower , ":" , type_path ;

shader_vertex_output_declaration =
  "out" , "vertex" , name_lower , ":" , type_path ;

shader_vertex_parameter =
    shader_parameter_declaration
  | shader_vertex_input_declaration
  | shader_vertex_output_declaration
  | shader_vertex_output_main_declaration ;

shader_vertex_parameters =
  { shader_vertex_parameter , ";" } ;

shader_vertex_output_assignment =
  "out" , name_lower , "=" , term_path ;

shader_vertex_output_assignments =
  shader_vertex_output_assignment , ";" , { shader_vertex_output_assignments } ;

shader_vertex_declaration =
  "vertex" , name_lower , "is" ,
  shader_vertex_parameters ,
  [ "with" , local_declarations ] ,
  "as" ,
  shader_vertex_output_assignments ,
  "end" ;

shader_fragment_input_declaration =
  "in" , name_lower , ":" , type_path ;

shader_fragment_output_declaration =
  "out" , name_lower , ":" , type_path , "as" , integer_literal ;

shader_fragment_parameter =
    shader_parameter_declaration
  | shader_fragment_input_declaration
  | shader_fragment_output_declaration ;

shader_fragment_parameters =
  { shader_fragment_parameter , ";" } ;

shader_fragment_discard_declaration =
  "discard" , "(" , expression , ")" ;

shader_fragment_local_declaration =
    local_declaration
  | shader_fragment_discard_declaration ;

shader_fragment_local_declarations =
  shader_fragment_local_declaration , ";" , { shader_fragment_local_declarations } ;

shader_fragment_output_assignment =
  "out" , name_lower , "=" , term_path ;

shader_fragment_output_assignments =
  shader_fragment_output_assignment , ";" , { shader_fragment_output_assignments } ;

shader_fragment_declaration =
  "fragment" , name_lower , "is" ,
  shader_fragment_parameters ,
  [ "with" , shader_fragment_local_declarations ] ,
  "as" ,
  shader_fragment_output_assignments ,
  "end" ;

shader_program_declaration =
  "program" , name_lower , "is" ,
  "vertex" , shader_path , ";" ,
  "fragment" , shader_path , ";" ,
  "end" ;

shader_declaration =
  "shader" , ( shader_vertex_declaration | shader_fragment_declaration | shader_program_declaration ) ;

shader_declarations =
  { shader_declaration , ";" } ;]]></s:verbatim>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="spec.declarations.shaders.vertex">
      <s:section-title>Vertex shaders</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          <s:term s:type="term">Vertex shaders</s:term> are programs that
          process data on a per-vertex basis in OpenGL.
        </s:paragraph>
      </s:subsection>

      <s:subsection xml:id="spec.declarations.shaders.vertex.declarations">
        <s:subsection-title>Declarations</s:subsection-title>
        <s:paragraph>
          A <s:term s:type="term">shader_vertex_declaration</s:term> declares a set
          of <s:link s:target="spec.declarations.shaders.io">inputs,
          outputs, and parameters</s:link>, as well as a sequence of zero or more
          <s:term s:type="term">local_value_declarations</s:term>, similar
          in semantics and typing to that found in a
          <s:link s:target="spec.expressions.let">let expression</s:link>,
          and a sequence of assignments of values to the declared
          <s:term s:type="term">outputs</s:term>. A vertex shader must also define exactly
          one output of type <s:link s:target="spec.types.vector">vector_4f</s:link>,
          indicated with the <s:term s:type="keyword">vertex</s:term> keyword,
          to which must be assigned a value representing the current homogeneous vertex
          position.
        </s:paragraph>
        <s:paragraph>
          It is required that there be exactly one
          <s:term s:type="term">shader_vertex_output_assignment</s:term> for each
          <s:term s:type="term">shader_vertex_output_declaration</s:term>.
        </s:paragraph>
      </s:subsection>

      <s:subsection xml:id="spec.declarations.shaders.vertex.type_rules">
        <s:subsection-title>Type rules</s:subsection-title>
        <s:paragraph>
          Each
          <s:term s:type="term">shader_parameter_declaration</s:term> and
          <s:term s:type="term">shader_vertex_input_declaration</s:term> introduces
          a new term of the given type into the environment, accessible only
          within the scope of the shader definition,
          as shown by the <s:term s:type="constant">shader_vertex_inputs_parameters</s:term> rule:
        </s:paragraph>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>Vertex shader inputs/parameters (shader_vertex_inputs_parameters)</s:formal-item-title>
          <s:image s:source="png/ty_shader_vertex_inputs_parameters.png">Vertex shader inputs/parameters (shader_vertex_inputs_parameters)</s:image>
        </s:formal-item>
        <s:paragraph>
          Each <s:term s:type="term">local_value_declaration</s:term> introduces
          a new term of the given type into the environment, accessible in each
          successive <s:term s:type="term">local_value_declaration</s:term> and
          in the <s:term s:type="term">shader_vertex_output_assignments</s:term>,
          as shown by the
          <s:term s:type="constant">shader_vertex_values</s:term> rule:
        </s:paragraph>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>Vertex shader values (shader_vertex_values)</s:formal-item-title>
          <s:image s:source="png/ty_shader_vertex_values.png">Vertex shader values (shader_vertex_values)</s:image>
        </s:formal-item>
        <s:paragraph>
          Finally, each output assigned in a <s:term s:type="term">shader_vertex_output_assignment</s:term>
          must be of the correct type, as shown by the
          <s:term s:type="constant">shader_vertex_output_assignment</s:term> rule:
        </s:paragraph>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>Vertex shader output assignments (shader_vertex_output)</s:formal-item-title>
          <s:image s:source="png/ty_shader_vertex_output.png">Vertex shader output assignments (shader_vertex_output)</s:image>
        </s:formal-item>
      </s:subsection>

      <s:subsection xml:id="spec.declarations.shaders.vertex.semantics">
        <s:subsection-title>Operational Semantics</s:subsection-title>
        <s:paragraph>
          The <s:term s:type="term">local_value_declarations</s:term> are evaluated from
          top-to-bottom, in an identical manner to
          <s:link s:target="spec.expressions.let">let expressions</s:link>,
          as shown by the
          <s:term s:type="variable">shader_vertex_values</s:term> rule:
        </s:paragraph>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>Vertex shader local declarations (shader_vertex_values)</s:formal-item-title>
          <s:image s:source="png/op_shader_vertex_values.png">Vertex shader local declarations (shader_vertex_values)</s:image>
        </s:formal-item>
      </s:subsection>

      <s:subsection xml:id="spec.declarations.shaders.vertex.examples">
        <s:subsection-title>Examples</s:subsection-title>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Examples</s:formal-item-title>
          <s:verbatim><![CDATA[
shader vertex v is
  parameter mm_modelview  : matrix_4x4f;
  parameter mm_projection : matrix_4x4f;
  parameter mm_normal     : matrix_3x3f;
  in position             : vector_4f;
  in normal               : vector_3f;
  out vertex r_position   : vector_4f;
  out r_normal            : vector_3f;
with
  value p_result = M4.multiply_vector (M4.multiply (mm_projection, mm_modelview), position);
  value n_result = M3.multiply_vector (mm_normal, normal);
as
  out r_position = p_result;
  out r_normal   = n_result;
end;]]></s:verbatim>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="spec.declarations.shaders.fragment">
      <s:section-title>Fragment shaders</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          <s:term s:type="term">Fragment shaders</s:term> are programs that
          process data on a per-fragment basis in OpenGL.
        </s:paragraph>
      </s:subsection>
      <s:subsection xml:id="spec.declarations.shaders.fragment.declarations">
        <s:subsection-title>Declarations</s:subsection-title>
        <s:paragraph>
          A <s:term s:type="term">shader_fragment_declaration</s:term> declares a set
          of <s:link s:target="spec.declarations.shaders.io">inputs,
          outputs, and parameters</s:link>, as well as a sequence of zero or more
          <s:term s:type="term">shader_fragment_local_declaration</s:term>, and a sequence
          of assignments of values to the declared
          <s:term s:type="term">outputs</s:term>.
        </s:paragraph>
        <s:paragraph>
          A fragment shader may optionally define at most
          one output of type <s:link s:target="spec.types.float">float</s:link>,
          indicated with the <s:term s:type="keyword">depth</s:term> keyword,
          to which must be assigned a value representing the current desired fragment depth (overriding
          the depth value typically calculated by the graphics system's rasterizer).
        </s:paragraph>
        <s:paragraph>
          A <s:term s:type="term">shader_fragment_local_declaration</s:term> is
          either a <s:term s:type="term">local_value_declaration</s:term>, similar
          in semantics and typing to that found in a
          <s:link s:target="spec.expressions.let">let expression</s:link>,
          or a
          <s:link s:target="spec.declarations.shaders.fragment.discard">shader_fragment_discard_declaration</s:link>.
        </s:paragraph>
      </s:subsection>
      <s:subsection xml:id="spec.declarations.shaders.fragment.discard">
        <s:subsection-title>Discard</s:subsection-title>
        <s:paragraph>
          A <s:term s:type="term">shader_fragment_discard_declaration</s:term> statement
          halts evaluation of the current fragment shader iff the given
          <s:term s:type="term">expression</s:term> evaluates to
          <s:term s:type="constant">true</s:term>.
        </s:paragraph>
      </s:subsection>
      <s:subsection xml:id="spec.declarations.shaders.fragment.type_rules">
        <s:subsection-title>Type rules</s:subsection-title>
        <s:paragraph>
          Each
          <s:term s:type="term">shader_parameter_declaration</s:term> and
          <s:term s:type="term">shader_fragment_input_declaration</s:term> introduces
          a new term of the given type into the environment, accessible only
          within the scope of the shader definition,
          as shown by the <s:term s:type="constant">shader_fragment_inputs_parameters</s:term> rule:
        </s:paragraph>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>Fragment shader inputs/parameters (shader_fragment_inputs_parameters)</s:formal-item-title>
          <s:image s:source="png/ty_shader_fragment_inputs_parameters.png">Vertex shader inputs/parameters (shader_fragment_inputs_parameters)</s:image>
        </s:formal-item>
        <s:paragraph>
          Each <s:term s:type="term">local_value_declaration</s:term> introduces
          a new term of the given type into the environment, accessible in each
          successive <s:term s:type="term">local_value_declaration</s:term> and
          in the <s:term s:type="term">shader_fragment_output_assignments</s:term>,
          as shown by the
          <s:term s:type="constant">shader_fragment_values</s:term> rule:
        </s:paragraph>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>Fragment shader values (shader_fragment_values)</s:formal-item-title>
          <s:image s:source="png/ty_shader_fragment_values.png">Vertex shader values (shader_fragment_values)</s:image>
        </s:formal-item>
        <s:paragraph>
          Each output assigned in a <s:term s:type="term">shader_fragment_output_assignment</s:term>
          must be of the correct type, as shown by the
          <s:term s:type="constant">shader_fragment_output_assignment</s:term> rule:
        </s:paragraph>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>Fragment shader output assignments (shader_fragment_output)</s:formal-item-title>
          <s:image s:source="png/ty_shader_fragment_output.png">Vertex shader output assignments (shader_fragment_output)</s:image>
        </s:formal-item>
        <s:paragraph>
          Finally, the expression passed to a <s:term s:type="term">shader_fragment_discard_declaration</s:term>
          must be of a <s:link s:target="spec.types.boolean">boolean</s:link> type
          as shown by the <s:term s:type="constant">shader_fragment_discard</s:term> rule <s:footnote>
            The <s:term s:type="term">shader_fragment_discard_declaration</s:term> is described
            as having type <s:link s:target="spec.types.boolean">boolean</s:link>, but
            the result of the expression is effectively consumed by the
            <s:term s:type="package">parasol</s:term> language runtime and so this is
            not observable in practice.
          </s:footnote>:
        </s:paragraph>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>Fragment shader discard (shader_fragment_discard)</s:formal-item-title>
          <s:image s:source="png/ty_shader_fragment_discard.png">Fragment shader discard (shader_fragment_discard)</s:image>
        </s:formal-item>
      </s:subsection>

      <s:subsection xml:id="spec.declarations.shaders.fragment.semantics">
        <s:subsection-title>Operational Semantics</s:subsection-title>
        <s:paragraph>
          The <s:term s:type="term">shader_fragment_local_declaration</s:term> are evaluated from
          top-to-bottom, in an identical manner to
          <s:link s:target="spec.expressions.let">let expressions</s:link>,
          as shown by the
          <s:term s:type="variable">shader_fragment_values</s:term> rule:
        </s:paragraph>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>Fragment shader local declarations (shader_fragment_values)</s:formal-item-title>
          <s:image s:source="png/op_shader_fragment_values.png">Fragment shader local declarations (shader_fragment_values)</s:image>
        </s:formal-item>
        <s:paragraph>
          Evaluation halts immediately upon evaluating any
          <s:term s:type="term">shader_fragment_discard_declaration</s:term> where
          the condition evaluates to <s:term s:type="constant">true</s:term>.
        </s:paragraph>
      </s:subsection>

      <s:subsection xml:id="spec.declarations.shaders.fragment.examples">
        <s:subsection-title>Examples</s:subsection-title>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Examples</s:formal-item-title>
          <s:verbatim><![CDATA[
shader fragment f is
  parameter texture_0 : sampler_2d;
  in uv               : vector_2f;
  out out0            : vector_4f as 0;
with
  value rgba = T.texture (texture_0, uv);
as
  out out0 = rgba;
end;]]></s:verbatim>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="spec.declarations.shaders.program">
      <s:section-title>Programs</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          <s:term s:type="term">Programs</s:term> aggregate
          <s:link s:target="spec.declarations.shaders.vertex">vertex</s:link> and
          <s:link s:target="spec.declarations.shaders.fragment">fragment</s:link>
          shaders into single entities that are executed on the
          targeted graphics hardware.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Declarations</s:subsection-title>
        <s:paragraph>
          A <s:term s:type="term">shader_program_declaration</s:term> declares a dependency
          on a <s:link s:target="spec.declarations.shaders.vertex">vertex shader</s:link>
          and a <s:link s:target="spec.declarations.shaders.fragment">fragment shader</s:link>.
        </s:paragraph>
      </s:subsection>
      <s:subsection xml:id="spec.declarations.shaders.program.type_rules">
        <s:subsection-title>Compatibility</s:subsection-title>
        <s:paragraph>
          In order for a given <s:term s:type="term">vertex shader</s:term> and
          <s:term s:type="term">fragment shader</s:term> to be used in a
          <s:term s:type="term">program</s:term>, the set of
          <s:term s:type="term">inputs</s:term> <s:term s:type="expression">I</s:term> of the
          fragment shader must be <s:term s:type="term">compatible</s:term> with the set of
          <s:term s:type="term">outputs</s:term>
          <s:term s:type="expression">O</s:term> of
          the vertex shader. Specifically, for each
          <s:term s:type="expression">0 &lt;= s &lt;= |I| - 1</s:term>, there must be some
          <s:term s:type="expression">0 &lt;= t &lt;= |O| - 1</s:term> such that
          the <s:term s:type="term">name</s:term> and
          <s:term s:type="term">type</s:term> of
          <s:term s:type="expression">I‚Çõ</s:term> matches that of
          <s:term s:type="expression">O‚Çú</s:term>:
        </s:paragraph>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>Input/output compatibility</s:formal-item-title>
          <s:verbatim><![CDATA[‚àÄs. 0 <= s <= |I| - 1 ‚áí
  ‚àÉt. (0 <= t <= |O| - 1 ‚ãÄ ((name(I‚Çõ) = name(O‚Çú) ‚ãÄ  type(I‚Çõ) = type(O‚Çú)))]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          The set of <s:term s:type="term">parameters</s:term>
          <s:term s:type="expression">P</s:term> of the given
          given vertex shader, and the set of
          <s:term s:type="term">parameters</s:term>
          <s:term s:type="expression">Q</s:term> of the given
          fragment shader must be type-compatible if they
          share any of the same names. That is, for each
          <s:term s:type="expression">0 &lt;= s &lt;= |P| - 1</s:term>,
          if there is some
          <s:term s:type="expression">0 &lt;= t &lt;= |Q| - 1</s:term> such that
          the name of <s:term s:type="expression">P‚Çõ</s:term> equals
          that of <s:term s:type="expression">Q‚Çú</s:term>, then the
          type of <s:term s:type="expression">P‚Çõ</s:term> must equal
          that of <s:term s:type="expression">Q‚Çú</s:term>.
        </s:paragraph>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>Input/output compatibility</s:formal-item-title>
          <s:verbatim><![CDATA[‚àÄs. 0 <= s <= |P| - 1 ‚áí
  ‚àÉt. (0 <= t <= |Q| - 1 ‚ãÄ name(I‚Çõ) = name(O‚Çú)) ‚áí
    type(I‚Çõ) = type(O‚Çú)]]></s:verbatim>
        </s:formal-item>
      </s:subsection>
      <s:subsection xml:id="spec.declarations.shaders.program.examples">
        <s:subsection-title>Examples</s:subsection-title>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Examples</s:formal-item-title>
          <s:verbatim><![CDATA[
shader program p is
  vertex p;
  fragment f;
end;]]></s:verbatim>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="spec.declarations.modules">
      <s:section-title>Modules</s:section-title>

      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          A <s:term s:type="term">module</s:term> is a organizational unit
          containing
          <s:link s:target="spec.declarations.terms">terms</s:link>,
          <s:link s:target="spec.declarations.types">types</s:link>, and
          <s:link s:target="spec.declarations.shaders">shaders</s:link>.
          Modules exist solely to partition the namespace into separate sections
          to allow for ease of code re-use across projects.
        </s:paragraph>
      </s:subsection>

      <s:subsection>
        <s:subsection-title>Declarations</s:subsection-title>
        <s:paragraph>
          A <s:term s:type="term">module_declaration</s:term> declares
          a new <s:term s:type="term">module</s:term>.
        </s:paragraph>
      </s:subsection>

      <s:subsection xml:id="spec.declarations.modules.names">
        <s:subsection-title>Names</s:subsection-title>
        <s:paragraph>
          The names selected for modules must be unique with respect to
          other modules within the <s:link s:target="spec.declarations.packages">package</s:link>
          in which they are defined. That is, there cannot be two modules with the same name
          in the same package.
        </s:paragraph>
        <s:paragraph>
          The following restrictions apply when naming modules:
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Name restrictions</s:formal-item-title>
          <s:list-unordered>
            <s:list-item>
              Module names must begin with an <s:term s:type="term">uppercase</s:term>
              letter. This is directly implied by the
              <s:link s:target="spec.declarations.modules.syntax">grammar</s:link>.
            </s:list-item>
            <s:list-item>
              Names cannot contain two adjacent underscores (<s:term s:type="constant">U+005F</s:term>).
            </s:list-item>
            <s:list-item>
              Names cannot end with underscores (<s:term s:type="constant">U+005F</s:term>).
            </s:list-item>
            <s:list-item>
              Names cannot start with the character sequence "<s:term s:type="constant">GL_</s:term>"
              (<s:term s:type="constant">U+0047</s:term>,
               <s:term s:type="constant">U+004C</s:term>,
               <s:term s:type="constant">U+005F</s:term>).
            </s:list-item>
            <s:list-item>
              Names cannot match any of the keywords or reserved words defined in
              any version of the OpenGL shading language. See the
              <s:link s:target="spec.glsl-identifiers">GLSL identifiers</s:link>
              section for the complete list.
            </s:list-item>
          </s:list-unordered>
        </s:formal-item>
      </s:subsection>

      <s:subsection xml:id="spec.declarations.modules.imports">
        <s:subsection-title>Imports</s:subsection-title>
        <s:paragraph>
          A <s:term s:type="term">module</s:term> may <s:term s:type="term">import</s:term>
          any number of modules via <s:term s:type="term">import_declarations</s:term>. An
          <s:term s:type="term">import_declaration</s:term>, given in module
          <s:term s:type="variable">X</s:term>,
          specifies a name of a module <s:term s:type="variable">Y</s:term>
          prefixed with the name of the
          <s:link s:target="spec.declarations.packages">package</s:link>
          in which the module <s:term s:type="variable">Y</s:term> was defined. The
          <s:term s:type="term">terms</s:term>, <s:term s:type="term">types</s:term>, and
          <s:term s:type="term">shaders</s:term> of <s:term s:type="variable">Y</s:term>
          are then accessible in
          <s:term s:type="variable">X</s:term> by qualifying
          their names with <s:term s:type="variable">Y</s:term>. As an example:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Module import example</s:formal-item-title>
          <s:verbatim><![CDATA[package com.example;

module Y is
  value k = 23;
end;

module X is
  import com.example.Y;
  value z = Y.k;
end;]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          The value of <s:term s:type="expression">X.z</s:term> is
          <s:term s:type="expression">23</s:term>.
        </s:paragraph>
        <s:paragraph>
          Because two modules defined in different packages can have the
          same names, it is possible for imports to <s:term s:type="term">collide</s:term>:
          If a <s:term s:type="variable">X</s:term> imports both
          modules <s:term s:type="expression">com.example_0.Y</s:term> and
          <s:term s:type="expression">com.example_1.Y</s:term>, then
          the name <s:term s:type="expression">Y</s:term> will be introduced twice.
          An <s:term s:type="term">import_declaration</s:term> may therefore provide
          an optional name to disambiguate imported modules:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Module import renaming</s:formal-item-title>
          <s:verbatim><![CDATA[package com.example;

module X is
  import com.example_0.Y;
  import com.example_1.Y as Z;

  value z = Y.k;
  value q = Z.p;
end;]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          If a module <s:term s:type="variable">X</s:term>
          imports a module
          <s:term s:type="variable">Y</s:term> as <s:term s:type="variable">Z</s:term>,
          the
          <s:term s:type="term">terms</s:term>, <s:term s:type="term">types</s:term>, and
          <s:term s:type="term">shaders</s:term> of <s:term s:type="variable">Y</s:term>
          are then accessible in
          <s:term s:type="variable">X</s:term> by qualifying
          their names with <s:term s:type="variable">Z</s:term>.
        </s:paragraph>
        <s:paragraph>
          The imported names of modules are <s:term s:type="emphasis">not</s:term>
          visible outside of the module in which they are imported. For example, if
          a module <s:term s:type="variable">X</s:term> imports a module
          <s:term s:type="variable">Y</s:term>, and <s:term s:type="variable">Y</s:term>
          imports a module <s:term s:type="variable">Z</s:term>, the module
          <s:term s:type="variable">Z</s:term> is
          <s:term s:type="emphasis">not</s:term>
          visible as
          <s:term s:type="variable">Y.Z</s:term>.
        </s:paragraph>
      </s:subsection>

      <s:subsection xml:id="spec.declarations.modules.recursion">
        <s:subsection-title>Recursion</s:subsection-title>
        <s:paragraph>
          No <s:term s:type="term">module_declaration</s:term> can be <s:term s:type="term">recursive</s:term>
          with respect to itself or any other <s:term s:type="term">module_declaration</s:term>.
        </s:paragraph>
        <s:paragraph>
          A <s:term s:type="term">module_declaration</s:term> <s:term s:type="variable">d</s:term>
          is (mutually) <s:term s:type="term">recursive</s:term> iff:
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Recursion conditions</s:formal-item-title>
          <s:list-unordered>
            <s:list-item>
              <s:term s:type="variable">d</s:term> imports itself.
            </s:list-item>
            <s:list-item>
              There is a sequence of modules <s:term s:type="expression">d‚ÇÄ, d‚ÇÅ, ..., d‚Çô</s:term>
              such that <s:term s:type="variable">d</s:term> imports
              <s:term s:type="variable">d‚ÇÄ</s:term>, and
              for all <s:term s:type="variable">m</s:term> where <s:term s:type="expression">0 &lt;= m &lt; n</s:term>,
              <s:term s:type="variable">d‚Çò</s:term> imports
              <s:term s:type="expression">d‚Çç‚Çò‚Çä‚ÇÅ‚Çé</s:term>, and
              <s:term s:type="variable">d‚Çô</s:term> imports
              <s:term s:type="variable">d</s:term>.
            </s:list-item>
          </s:list-unordered>
        </s:formal-item>
      </s:subsection>

      <s:subsection xml:id="spec.declarations.modules.syntax">
        <s:subsection-title>Syntax</s:subsection-title>
        <s:paragraph>
          The precise syntax of module declarations is given by the following
          EBNF:
        </s:paragraph>
      <s:formal-item s:kind="specifications" s:type="specifications">
        <s:formal-item-title>Module declaration syntax</s:formal-item-title>
        <s:verbatim><![CDATA[package_path =
  name_lower , { "." , name_lower } ;

import_path =
  package_path , "." , name_upper ;

import_declaration =
  "import" , import_path , [ "as" , name_upper ] ;

import_declarations =
  { import_declaration , ";" } ;

module_level_declarations =
  { value_declarations | function_declarations | type_declarations | shader_declarations } ;

module_declaration =
  "module" , name_upper , "is" ,
  import_declarations ,
  module_level_declarations ,
  "end" ;

module_declarations =
  module_declaration , ";" , { module_declaration , ";" } ;]]></s:verbatim>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="spec.declarations.packages">
      <s:section-title>Packages</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          <s:term s:type="term">Packages</s:term> are to
          <s:link s:target="spec.declarations.modules">modules</s:link>
          as
          <s:link s:target="spec.declarations.modules">modules</s:link>
          are to
          <s:link s:target="spec.declarations.terms">terms</s:link>,
          <s:link s:target="spec.declarations.types">types</s:link>, and
          <s:link s:target="spec.declarations.shaders">shaders</s:link>.
          <s:term s:type="term">Packages</s:term> provide a non-hierarchical partitioned
          namespace that separates <s:term s:type="term">modules</s:term> for ease
          of code re-use across projects.
        </s:paragraph>
      </s:subsection>

      <s:subsection>
        <s:subsection-title>Declarations</s:subsection-title>
        <s:paragraph>
          A <s:term s:type="term">package_declaration</s:term> declares that the
          current <s:link s:target="spec.lex.units">unit</s:link>
          will contain declarations that will be placed in the named package.
        </s:paragraph>
        <s:paragraph>
          Multiple <s:term s:type="term">units</s:term> can contain the same
          <s:term s:type="term">package_declaration</s:term>, however a single
          <s:term s:type="term">unit</s:term> must contain exactly one
          <s:term s:type="term">package_declaration</s:term>.
        </s:paragraph>
      </s:subsection>

      <s:subsection xml:id="spec.declarations.packages.syntax">
        <s:subsection-title>Syntax</s:subsection-title>
        <s:paragraph>
          The precise syntax of package declarations is given by the following
          EBNF:
        </s:paragraph>
      <s:formal-item s:kind="specifications" s:type="specifications">
        <s:formal-item-title>Package declaration syntax</s:formal-item-title>
        <s:verbatim><![CDATA[package_path =
  name_lower , { "." , name_lower } ;

package_declaration =
  "package" , package_path ;]]></s:verbatim>
        </s:formal-item>
      </s:subsection>
    </s:section>
  </s:part>

  <s:part xml:id="spec.expressions">
    <s:part-title>Expressions</s:part-title>
    <s:part-contents/>

    <s:section xml:id="spec.expressions.overview">
      <s:section-title>Description</s:section-title>
      <s:subsection>
        <s:subsection-title>Overview</s:subsection-title>
        <s:paragraph>
          An <s:term s:type="term">expression</s:term> is a computation
          that evaluates to a <s:term s:type="term">value</s:term>
          of a single <s:link s:target="spec.types">type</s:link>
          according to the rules given in the
          operational semantics for each expression form.
          Expressions may be one of the following forms:
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Expression forms</s:formal-item-title>
          <s:list-unordered>
            <s:list-item>An <s:link s:target="spec.expressions.integer_literal">integer literal</s:link>. For example: <s:term s:type="expression">23</s:term></s:list-item>
            <s:list-item>A <s:link s:target="spec.expressions.real_literal">real literal</s:link>. For example: <s:term s:type="expression">23.0</s:term></s:list-item>
            <s:list-item>A <s:link s:target="spec.expressions.boolean_literal">boolean literal</s:link>. For example: <s:term s:type="expression">true</s:term></s:list-item>
            <s:list-item>A <s:link s:target="spec.expressions.variable">variable</s:link>. For example: <s:term s:type="expression">x</s:term></s:list-item>
            <s:list-item>A <s:link s:target="spec.expressions.function_application">function application</s:link>. For example: <s:term s:type="expression">f (x, y)</s:term></s:list-item>
            <s:list-item>A <s:link s:target="spec.expressions.conditional">conditional</s:link>. For example: <s:term s:type="expression">if x then y else z end</s:term></s:list-item>
            <s:list-item>A <s:link s:target="spec.expressions.let">let</s:link> block. For example: <s:term s:type="expression">let value x = 23; value y = 23; in f (x, y) end</s:term></s:list-item>
            <s:list-item>The construction of a <s:link s:target="spec.expressions.new">new</s:link> value. For example: <s:term s:type="expression">new vector_3f (1.0, 2.0, 3.0)</s:term></s:list-item>
            <s:list-item>A <s:link s:target="spec.expressions.record">record</s:link> value. For example: <s:term s:type="expression">record t { x = 23, y = 24 }</s:term></s:list-item>
            <s:list-item>A <s:link s:target="spec.expressions.record_projection">record projection</s:link>. For example: <s:term s:type="expression">e.x</s:term>, for some expression <s:term s:type="variable">e</s:term>.</s:list-item>
            <s:list-item>A vector <s:link s:target="spec.expressions.swizzle">swizzle</s:link>. For example: <s:term s:type="expression">e [x x y z]</s:term>, for some expression <s:term s:type="variable">e</s:term>.</s:list-item>
          </s:list-unordered>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Operational Semantics</s:subsection-title>
        <s:paragraph>
          The operational semantics for each expression form appears
          in the respective sections for each. The following syntactic forms
          are considered to be values:
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Values (values)</s:formal-item-title>
          <s:image s:source="png/op_values.png">Values (values)</s:image>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="spec.expressions.syntax">
      <s:section-title>Syntax</s:section-title>
      <s:paragraph>
        The precise syntax of expressions is given by the following
        EBNF:
      </s:paragraph>
      <s:formal-item s:kind="specifications" s:type="specifications">
        <s:formal-item-title>Expression syntax</s:formal-item-title>
        <s:verbatim><![CDATA[term_path =
    name_lower
  | name_upper , "." , name_lower ;

type_path =
    name_lower
  | name_upper , "." , name_lower ;

variable_or_application_expression =
  term_path [ "(" , expression , { "," , expression } , ")" ]
  ;

new_parameters =
  "(" , expression , { "," , expression } , ")" ;

new_expression =
  "new" , type_path , new_parameters ;

record_expression_fields =
  "{" , name_lower , "=" , expression , { "," name_lower , "=" , expression } , "}" ;

record_expression =
  "record" , type_path , record_expression_fields ;

local_declaration =
  "value" , name_lower , [ ":" , type_path ] , "=" , expression ;

local_declarations =
  local_declaration , ";" , { local_declarations } ;

let_expression =
  "let" , local_declarations , "in" , expression , "end" ;

conditional_expression =
  "if" , expression , "then" , expression , "else" , expression , "end" ;

expression_pre =
    integer_literal
  | real_literal
  | boolean_literal
  | variable_or_application_expression
  | conditional_expression
  | let_expression
  | new_expression
  | record_expression
  ;

expression_projection =
  "." , name_lower ;

expression_swizzle_names =
  "[" , name_lower , { "," , name_lower } , "]" ;

expression =
  expression_pre , { expression_swizzle | expression_projection } ;
]]></s:verbatim>
      </s:formal-item>
    </s:section>

    <s:section xml:id="spec.expressions.integer_literal">
      <s:section-title>Integer literal</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          An <s:term s:type="term">integer_literal</s:term> is a simple
          integer value.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Type rules</s:subsection-title>
        <s:paragraph>
          <s:term s:type="term">integer_literal</s:term> expressions are of type
          <s:link s:target="spec.types.integer">integer</s:link>,
          where <s:term s:type="variable">‚Ñ§</s:term> represents the
          literal:
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Integer literal type rule (integer_constant)</s:formal-item-title>
          <s:image s:source="png/ty_integer_constant.png">Integer literal type rule (integer_constant)</s:image>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Operational semantics</s:subsection-title>
        <s:paragraph>
          <s:term s:type="term">integer_literal</s:term> expressions are <s:term s:type="term">values</s:term>
          by definition, and are equal to the value of the literal.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="spec.expressions.real_literal">
      <s:section-title>Real literal</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          A <s:term s:type="term">real_literal</s:term> is a simple
          real-number value.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Type rules</s:subsection-title>
        <s:paragraph>
          <s:term s:type="term">Real literal</s:term> expressions are of type
          <s:link s:target="spec.types.float">float</s:link>,
          where <s:term s:type="variable">‚Ñù</s:term> represents the
          literal:
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Real literal type rule (float_constant)</s:formal-item-title>
          <s:image s:source="png/ty_float_constant.png">Real literal type rule (float_constant)</s:image>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Operational semantics</s:subsection-title>
        <s:paragraph>
          <s:term s:type="term">real_literal</s:term> expressions are <s:term s:type="term">values</s:term>
          by definition, and are equal to the value of the literal.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="spec.expressions.boolean_literal">
      <s:section-title>Boolean literal</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          A <s:term s:type="term">boolean_literal</s:term> is a simple
          <s:term s:type="keyword">true</s:term> or
          <s:term s:type="keyword">false</s:term> value.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Type rules</s:subsection-title>
        <s:paragraph>
          <s:term s:type="term">boolean_literal</s:term> expressions are of type
          <s:link s:target="spec.types.boolean">boolean</s:link>:
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Boolean true literal type rule (true_constant)</s:formal-item-title>
          <s:image s:source="png/ty_true_constant.png">Boolean true literal type rule (true_constant)</s:image>
        </s:formal-item>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Boolean false literal type rule (false_constant)</s:formal-item-title>
          <s:image s:source="png/ty_false_constant.png">Boolean false literal type rule (false_constant)</s:image>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Operational semantics</s:subsection-title>
        <s:paragraph>
          <s:term s:type="term">Boolean literal</s:term> expressions are <s:term s:type="term">values</s:term>
          by definition, and are equal to the value of the literal.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="spec.expressions.variable">
      <s:section-title>Variable</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          A <s:term s:type="term">variable</s:term> expression is a simple
          reference to a variable in the current environment.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Type rules</s:subsection-title>
        <s:paragraph>
          For <s:term s:type="term">variable</s:term> expressions, if a variable <s:term s:type="variable">x</s:term>
          is of type <s:term s:type="variable">t</s:term> in the current environment, then
          the result of evaluating the variable has type <s:term s:type="variable">t</s:term>:
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Variable type rule (variable)</s:formal-item-title>
          <s:image s:source="png/ty_variable.png">Variable type rule (variable)</s:image>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Operational semantics</s:subsection-title>
        <s:paragraph>
          Variables are replaced with their values during the evaluation of
          <s:link s:target="spec.expressions.function_application">functions</s:link>,
          <s:link s:target="spec.expressions.let">let</s:link> expressions, and
          top-level
          <s:link s:target="spec.declarations.terms.semantics">value</s:link>
          declarations.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="spec.expressions.function_application">
      <s:section-title>Function application</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          A <s:term s:type="term">function_application</s:term> expression applies
          a given function <s:term s:type="variable">f</s:term> to an n-tuple of
          argument expressions.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Type rules</s:subsection-title>
        <s:paragraph>
          For <s:term s:type="term">function_application</s:term> expressions, if a function <s:term s:type="variable">f</s:term>
          takes an n-tuple of values of types <s:term s:type="type">(t‚ÇÄ ‚úï ... ‚úï t‚Çô)</s:term> and
          returns a value of type <s:term s:type="type">u</s:term>, then applying
          <s:term s:type="variable">f</s:term> to an n-tuple of expressions of the
          corresponding types, results in a value of type <s:term s:type="type">u</s:term>:
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Function application type rule (function_application)</s:formal-item-title>
          <s:image s:source="png/ty_function_application.png">Function application type rule (function_application)</s:image>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Operational semantics</s:subsection-title>
        <s:paragraph>
          For a <s:term s:type="term">function_application</s:term> expression
          <s:term s:type="expression">e</s:term>, expressions
          passed to the function are evaluated from left-to-right by rules
          <s:term s:type="constant">function_application_left_0</s:term> and
          <s:term s:type="constant">function_application_left_1</s:term>, and when all of
          the arguments have evaluated to values, the variables in the body of the
          function are substituted with the values of the arguments and the expression
          as a whole is evaluated, by rule
          <s:term s:type="constant">function_application_body</s:term>.
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Function application semantics (function_application)</s:formal-item-title>
          <s:image s:source="png/op_function_application.png">Function application semantics (function_application)</s:image>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="spec.expressions.conditional">
      <s:section-title>Conditional</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          A <s:term s:type="term">conditional</s:term> expression evaluates
          to the expression in either of its defined
          <s:term s:type="term">branches</s:term> based on a given
          <s:term s:type="term">condition</s:term>.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Type rules</s:subsection-title>
        <s:paragraph>
          For <s:term s:type="term">conditional</s:term> expressions, if the condition is of type
          <s:link s:target="spec.types.boolean">boolean</s:link>, and both
          branches are of type <s:term s:type="type">t</s:term>, then evaluating
          the expression results in a value of type <s:term s:type="type">t</s:term>:
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Conditional type rule (conditional)</s:formal-item-title>
          <s:image s:source="png/ty_conditional.png">Conditional type rule (conditional)</s:image>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Operational semantics</s:subsection-title>
        <s:paragraph>
          For a <s:term s:type="term">conditional</s:term> expression
          <s:term s:type="expression">e</s:term>, the
          condition of the expression is evaluated, if it is not already a
          <s:term s:type="term">value</s:term>, by rule
          <s:term s:type="constant">if_condition</s:term>. If the
          condition is <s:term s:type="constant">true</s:term>,
          <s:term s:type="expression">e</s:term>
          evaluates to the expression in the left branch, by rule
          <s:term s:type="constant">if_true</s:term>. If the condition is
          <s:term s:type="constant">false</s:term>,
          <s:term s:type="expression">e</s:term> evaluates
          to the expression in the right branch, by rule
          <s:term s:type="constant">if_false</s:term>.
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Conditional semantics (condition)</s:formal-item-title>
          <s:image s:source="png/op_conditional.png">Conditional semantics (condition)</s:image>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="spec.expressions.let">
      <s:section-title>Let</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          A <s:term s:type="term">let_expression</s:term> consists of a sequence of
          <s:term s:type="term">local_value_declarations</s:term> and a body consisting
          of a single <s:term s:type="term">expression</s:term>. The
          <s:term s:type="term">local_value_declarations</s:term> differ from
          top-level <s:link s:target="spec.declarations.terms.values">value_declarations</s:link>
          in that the order of declaration is significant, and it is legal for
          multiple <s:term s:type="term">local_value_declarations</s:term> to have
          the same name, with each new declaration hiding any previous declarations
          (including top level declarations) with the same name.
        </s:paragraph>
        <s:paragraph>
          The same rules apply for <s:term s:type="term">local_value_declarations</s:term> with regards to
          <s:link s:target="spec.declarations.terms.recursion">recursion</s:link> as
          any other term declaration.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Type rules</s:subsection-title>
        <s:paragraph>
          For <s:term s:type="term">let_expressions</s:term>, if each successive
          <s:term s:type="term">local_value_declaration</s:term> is well-typed (with
          respect to the environment and the preceding
          <s:term s:type="term">local_value_declarations</s:term>), and
          the body of the expression (denoted <s:term s:type="variable">y</s:term>)
          is of type <s:term s:type="type">t</s:term>,
          then evaluating the expression results in a value of type
          <s:term s:type="type">t</s:term>:
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Let type rule (let)</s:formal-item-title>
          <s:image s:source="png/ty_let.png">Let type rule (let)</s:image>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Operational semantics</s:subsection-title>
        <s:paragraph>
          For a <s:term s:type="term">let</s:term> expression
          <s:term s:type="expression">e</s:term>, the
          <s:term s:type="term">local_value_declarations</s:term> are evaluated
          from top-to-bottom with each of the previously evaluated
          declarations being substituted into the current declaration
          before evaluation, by rule
          <s:term s:type="constant">let_locals</s:term>. When all
          of the declarations have been evaluated, the values of the
          declarations are subsituted into the body of the
          <s:term s:type="term">let</s:term>
          and <s:term s:type="expression">e</s:term> evaluates to the
          resulting expression, by rule
          <s:term s:type="constant">let_body</s:term>.
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Let semantics (let)</s:formal-item-title>
          <s:image s:source="png/op_let.png">Let semantics (let)</s:image>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="spec.expressions.record_projection">
      <s:section-title>Record Projection</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          A <s:term s:type="term">record_projection</s:term> expression returns
          the value of a field from an expression
          <s:term s:type="expression">r</s:term>, which is expected to be of a
          <s:link s:target="spec.types.records">record</s:link>
          type.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Type rules</s:subsection-title>
        <s:paragraph>
          For <s:term s:type="term">record_projection</s:term> expressions, if an expression
          <s:term s:type="expression">r</s:term> is of type <s:term s:type="type">t</s:term>,
          and <s:term s:type="type">t</s:term> is a record type
          with fields <s:term s:type="variable">ùîΩ‚Çò</s:term>
          to <s:term s:type="variable">ùîΩ‚Çô</s:term>, of types
          <s:term s:type="type">t‚Çò</s:term> to <s:term s:type="type">t‚Çô</s:term>,
          then accessing field <s:term s:type="variable">ùîΩ‚Çñ</s:term> of
          <s:term s:type="expression">r</s:term>, where
          <s:term s:type="expression">k ‚àà [m, n]</s:term>, results in
          a value of type <s:term s:type="type">t‚Çñ</s:term>:
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Record projection type rule (record_projection)</s:formal-item-title>
          <s:image s:source="png/ty_record_projection.png">Record projection type rule (record_projection)</s:image>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Operational semantics</s:subsection-title>
        <s:paragraph>
          For a <s:term s:type="term">record_projection</s:term> expression
          <s:term s:type="expression">e</s:term>,
          the left hand side of the expression is evaluated, by rule
          <s:term s:type="constant">record_projection_pre</s:term>, and then
          <s:term s:type="expression">e</s:term> evaluates to the
          value associated with the label <s:term s:type="expression">k</s:term>
          by rule <s:term s:type="constant">record_projection_value</s:term>.
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Record projection semantics (record_projection)</s:formal-item-title>
          <s:image s:source="png/op_record_projection.png">Record projection semantics (record_projection)</s:image>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="spec.expressions.record">
      <s:section-title>Record</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          A <s:term s:type="term">record_expression</s:term> constructs
          a new value of a
          <s:link s:target="spec.types.records">record</s:link>
          type.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Type rules</s:subsection-title>
        <s:paragraph>
          If a record type <s:term s:type="type">t</s:term> exists in the current
          environment, then a record expression creates a new value of type
          <s:term s:type="type">t</s:term>. Note that the type rule implies that
          all <s:term s:type="term">fields</s:term> of the corresponding
          record type must be specified exactly once.
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Record expression type rule (record_expression)</s:formal-item-title>
          <s:image s:source="png/ty_record_expression.png">Record expression type rule (record_expression)</s:image>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Operational semantics</s:subsection-title>
        <s:paragraph>
          A <s:term s:type="term">record_expression</s:term> is
          a set of distinct
          <s:link s:target="spec.types.records">record</s:link>
          field labels with associated expressions. The expressions
          associated with each field are evaluated in the order that they appear
          in the source code, by rules
          <s:term s:type="constant">record_expression_0</s:term> and
          <s:term s:type="constant">record_expression_1</s:term>, resulting in
          a new value of type <s:term s:type="type">t</s:term>.
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Record expression semantics (record_expression)</s:formal-item-title>
          <s:image s:source="png/op_record_expression.png">Record expression semantics (record_expression)</s:image>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="spec.expressions.swizzle">
      <s:section-title>Swizzle</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          A <s:term s:type="term">swizzle_expression</s:term> selects one or
          more named components of an expression of a
          <s:link s:target="spec.types.vector">vector</s:link>
          type, returning either a
          scalar value, or another <s:term s:type="term">vector</s:term>.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Type rules</s:subsection-title>
        <s:paragraph>
          For <s:term s:type="term">swizzle_expressions</s:term>, special type rules
          apply as described in the
          <s:link s:target="spec.types.vector">Vectors</s:link>
          section of the
          <s:link s:target="spec.types">Types</s:link> section.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Operational semantics</s:subsection-title>
        <s:paragraph>
          For a <s:term s:type="term">swizzle_expression</s:term>
          <s:term s:type="expression">e</s:term>,
          the left hand side of the expression is evaluated, by rule
          <s:term s:type="constant">swizzle_pre</s:term>, and the
          resulting expression is a new vector or scalar value.
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Swizzle semantics (swizzle)</s:formal-item-title>
          <s:image s:source="png/op_swizzle.png">Swizzle semantics (swizzle)</s:image>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="spec.expressions.new">
      <s:section-title>New</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          A <s:term s:type="term">new_expression</s:term> creates a new
          value of a given type, initialized with the values of the given
          expressions.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Type rules</s:subsection-title>
        <s:paragraph>
          For <s:term s:type="term">new_expression</s:term>,
          that construct values of types with the
          <s:term s:type="keyword">new</s:term> keyword, special type rules
          apply as described in the
          <s:link s:target="spec.types.constructors">Constructors</s:link>
          section of the
          <s:link s:target="spec.types">Types</s:link> section.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Operational semantics</s:subsection-title>
        <s:paragraph>
          A <s:term s:type="term">new_expression</s:term> is of the
          form <s:term s:type="expression">new t x</s:term>, where
          the <s:term s:type="expression">x</s:term> is an n-tuple
          of expressions given as
          <s:link s:target="spec.types.constructors">constructor</s:link>
          arguments. The expressions given are evaluated from left-to-right
          by rules <s:term s:type="constant">new_left_0</s:term> and
          <s:term s:type="constant">new_left_1</s:term>, resulting in
          a new value of type <s:term s:type="type">t</s:term>.
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>New semantics (new)</s:formal-item-title>
          <s:image s:source="png/op_new.png">New semantics (new)</s:image>
        </s:formal-item>
      </s:subsection>
    </s:section>
  </s:part>

  <s:part xml:id="spec.types">
    <s:part-title>Types</s:part-title>
    <s:part-contents/>

    <s:section>
      <s:section-title>Overview</s:section-title>
      <s:paragraph>
        A <s:term s:type="term">type</s:term> classifies a set of
        values. Types in the <s:term s:type="package">parasol</s:term>
        language have <s:term s:type="term">by-name equivalence</s:term>
        (that is, two types are equal iff they have the same name) and
        the types of all terms are checked <s:term s:type="term">statically</s:term>.
        All well-typed <s:term s:type="term">terms</s:term> in the
        language have exactly one <s:term s:type="term">type</s:term>.
      </s:paragraph>
      <s:paragraph>
        The language defines a set of <s:term s:type="term">basic types</s:term>,
        and allows the declaration of new types. The set of basic types is:
      </s:paragraph>
      <s:formal-item s:kind="specifications" s:type="specifications">
        <s:formal-item-title>Basic types</s:formal-item-title>
        <s:list-unordered>
          <s:list-item><s:link s:target="spec.types.integer">integer</s:link></s:list-item>
          <s:list-item><s:link s:target="spec.types.float">float</s:link></s:list-item>
          <s:list-item><s:link s:target="spec.types.boolean">boolean</s:link></s:list-item>
          <s:list-item><s:link s:target="spec.types.vector">vector_2i</s:link></s:list-item>
          <s:list-item><s:link s:target="spec.types.vector">vector_3i</s:link></s:list-item>
          <s:list-item><s:link s:target="spec.types.vector">vector_4i</s:link></s:list-item>
          <s:list-item><s:link s:target="spec.types.vector">vector_2f</s:link></s:list-item>
          <s:list-item><s:link s:target="spec.types.vector">vector_3f</s:link></s:list-item>
          <s:list-item><s:link s:target="spec.types.vector">vector_4f</s:link></s:list-item>
          <s:list-item><s:link s:target="spec.types.matrix">matrix_3x3f</s:link></s:list-item>
          <s:list-item><s:link s:target="spec.types.matrix">matrix_4x4f</s:link></s:list-item>
          <s:list-item><s:link s:target="spec.types.samplers">sampler_2d</s:link></s:list-item>
          <s:list-item><s:link s:target="spec.types.samplers">sampler_cube</s:link></s:list-item>
        </s:list-unordered>
      </s:formal-item>
      <s:paragraph>
        Values of the basic types may be introduced via certain
        <s:link s:target="spec.expressions">literal expressions</s:link>,
        or via the use of the <s:term s:type="keyword">new</s:term>
        keyword, which invokes an appropriate
        <s:link s:target="spec.types.constructors">constructor function</s:link>
        for the given type. The <s:term s:type="term">constructor function</s:term>
        chosen is based upon the n-tuple of arguments presented to the
        <s:term s:type="keyword">new</s:term> keyword, and if no appropriate function
        exists, the expression is rejected as ill-typed.
      </s:paragraph>
    </s:section>

    <s:section xml:id="spec.types.constructors">
      <s:section-title>Constructors</s:section-title>
      <s:paragraph>
        Each of the basic types have zero or more associated
        anonymous <s:term s:type="term">constructor functions</s:term>
        (often abbreviated to <s:term s:type="term">constructors</s:term>)
        which are responsible for introducing values of the types into the
        environment. An expression of the form
        <s:term s:type="expression">new s (x‚ÇÄ : t‚ÇÄ, ..., x‚Çô : t‚Çô)</s:term> has
        type <s:term s:type="type">s</s:term> iff
        there is a <s:term s:type="term">constructor</s:term> for
        <s:term s:type="type">s</s:term> of type
        <s:term s:type="type">(t‚ÇÄ ‚úï ... t‚Çô) ‚Üí s</s:term>.
      </s:paragraph>
      <s:paragraph>
        The descriptions for each of the basic types describe the
        available <s:term s:type="term">constructors</s:term> for
        each.
      </s:paragraph>
    </s:section>

    <s:section xml:id="spec.types.integer">
      <s:section-title>Integer</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          The <s:term s:type="type">integer</s:term> type represents a signed,
          <s:term s:type="constant">32</s:term> bit, two's-complement integer.
          Values outside of the range
          <s:term s:type="expression">[-(2¬≥¬π), (2¬≥¬π) - 1]</s:term> are silently
          wrapped to produce the low-order <s:term s:type="constant">32</s:term>
          bits of the result.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Constructors</s:subsection-title>
        <s:paragraph>
          The type has the following <s:term s:type="term">constructors</s:term>:
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Constructors</s:formal-item-title>
          <s:list-unordered>
            <s:list-item><s:term s:type="type">integer ‚Üí integer</s:term></s:list-item>
            <s:list-item><s:term s:type="type">boolean ‚Üí integer</s:term></s:list-item>
            <s:list-item><s:term s:type="type">float ‚Üí integer</s:term></s:list-item>
          </s:list-unordered>
        </s:formal-item>
        <s:paragraph>
          The constructor taking a value <s:term s:type="variable">v</s:term> of 
          type <s:term s:type="type">boolean</s:term>
          results in an integer value <s:term s:type="constant">0</s:term> iff
          <s:term s:type="expression">v = false</s:term> and
          an integer value <s:term s:type="constant">1</s:term> iff
          <s:term s:type="expression">v = true</s:term>.
        </s:paragraph>
        <s:paragraph>
          The constructor taking a value <s:term s:type="variable">v</s:term> of 
          type <s:term s:type="type">float</s:term>
          results in an integer value consisting of the integral part of
          <s:term s:type="variable">v</s:term> with the fractional part truncated.
        </s:paragraph>
        <s:paragraph>
          The <s:term s:type="type">integer</s:term> type is a
          <s:term s:type="term">scalar</s:term> type. As with the other
          <s:term s:type="term">scalar</s:term> types, the
          type rule for the construction of values of type
          <s:term s:type="type">integer</s:term> is:
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Scalar new type rule (new_scalar)</s:formal-item-title>
          <s:image s:source="png/ty_new_scalar.png">Scalar new type rule (new_scalar)</s:image>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="spec.types.float">
      <s:section-title>Float</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          The <s:term s:type="type">float</s:term> type represents a single-precision
          IEEE754 floating point number.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Constructors</s:subsection-title>
        <s:paragraph>
          The type has the following <s:term s:type="term">constructors</s:term>:
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Constructors</s:formal-item-title>
          <s:list-unordered>
            <s:list-item><s:term s:type="type">integer ‚Üí float</s:term></s:list-item>
            <s:list-item><s:term s:type="type">boolean ‚Üí float</s:term></s:list-item>
            <s:list-item><s:term s:type="type">float ‚Üí float</s:term></s:list-item>
          </s:list-unordered>
        </s:formal-item>
        <s:paragraph>
          The constructor taking a value <s:term s:type="variable">v</s:term> of 
          type <s:term s:type="type">boolean</s:term>
          results in a value <s:term s:type="constant">0.0</s:term> iff
          <s:term s:type="expression">v = false</s:term> and
          a value <s:term s:type="constant">1.0</s:term>
          <s:term s:type="expression">v = true</s:term>.
        </s:paragraph>
        <s:paragraph>
          The constructor taking a value <s:term s:type="variable">v</s:term> of 
          type <s:term s:type="type">integer</s:term>
          results in an value with an integral part as close as possible to the
          value of <s:term s:type="variable">v</s:term> dependent on the internal
          precision of the <s:term s:type="type">float</s:term> type.
        </s:paragraph>
        <s:paragraph>
          The <s:term s:type="type">float</s:term> type is a
          <s:term s:type="term">scalar</s:term> type. As with the other
          <s:term s:type="term">scalar</s:term> types, the
          type rule for the construction of values of type
          <s:term s:type="type">float</s:term> is:
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Scalar new type rule (new_scalar)</s:formal-item-title>
          <s:image s:source="png/ty_new_scalar.png">Scalar new type rule (new_scalar)</s:image>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="spec.types.boolean">
      <s:section-title>Boolean</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          The <s:term s:type="type">boolean</s:term> type represents a
          <s:term s:type="constant">true</s:term> or <s:term s:type="constant">false</s:term>
          value.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Constructors</s:subsection-title>
        <s:paragraph>
          The type has the following <s:term s:type="term">constructors</s:term>:
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Constructors</s:formal-item-title>
          <s:list-unordered>
            <s:list-item><s:term s:type="type">boolean ‚Üí boolean</s:term></s:list-item>
            <s:list-item><s:term s:type="type">float ‚Üí boolean</s:term></s:list-item>
            <s:list-item><s:term s:type="type">integer ‚Üí boolean</s:term></s:list-item>
          </s:list-unordered>
        </s:formal-item>
        <s:paragraph>
          The constructor taking a value <s:term s:type="variable">v</s:term> of 
          type <s:term s:type="type">float</s:term>
          results in a value <s:term s:type="constant">false</s:term> iff
          <s:term s:type="expression">v = 0.0</s:term> and
          a value <s:term s:type="constant">true</s:term> otherwise.
        </s:paragraph>
        <s:paragraph>
          The constructor taking a value <s:term s:type="variable">v</s:term> of 
          type <s:term s:type="type">integer</s:term>
          results in a value <s:term s:type="constant">false</s:term> iff
          <s:term s:type="expression">v = 0</s:term> and
          a value <s:term s:type="constant">true</s:term> otherwise.
        </s:paragraph>
        <s:paragraph>
          The <s:term s:type="type">boolean</s:term> type is a
          <s:term s:type="term">scalar</s:term> type. As with the other
          <s:term s:type="term">scalar</s:term> types, the
          type rule for the construction of values of type
          <s:term s:type="type">boolean</s:term> is:
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Scalar new type rule (new_scalar)</s:formal-item-title>
          <s:image s:source="png/ty_new_scalar.png">Scalar new type rule (new_scalar)</s:image>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="spec.types.vector">
      <s:section-title>Vectors</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          The <s:term s:type="type">vector_NT</s:term> types represent
          fixed-length vectors, where <s:term s:type="expression">N ‚àà [2, 4]</s:term>
          and represents the number of components in the vector,
          and <s:term s:type="expression">T ‚àà {f, i}</s:term>
          where <s:term s:type="constant">f</s:term> indicates that the components
          of the vector are of type
          <s:link s:target="spec.types.float">float</s:link>
          and <s:term s:type="constant">i</s:term>
          indicates that the components of the vector are of type
          <s:link s:target="spec.types.integer">integer</s:link>.
        </s:paragraph>
        <s:paragraph>
          The components of the <s:term s:type="type">vector_NT</s:term> types
          are labelled, in order, from the n-tuple of labels
          <s:term s:type="expression">K = (x, y, z, w)</s:term>.
          At most <s:term s:type="expression">N</s:term> labels are used for each type,
          so the first, second, third, and fourth elements of the
          <s:term s:type="type">vector_4T</s:term> types are labelled
          <s:term s:type="constant">x</s:term>, <s:term s:type="constant">y</s:term>,
          <s:term s:type="constant">z</s:term>, and <s:term s:type="constant">w</s:term>,
          respectively. The <s:term s:type="type">vector_3T</s:term> types lack a
          <s:term s:type="constant">w</s:term> component, and the
          <s:term s:type="type">vector_2T</s:term> types lack both
          <s:term s:type="constant">z</s:term> and <s:term s:type="constant">w</s:term>
          components.
        </s:paragraph>
        <s:paragraph>
          The values of the components of the <s:term s:type="type">vector_NT</s:term> types
          are extracted via <s:term s:type="term">swizzle</s:term> expressions. A
          <s:term s:type="term">swizzle</s:term> expression consists of an n-tuple
          <s:term s:type="expression">S‚Çö</s:term>
          of labels taken from the set <s:term s:type="expression">S = tuples(L, M)</s:term> of
          n-tuples, where
          <s:term s:type="expression">M &lt;= N</s:term>,
          <s:term s:type="expression">L</s:term> is the first
          <s:term s:type="expression">M - 1</s:term> elements of <s:term s:type="expression">K</s:term>,
          and <s:term s:type="expression">0 &lt;= P &lt;= |S|</s:term>,
          and evaluates to
          a value of type <s:term s:type="type">vector_MT</s:term>
          or, in the case that <s:term s:type="expression">M = 1</s:term>,
          a scalar value of type <s:term s:type="type">T</s:term>,
          consisting of the values of the components named in <s:term s:type="expression">S‚Çö</s:term>:
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Swizzle vector type rule (vector_swizzle)</s:formal-item-title>
          <s:image s:source="png/ty_vector_swizzle.png">Swizzle vector type rule (vector_swizzle)</s:image>
        </s:formal-item>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Swizzle scalar type rule (vector_swizzle_single)</s:formal-item-title>
          <s:image s:source="png/ty_vector_swizzle_single.png">Swizzle scalar type rule (vector_swizzle_single)</s:image>
        </s:formal-item>
        <s:paragraph>
          Algebraically, <s:term s:type="term">swizzling</s:term> is analogous to
          multiplication of a vector <s:term s:type="variable">v</s:term> of size
          <s:term s:type="expression">N</s:term>
          by an <s:term s:type="expression">NxN</s:term> matrix
          <s:term s:type="variable">p</s:term>, where each row of
          <s:term s:type="variable">p</s:term> consists of
          <s:term s:type="expression">N - 1</s:term> zeroes and exactly one
          <s:term s:type="expression">1</s:term>:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Swizzle matrix example</s:formal-item-title>
          <s:image s:source="png/ex_matrix_swizzle_example.png">Swizzle matrix example</s:image>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Constructors</s:subsection-title>
        <s:paragraph>
          The <s:term s:type="term">constructors</s:term> of the
          <s:term s:type="type">vector_NT</s:term> types
          can be conceptually divided into <s:term s:type="term">primary</s:term>
          and <s:term s:type="term">auxiliary constructors</s:term>. Each
          <s:term s:type="type">vector_NT</s:term> type has exactly one
          <s:term s:type="term">primary constructor</s:term> which initializes
          the components of the resulting <s:term s:type="type">vector_NT</s:term>
          value to the values of the expressions in the exact order given.
          There is no practical or visible difference between a
          <s:term s:type="term">primary</s:term> and
          <s:term s:type="term">auxiliary constructor</s:term>; the distinction
          is simply made for the purposes of describing the typing rules.
        </s:paragraph>
        <s:paragraph>
          The types of the <s:term s:type="term">primary constructors</s:term> for
          each type are:
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Vector primary constructors</s:formal-item-title>
          <s:table>
            <s:table-summary>Vector primary constructors</s:table-summary>
            <s:table-head>
              <s:table-column-name>Type</s:table-column-name>
              <s:table-column-name>Constructor type</s:table-column-name>
            </s:table-head>
            <s:table-body>
              <s:table-row>
                <s:table-cell><s:term s:type="type">vector_2i</s:term></s:table-cell>
                <s:table-cell><s:term s:type="type">(integer, integer) ‚Üí vector_2i</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term s:type="type">vector_3i</s:term></s:table-cell>
                <s:table-cell><s:term s:type="type">(integer, integer, integer) ‚Üí vector_3i</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term s:type="type">vector_4i</s:term></s:table-cell>
                <s:table-cell><s:term s:type="type">(integer, integer, integer, integer) ‚Üí vector_4i</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term s:type="type">vector_2f</s:term></s:table-cell>
                <s:table-cell><s:term s:type="type">(float, float) ‚Üí vector_2f</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term s:type="type">vector_3f</s:term></s:table-cell>
                <s:table-cell><s:term s:type="type">(float, float, float) ‚Üí vector_3f</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term s:type="type">vector_4f</s:term></s:table-cell>
                <s:table-cell><s:term s:type="type">(float, float, float, float) ‚Üí vector_4f</s:term></s:table-cell>
              </s:table-row>
            </s:table-body>
          </s:table>
        </s:formal-item>
        <s:paragraph>
          Given the presence of <s:term s:type="term">primary constructors</s:term>,
          the type rule for the construction of a vector using the
          <s:term s:type="keyword">new</s:term> keyword is:
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Vector new type rule (vector_new)</s:formal-item-title>
          <s:image s:source="png/ty_vector_new.png">Vector new type rule (vector_new)</s:image>
        </s:formal-item>
        <s:paragraph>
          The <s:term s:type="term">auxiliary constructors</s:term> for the
          <s:term s:type="type">vector_NT</s:term> types are:
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Vector auxiliary constructors</s:formal-item-title>
          <s:table>
            <s:table-summary>Vector auxiliary constructors</s:table-summary>
            <s:table-head>
              <s:table-column-name>Type</s:table-column-name>
              <s:table-column-name>Constructor type</s:table-column-name>
            </s:table-head>
            <s:table-body>
              <s:table-row>
                <s:table-cell><s:term s:type="type">vector_2i</s:term></s:table-cell>
                <s:table-cell><s:term s:type="type">vector_2i ‚Üí vector_2i</s:term></s:table-cell>
              </s:table-row>

              <s:table-row>
                <s:table-cell><s:term s:type="type">vector_3i</s:term></s:table-cell>
                <s:table-cell><s:term s:type="type">(integer, vector_2i) ‚Üí vector_3i</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term s:type="type">vector_3i</s:term></s:table-cell>
                <s:table-cell><s:term s:type="type">(vector_2i, integer) ‚Üí vector_3i</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term s:type="type">vector_3i</s:term></s:table-cell>
                <s:table-cell><s:term s:type="type">vector_3i ‚Üí vector_3i</s:term></s:table-cell>
              </s:table-row>

              <s:table-row>
                <s:table-cell><s:term s:type="type">vector_4i</s:term></s:table-cell>
                <s:table-cell><s:term s:type="type">(vector_2i, integer, integer) ‚Üí vector_4i</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term s:type="type">vector_4i</s:term></s:table-cell>
                <s:table-cell><s:term s:type="type">(integer, vector_2i, integer) ‚Üí vector_4i</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term s:type="type">vector_4i</s:term></s:table-cell>
                <s:table-cell><s:term s:type="type">(vector_2i, vector_2i) ‚Üí vector_4i</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term s:type="type">vector_4i</s:term></s:table-cell>
                <s:table-cell><s:term s:type="type">(integer, integer, vector_2i) ‚Üí vector_4i</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term s:type="type">vector_4i</s:term></s:table-cell>
                <s:table-cell><s:term s:type="type">(vector_3i, integer) ‚Üí vector_4i</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term s:type="type">vector_4i</s:term></s:table-cell>
                <s:table-cell><s:term s:type="type">(integer, vector_3i) ‚Üí vector_4i</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term s:type="type">vector_4i</s:term></s:table-cell>
                <s:table-cell><s:term s:type="type">vector_4i ‚Üí vector_4i</s:term></s:table-cell>
              </s:table-row>

              <s:table-row>
                <s:table-cell><s:term s:type="type">vector_2f</s:term></s:table-cell>
                <s:table-cell><s:term s:type="type">vector_2f ‚Üí vector_2f</s:term></s:table-cell>
              </s:table-row>

              <s:table-row>
                <s:table-cell><s:term s:type="type">vector_3f</s:term></s:table-cell>
                <s:table-cell><s:term s:type="type">(float, vector_2f) ‚Üí vector_3f</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term s:type="type">vector_3f</s:term></s:table-cell>
                <s:table-cell><s:term s:type="type">(vector_2f, float) ‚Üí vector_3f</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term s:type="type">vector_3f</s:term></s:table-cell>
                <s:table-cell><s:term s:type="type">vector_3f ‚Üí vector_3f</s:term></s:table-cell>
              </s:table-row>

              <s:table-row>
                <s:table-cell><s:term s:type="type">vector_4f</s:term></s:table-cell>
                <s:table-cell><s:term s:type="type">(vector_2f, float, float) ‚Üí vector_4f</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term s:type="type">vector_4f</s:term></s:table-cell>
                <s:table-cell><s:term s:type="type">(float, vector_2f, float) ‚Üí vector_4f</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term s:type="type">vector_4f</s:term></s:table-cell>
                <s:table-cell><s:term s:type="type">(vector_2f, vector_2f) ‚Üí vector_4f</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term s:type="type">vector_4f</s:term></s:table-cell>
                <s:table-cell><s:term s:type="type">(float, float, vector_2f) ‚Üí vector_4f</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term s:type="type">vector_4f</s:term></s:table-cell>
                <s:table-cell><s:term s:type="type">(vector_3f, float) ‚Üí vector_4f</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term s:type="type">vector_4f</s:term></s:table-cell>
                <s:table-cell><s:term s:type="type">(float, vector_3f) ‚Üí vector_4f</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term s:type="type">vector_4f</s:term></s:table-cell>
                <s:table-cell><s:term s:type="type">vector_4f ‚Üí vector_4f</s:term></s:table-cell>
              </s:table-row>
            </s:table-body>
          </s:table>
        </s:formal-item>
        <s:paragraph>
          For each <s:term s:type="term">auxiliary constructor</s:term> for a given
          <s:term s:type="type">vector_NT</s:term> type, the values of the scalars (if any),
          and the values of the components of the given vectors (if any), are concatenated
          together in the order given to produce an n-tuple of length
          <s:term s:type="variable">N</s:term>
          which is then passed directly to the
          <s:term s:type="term">primary constructor</s:term> for the given type.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="spec.types.matrix">
      <s:section-title>Matrices</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          The <s:term s:type="type">matrix_NxNf</s:term> types represent
          square matrices, where <s:term s:type="expression">N ‚àà [3, 4]</s:term>
          and represents the number of rows/columns in the matrix.
          Only matrices with elements of type
          <s:link s:target="spec.types.float">float</s:link>
          are provided.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Constructors</s:subsection-title>
        <s:paragraph>
          Values of the <s:term s:type="type">matrix_NxNf</s:term> types are
          constructed by providing exactly <s:term s:type="expression">N</s:term>
          <s:term s:type="term">column vectors</s:term> of size
          <s:term s:type="expression">N</s:term>. This is reflected in the
          available <s:term s:type="term">constructors</s:term> for the
          <s:term s:type="type">matrix_NxNf</s:term> types:
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Matrix constructors</s:formal-item-title>
          <s:table>
            <s:table-summary>Matrix constructors</s:table-summary>
            <s:table-head>
              <s:table-column-name>Type</s:table-column-name>
              <s:table-column-name>Constructor type</s:table-column-name>
            </s:table-head>
            <s:table-body>
              <s:table-row>
                <s:table-cell><s:term s:type="type">matrix_3x3f</s:term></s:table-cell>
                <s:table-cell><s:term s:type="type">(vector_3f, vector_3f, vector_3f) ‚Üí matrix_3x3f</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term s:type="type">matrix_4x4f</s:term></s:table-cell>
                <s:table-cell><s:term s:type="type">(vector_4f, vector_4f, vector_4f, vector_4f) ‚Üí matrix_4x4f</s:term></s:table-cell>
              </s:table-row>
            </s:table-body>
          </s:table>
        </s:formal-item>
        <s:paragraph>
          The type rule for the construction of matrices with the
          <s:term s:type="keyword">new</s:term> keyword is:
        </s:paragraph>
        <s:formal-item s:kind="specifications" s:type="specifications">
          <s:formal-item-title>Matrix new type rule (matrix_new)</s:formal-item-title>
          <s:image s:source="png/ty_matrix_new.png">Matrix new type rule (matrix_new)</s:image>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="spec.types.samplers">
      <s:section-title>Samplers</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          The <s:term s:type="type">sampler_2d</s:term> and
          <s:term s:type="type">sampler_cube</s:term> types represent
          abstract <s:term s:type="term">handles</s:term> to two-dimensional
          and cube textures, respectively.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Constructors</s:subsection-title>
        <s:paragraph>
          The types have no constructors and there is no way to
          create new values of the types in the language. They are
          intended for use as parameters to
          <s:link s:target="spec.declarations.shaders">shaders</s:link>.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="spec.types.records">
      <s:section-title>Records</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          Record types are composite types consisting of labelled
          fields. Values of record types are constructed with the
          <s:term s:type="keyword">new</s:term> keyword, and values
          of fields are accessed with
          <s:link s:target="spec.expressions.record_projection">record_projection</s:link>
          expressions.
        </s:paragraph>
        <s:paragraph>
          Only a subset of the available types can be used as fields in records:
        </s:paragraph>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>Record field types</s:formal-item-title>
          <s:list-unordered>
            <s:list-item><s:link s:target="spec.types.integer">integer</s:link></s:list-item>
            <s:list-item><s:link s:target="spec.types.float">float</s:link></s:list-item>
            <s:list-item><s:link s:target="spec.types.boolean">boolean</s:link></s:list-item>
            <s:list-item><s:link s:target="spec.types.vector">vector_NT</s:link></s:list-item>
            <s:list-item><s:link s:target="spec.types.matrix">matrix_NxNf</s:link></s:list-item>
            <s:list-item>User-defined <s:link s:target="spec.types.records">record</s:link> types</s:list-item>
          </s:list-unordered>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Constructors</s:subsection-title>
        <s:paragraph>
          Record types do not have <s:term s:type="term">constructors</s:term>
          and values of record types can only be introduced with
          <s:link s:target="spec.expressions.record">record expressions</s:link>.
        </s:paragraph>
      </s:subsection>
    </s:section>
  </s:part>

  <s:part xml:id="spec.execution">
    <s:part-title>Compilation and Execution</s:part-title>
    <s:part-contents/>
    <s:section>
      <s:section-title>Overview</s:section-title>
      <s:paragraph>
        This section attempts to informally document the typical life cycle
        of a <s:term s:type="package">parasol</s:term> program, from its initial
        state as a set of source code, to its final state executing on a GPU,
        from a somewhat abstract and idealized viewpoint. The intention is to
        allow the reader to better understand how the given operational
        semantics fit together and how the language as structured results
        in a working program.
      </s:paragraph>
    </s:section>
    <s:section>
      <s:section-title>Lifecycle</s:section-title>
      <s:paragraph>
        First, the intended program is <s:term s:type="term">compiled</s:term>:
      </s:paragraph>
      <s:formal-item s:kind="examples">
        <s:formal-item-title>Compilation</s:formal-item-title>
        <s:list-ordered>
          <s:list-item>
            The user submits a series of <s:link s:target="spec.lex.units">units</s:link>,
            in no particular order, to the
            <s:term s:type="package">parasol</s:term> implementation compiler, along with the
            fully-qualified name of a
            <s:link s:target="spec.declarations.shaders.program">program</s:link>.
          </s:list-item>
          <s:list-item>
            The compiler combines the <s:term s:type="term">units</s:term>, checks
            for <s:link s:target="spec.declarations.modules">module</s:link>
            name collisions, checks the sanity of the submitted modules,
            resolves all names, and checks the
            <s:link s:target="spec.types">types</s:link>
            of all
            <s:link s:target="spec.declarations.terms">terms</s:link>.
          </s:list-item>
          <s:list-item>
            The compiler then erases all <s:term s:type="term">module_declarations</s:term> from
            the environment, renaming all <s:term s:type="term">terms</s:term> to result in a set
            of <s:term s:type="term">terms</s:term> with unique names.
          </s:list-item>
          <s:list-item>
            The compiler then determines all <s:term s:type="term">terms</s:term> upon which
            the <s:link s:target="spec.declarations.shaders.program">program</s:link>
            depends, removing all unused <s:term s:type="term">terms</s:term> and sorting
            the resulting <s:term s:type="term">terms</s:term> topologically.
          </s:list-item>
        </s:list-ordered>
      </s:formal-item>
      <s:paragraph>
        At this point,
        the environment contains a
        <s:link s:target="spec.declarations.shaders.vertex">vertex shader</s:link>
        <s:term s:type="expression">V</s:term>
        with an associated ordered set of <s:term s:type="term">terms</s:term>
        <s:term s:type="expression">T</s:term>, and
        <s:link s:target="spec.declarations.shaders.fragment">fragment shader</s:link>
        <s:term s:type="expression">F</s:term>
        with an associated ordered set of <s:term s:type="term">terms</s:term>
        <s:term s:type="expression">U</s:term>.
      </s:paragraph>
      <s:paragraph>
        <s:term s:type="term">Execution</s:term> then proceeds as follows:
      </s:paragraph>
      <s:formal-item s:kind="examples">
        <s:formal-item-title>Execution</s:formal-item-title>
        <s:list-ordered>
          <s:list-item>
            Execution of <s:term s:type="expression">V</s:term> begins.
          </s:list-item>
          <s:list-item>
            The <s:term s:type="term">terms</s:term> in <s:term s:type="expression">T</s:term> are
            evaluated in the order given.
          </s:list-item>
          <s:list-item>
            The operational semantics imply that the values of the terms in
            <s:term s:type="expression">T</s:term> have been substituted into the
            <s:link s:target="spec.declarations.shaders.vertex.declarations">local declarations</s:link>
            of <s:term s:type="expression">V</s:term>. The
            local declarations defined in <s:term s:type="expression">V</s:term> are evaluated.
          </s:list-item>
          <s:list-item>
            The values resulting from evaluation are written to the
            outputs of <s:term s:type="expression">V</s:term>.
          </s:list-item>
          <s:list-item>
            Execution of <s:term s:type="expression">F</s:term> begins.
          </s:list-item>
          <s:list-item>
            The <s:term s:type="term">terms</s:term> in <s:term s:type="expression">U</s:term> are
            evaluated in the order given.
          </s:list-item>
          <s:list-item>
            The operational semantics imply that the values of the terms in
            <s:term s:type="expression">U</s:term> have been substituted into the
            <s:link s:target="spec.declarations.shaders.fragment.declarations">local declarations</s:link>
            of <s:term s:type="expression">F</s:term>. The
            local declarations defined in <s:term s:type="expression">F</s:term> are evaluated.
          </s:list-item>
          <s:list-item>
            If <s:term s:type="expression">F</s:term> contains a
            <s:link s:target="spec.declarations.shaders.fragment.discard">discard</s:link>
            declaration, and the condition evaluates to <s:term s:type="constant">true</s:term>,
            execution of <s:term s:type="expression">F</s:term> halts and no
            output is produced.
          </s:list-item>
          <s:list-item>
            The values resulting from evaluation are written to the
            outputs of <s:term s:type="expression">F</s:term>.
          </s:list-item>
        </s:list-ordered>
      </s:formal-item>
    </s:section>
  </s:part>

  <s:part xml:id="spec.stdlib">
    <s:part-title>Standard Library Reference</s:part-title>
    <s:part-contents/>
    <s:section xml:id="spec.stdlib.com.io7m.parasol.Float">
      <s:section-title>Module com.io7m.parasol.Float</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>absolute</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>absolute Definition</s:formal-item-title>
          <s:verbatim>function absolute (x : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the absolute value of <s:term s:type="variable">x</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>add</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>add Definition</s:formal-item-title>
          <s:verbatim>function add (x : float, y : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return <s:term s:type="expression">x + y</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>arc_cosine</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>arc_cosine Definition</s:formal-item-title>
          <s:verbatim>function arc_cosine (x : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the arc cosine <s:term s:type="expression">acos(x)</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>arc_sine</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>arc_sine Definition</s:formal-item-title>
          <s:verbatim>function arc_sine (x : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the arc sine <s:term s:type="expression">asin(x)</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>arc_tangent</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>arc_tangent Definition</s:formal-item-title>
          <s:verbatim>function arc_tangent (x : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the arc tangent <s:term s:type="expression">atan(x)</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>ceiling</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>ceiling Definition</s:formal-item-title>
          <s:verbatim>function ceiling (x : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return a value equal to the nearest integer that is greater than or equal to <s:term s:type="variable">x</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>clamp</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>clamp Definition</s:formal-item-title>
          <s:verbatim>function clamp (x : float, min : float, max : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return <s:term s:type="expression">x</s:term> constrainted to the range <s:term s:type="expression">[min, max]</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>cosine</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>cosine Definition</s:formal-item-title>
          <s:verbatim>function cosine (x : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the cosine <s:term s:type="expression">cos(x)</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>divide</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>divide Definition</s:formal-item-title>
          <s:verbatim>function divide (x : float, y : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the division <s:term s:type="expression">x / y</s:term>. The result is only defined if <s:term s:type="expression">y &gt; 0</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>equals</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>equals Definition</s:formal-item-title>
          <s:verbatim>function equals (x : float, y : float) : boolean</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return <s:term s:type="constant">true</s:term> iff <s:term s:type="expression">x == y</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>floor</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>floor Definition</s:formal-item-title>
          <s:verbatim>function floor (x : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return a value equal to the nearest integer that is less than or equal to <s:term s:type="variable">x</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>greater</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>greater Definition</s:formal-item-title>
          <s:verbatim>function greater (x : float, y : float) : boolean</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return <s:term s:type="constant">true</s:term> iff <s:term s:type="expression">x &gt; y</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>greater_or_equal</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>greater_or_equal Definition</s:formal-item-title>
          <s:verbatim>function greater_or_equal (x : float, y : float) : boolean</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return <s:term s:type="constant">true</s:term> iff <s:term s:type="expression">x &gt;= y</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>interpolate</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>interpolate Definition</s:formal-item-title>
          <s:verbatim>function interpolate (x : float, y : float, a : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>
          Return a linearly interpolated value in the range <s:term s:type="expression">[x, y]</s:term>
          given by <s:term s:type="expression">(x ‚úï (1 - a)) + (y ‚úï a)</s:term>.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>is_infinite</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>is_infinite Definition</s:formal-item-title>
          <s:verbatim>function is_infinite (x : float) : boolean</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return <s:term s:type="constant">true</s:term> iff <s:term s:type="expression">x == infinity</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>is_nan</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>is_nan Definition</s:formal-item-title>
          <s:verbatim>function is_nan (x : float) : boolean</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return <s:term s:type="constant">true</s:term> iff <s:term s:type="expression">x</s:term> is not a number.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>lesser</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>lesser Definition</s:formal-item-title>
          <s:verbatim>function lesser (x : float, y : float) : boolean</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return <s:term s:type="constant">true</s:term> iff <s:term s:type="expression">x &lt; y</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>lesser_or_equal</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>lesser_or_equal Definition</s:formal-item-title>
          <s:verbatim>function lesser_or_equal (x : float, y : float) : boolean</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return <s:term s:type="constant">true</s:term> iff <s:term s:type="expression">x &lt;= y</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>maximum</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>maximum Definition</s:formal-item-title>
          <s:verbatim>function maximum (x : float, y : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the maximum value of <s:term s:type="expression">x</s:term> and <s:term s:type="expression">y</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>minimum</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>minimum Definition</s:formal-item-title>
          <s:verbatim>function minimum (x : float, y : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the minimum value of <s:term s:type="expression">x</s:term> and <s:term s:type="expression">y</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>modulo</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>modulo Definition</s:formal-item-title>
          <s:verbatim>function modulo (x : float, y : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the value of <s:term s:type="expression">x mod y</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>multiply</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>multiply Definition</s:formal-item-title>
          <s:verbatim>function multiply (x : float, y : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the value of <s:term s:type="expression">x ‚úï y</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>power</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>power Definition</s:formal-item-title>
          <s:verbatim>function power (x : float, n : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the value of <s:term s:type="expression">x‚Åø</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>round</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>round Definition</s:formal-item-title>
          <s:verbatim>function round (x : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the value of the nearest integer to <s:term s:type="expression">x</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>sign</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>sign Definition</s:formal-item-title>
          <s:verbatim>function sign (x : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return <s:term s:type="expression">0.0</s:term> iff <s:term s:type="expression">x == 0.0</s:term>,
        <s:term s:type="expression">1.0</s:term> iff <s:term s:type="expression">x > 0.0</s:term>, and
        <s:term s:type="expression">-1.0</s:term> otherwise.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>sine</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>sine Definition</s:formal-item-title>
          <s:verbatim>function sine (x : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the sine <s:term s:type="expression">sin(x)</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>square_root</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>square_root Definition</s:formal-item-title>
          <s:verbatim>function square_root (x : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the square root of <s:term s:type="expression">x</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>subtract</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>subtract Definition</s:formal-item-title>
          <s:verbatim>function subtract (x : float, y : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the value of of <s:term s:type="expression">x - y</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>tangent</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>tangent Definition</s:formal-item-title>
          <s:verbatim>function tangent (x : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the tangent <s:term s:type="expression">tan(x)</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>truncate</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>truncate Definition</s:formal-item-title>
          <s:verbatim>function truncate (x : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>
          Return the nearest integer to <s:term s:type="expression">x</s:term> whose absolute value is
          not greater than the absolute value of <s:term s:type="expression">x</s:term>.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="spec.stdlib.com.io7m.parasol.Integer">
      <s:section-title>Module com.io7m.parasol.Integer</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>add</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>add Definition</s:formal-item-title>
          <s:verbatim>function add (x : integer, y : integer) : integer</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return <s:term s:type="expression">x + y</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>divide</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>divide Definition</s:formal-item-title>
          <s:verbatim>function divide (x : integer, y : integer) : integer</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the division <s:term s:type="expression">x / y</s:term>. The result is only defined if <s:term s:type="expression">y &gt; 0</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>multiply</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>multiply Definition</s:formal-item-title>
          <s:verbatim>function multiply (x : integer, y : integer) : integer</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return <s:term s:type="expression">x ‚úï y</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>subtract</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>subtract Definition</s:formal-item-title>
          <s:verbatim>function subtract (x : integer, y : integer) : integer</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return <s:term s:type="expression">x - y</s:term>.</s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="spec.stdlib.com.io7m.parasol.Matrix3x3f">
      <s:section-title>Module com.io7m.parasol.Matrix3x3f</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>multiply</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>multiply Definition</s:formal-item-title>
          <s:verbatim>function multiply (m0 : matrix_3x3f, m1 : matrix_3x3f) : matrix_3x3f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return <s:term s:type="expression">m0 ‚úï m1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>multiply_vector</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>multiply_vector Definition</s:formal-item-title>
          <s:verbatim>function multiply_vector (m : matrix_3x3f, v : vector_3f) : vector_3f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return <s:term s:type="expression">m ‚úï v</s:term>.</s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="spec.stdlib.com.io7m.parasol.Matrix4x4f">
      <s:section-title>Module com.io7m.parasol.Matrix4x4f</s:section-title>
      <s:subsection>
        <s:subsection-title>multiply</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>multiply Definition</s:formal-item-title>
          <s:verbatim>function multiply (m0 : matrix_4x4f, m1 : matrix_4x4f) : matrix_4x4f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return <s:term s:type="expression">m0 ‚úï m1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>multiply_vector</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>multiply_vector Definition</s:formal-item-title>
          <s:verbatim>function multiply_vector (m : matrix_4x4f, v : vector_4f) : vector_4f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return <s:term s:type="expression">m ‚úï v</s:term>.</s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="spec.stdlib.com.io7m.parasol.Sampler2D">
      <s:section-title>Module com.io7m.parasol.Sampler2D</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>texture</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>texture Definition</s:formal-item-title>
          <s:verbatim>function texture (t : sampler_2d, uv : vector_2f) : vector_4f</s:verbatim>
        </s:formal-item>
        <s:paragraph>
          Retrieve a texel from the texture <s:term s:type="variable">t</s:term>
          from the texture coordinate <s:term s:type="variable">uv</s:term>.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="spec.stdlib.com.io7m.parasol.Vector2f">
      <s:section-title>Module com.io7m.parasol.Vector2f</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>add</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>add Definition</s:formal-item-title>
          <s:verbatim>function add (v0 : vector_2f, v1 : vector_2f) : vector_2f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise addition  <s:term s:type="expression">v0 + v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>add_scalar</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>add_scalar Definition</s:formal-item-title>
          <s:verbatim>function add_scalar (v : vector_2f, x : float) : vector_2f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the addition  <s:term s:type="expression">(v[x] + s, v[y] + s)</s:term>.</s:paragraph>
      </s:subsection>

      <s:subsection>
        <s:subsection-title>divide</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>divide Definition</s:formal-item-title>
          <s:verbatim>function divide (v0 : vector_2f, v1 : vector_2f) : vector_2f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise division  <s:term s:type="expression">v0 / v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>divide_scalar</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>divide_scalar Definition</s:formal-item-title>
          <s:verbatim>function divide_scalar (v : vector_2f, x : float) : vector_2f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the division  <s:term s:type="expression">(v[x] / s, v[y] / s)</s:term>.</s:paragraph>
      </s:subsection>

      <s:subsection>
        <s:subsection-title>dot</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>dot Definition</s:formal-item-title>
          <s:verbatim>function dot (v0 : vector_2f, v1 : vector_2f) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the dot product <s:term s:type="expression">v0 ‚ãÖ v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>interpolate</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>interpolate Definition</s:formal-item-title>
          <s:verbatim>function interpolate (v0 : vector_2f, v1 : vector_2f, t : float) : vector_2f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the linear interpolation <s:term s:type="expression">(v0 ‚úï t) + (v1 ‚úï (1 - t))</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>magnitude</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>magnitude Definition</s:formal-item-title>
          <s:verbatim>function magnitude (v : vector_2f) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the magnitude of <s:term s:type="expression">v</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>multiply</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>multiply Definition</s:formal-item-title>
          <s:verbatim>function multiply (v0 : vector_2f, v1 : vector_2f) : vector_2f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise multiplication <s:term s:type="expression">v0 ‚úï v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>multiply_scalar</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>multiply_scalar Definition</s:formal-item-title>
          <s:verbatim>function multiply_scalar (v0 : vector_2i, x : float) : vector_3f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the multiplication <s:term s:type="expression">(v[x] ‚úï s, v[y] ‚úï s)</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>negate</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>negate Definition</s:formal-item-title>
          <s:verbatim>function negate (v : vector_2f) : vector_2f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise negation <s:term s:type="expression">-v</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>normalize</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>normalize Definition</s:formal-item-title>
          <s:verbatim>function normalize (v : vector_2f) : vector_2f</s:verbatim>
        </s:formal-item>
        <s:paragraph>
          Return a vector pointing in the same direction as <s:term s:type="expression">v</s:term>
          but with a magnitude of <s:term s:type="constant">1</s:term>.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>reflect</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>reflect Definition</s:formal-item-title>
          <s:verbatim>function reflect (i : vector_2f, n : vector_2f) : vector_2f</s:verbatim>
        </s:formal-item>
        <s:paragraph> 
          Return the reflection of the incident vector 
          <s:term s:type="expression">i</s:term> with respect to the vector <s:term s:type="expression">n</s:term>,
          as given by <s:term s:type="expression">i - 2.0 ‚úï dot(n, i) ‚úï n</s:term>.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>refract</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>refract Definition</s:formal-item-title>
          <s:verbatim>function refract (i : vector_2f, n : vector_2f, e : float) : vector_2f</s:verbatim>
        </s:formal-item>
        <s:paragraph> 
          Return the refraction vector of the incident vector 
          <s:term s:type="expression">i</s:term> with respect to the vector <s:term s:type="expression">n</s:term>,
          with the given ratio of indices of refraction <s:term s:type="expression">e</s:term>.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>subtract</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>subtract Definition</s:formal-item-title>
          <s:verbatim>function subtract (v0 : vector_2f, v1 : vector_2f) : vector_2f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise subtraction <s:term s:type="expression">v0 - v1</s:term>.</s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="spec.stdlib.com.io7m.parasol.Vector2i">
      <s:section-title>Module com.io7m.parasol.Vector2i</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>add</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>add Definition</s:formal-item-title>
          <s:verbatim>function add (v0 : vector_2i, v1 : vector_2i) : vector_2i</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise addition  <s:term s:type="expression">v0 + v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>add_scalar</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>add_scalar Definition</s:formal-item-title>
          <s:verbatim>function add_scalar (v : vector_2i, x : integer) : vector_2i</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the addition  <s:term s:type="expression">(v[x] + s, v[y] + s)</s:term>.</s:paragraph>
      </s:subsection>

      <s:subsection>
        <s:subsection-title>divide</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>divide Definition</s:formal-item-title>
          <s:verbatim>function divide (v0 : vector_2i, v1 : vector_2i) : vector_2i</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise division  <s:term s:type="expression">v0 / v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>divide_scalar</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>divide_scalar Definition</s:formal-item-title>
          <s:verbatim>function divide_scalar (v : vector_2i, x : integer) : vector_2i</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the division  <s:term s:type="expression">(v[x] / s, v[y] / s)</s:term>.</s:paragraph>
      </s:subsection>

      <s:subsection>
        <s:subsection-title>dot</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>dot Definition</s:formal-item-title>
          <s:verbatim>function dot (v0 : vector_2i, v1 : vector_2i) : integer</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the dot product <s:term s:type="expression">v0 ‚ãÖ v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>interpolate</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>interpolate Definition</s:formal-item-title>
          <s:verbatim>function interpolate (v0 : vector_2i, v1 : vector_2i, t : float) : vector_2i</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the linear interpolation <s:term s:type="expression">(v0 ‚úï t) + (v1 ‚úï (1 - t))</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>magnitude</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>magnitude Definition</s:formal-item-title>
          <s:verbatim>function magnitude (v : vector_2i) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the magnitude of <s:term s:type="expression">v</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>multiply</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>multiply Definition</s:formal-item-title>
          <s:verbatim>function multiply (v0 : vector_2i, v1 : vector_2i) : vector_2i</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise multiplication <s:term s:type="expression">v0 ‚úï v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>multiply_scalar</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>multiply_scalar Definition</s:formal-item-title>
          <s:verbatim>function multiply_scalar (v0 : vector_2i, x : integer) : vector_3f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the multiplication <s:term s:type="expression">(v[x] ‚úï s, v[y] ‚úï s)</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>negate</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>negate Definition</s:formal-item-title>
          <s:verbatim>function negate (v : vector_2i) : vector_2i</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise negation <s:term s:type="expression">-v</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>normalize</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>normalize Definition</s:formal-item-title>
          <s:verbatim>function normalize (v : vector_2i) : vector_2i</s:verbatim>
        </s:formal-item>
        <s:paragraph>
          Return a vector pointing in the same direction as <s:term s:type="expression">v</s:term>
          but with a magnitude of <s:term s:type="constant">1</s:term>.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>reflect</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>reflect Definition</s:formal-item-title>
          <s:verbatim>function reflect (i : vector_2i, n : vector_2i) : vector_2i</s:verbatim>
        </s:formal-item>
        <s:paragraph> 
          Return the reflection of the incident vector 
          <s:term s:type="expression">i</s:term> with respect to the vector <s:term s:type="expression">n</s:term>,
          as given by <s:term s:type="expression">i - 2.0 ‚úï dot(n, i) ‚úï n</s:term>.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>refract</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>refract Definition</s:formal-item-title>
          <s:verbatim>function refract (i : vector_2i, n : vector_2i, e : float) : vector_2i</s:verbatim>
        </s:formal-item>
        <s:paragraph> 
          Return the refraction vector of the incident vector 
          <s:term s:type="expression">i</s:term> with respect to the vector <s:term s:type="expression">n</s:term>,
          with the given ratio of indices of refraction <s:term s:type="expression">e</s:term>.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>subtract</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>subtract Definition</s:formal-item-title>
          <s:verbatim>function subtract (v0 : vector_2i, v1 : vector_2i) : vector_2i</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise subtraction <s:term s:type="expression">v0 - v1</s:term>.</s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="spec.stdlib.com.io7m.parasol.Vector3f">
      <s:section-title>Module com.io7m.parasol.Vector3f</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>add</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>add Definition</s:formal-item-title>
          <s:verbatim>function add (v0 : vector_3f, v1 : vector_3f) : vector_3f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise addition  <s:term s:type="expression">v0 + v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>add_scalar</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>add_scalar Definition</s:formal-item-title>
          <s:verbatim>function add_scalar (v : vector_3f, x : integer) : vector_3f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the addition  <s:term s:type="expression">(v[x] + s, v[y] + s, v[z] + s)</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>divide</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>divide Definition</s:formal-item-title>
          <s:verbatim>function divide (v0 : vector_3f, v1 : vector_3f) : vector_3f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise division  <s:term s:type="expression">v0 / v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>divide_scalar</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>divide_scalar Definition</s:formal-item-title>
          <s:verbatim>function divide_scalar (v : vector_3f, x : integer) : vector_3f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the division  <s:term s:type="expression">(v[x] / s, v[y] / s, v[z] / s)</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>cross</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>cross Definition</s:formal-item-title>
          <s:verbatim>function cross (v0 : vector_3f, v1 : vector_3f) : vector_3f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the cross product <s:term s:type="expression">v0 ‚úï v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>dot</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>dot Definition</s:formal-item-title>
          <s:verbatim>function dot (v0 : vector_3f, v1 : vector_3f) : integer</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the dot product <s:term s:type="expression">v0 ‚ãÖ v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>interpolate</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>interpolate Definition</s:formal-item-title>
          <s:verbatim>function interpolate (v0 : vector_3f, v1 : vector_3f, t : float) : vector_3f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the linear interpolation <s:term s:type="expression">(v0 ‚úï t) + (v1 ‚úï (1 - t))</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>magnitude</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>magnitude Definition</s:formal-item-title>
          <s:verbatim>function magnitude (v : vector_3f) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the magnitude of <s:term s:type="expression">v</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>multiply</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>multiply Definition</s:formal-item-title>
          <s:verbatim>function multiply (v0 : vector_3f, v1 : vector_3f) : vector_3f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise multiplication <s:term s:type="expression">v0 ‚úï v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>multiply_scalar</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>multiply_scalar Definition</s:formal-item-title>
          <s:verbatim>function multiply_scalar (v0 : vector_3f, x : float) : vector_3f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the multiplication <s:term s:type="expression">(v[x] ‚úï s, v[y] ‚úï s, v[z] ‚úï s)</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>negate</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>negate Definition</s:formal-item-title>
          <s:verbatim>function negate (v : vector_3f) : vector_3f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise negation <s:term s:type="expression">-v</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>normalize</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>normalize Definition</s:formal-item-title>
          <s:verbatim>function normalize (v : vector_3f) : vector_3f</s:verbatim>
        </s:formal-item>
        <s:paragraph>
          Return a vector pointing in the same direction as <s:term s:type="expression">v</s:term>
          but with a magnitude of <s:term s:type="constant">1</s:term>.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>reflect</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>reflect Definition</s:formal-item-title>
          <s:verbatim>function reflect (i : vector_3f, n : vector_3f) : vector_3f</s:verbatim>
        </s:formal-item>
        <s:paragraph> 
          Return the reflection of the incident vector 
          <s:term s:type="expression">i</s:term> with respect to the vector <s:term s:type="expression">n</s:term>,
          as given by <s:term s:type="expression">i - 2.0 ‚úï dot(n, i) ‚úï n</s:term>.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>refract</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>refract Definition</s:formal-item-title>
          <s:verbatim>function refract (i : vector_3f, n : vector_3f, e : float) : vector_3f</s:verbatim>
        </s:formal-item>
        <s:paragraph> 
          Return the refraction vector of the incident vector 
          <s:term s:type="expression">i</s:term> with respect to the vector <s:term s:type="expression">n</s:term>,
          with the given ratio of indices of refraction <s:term s:type="expression">e</s:term>.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>subtract</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>subtract Definition</s:formal-item-title>
          <s:verbatim>function subtract (v0 : vector_3f, v1 : vector_3f) : vector_3f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise subtraction <s:term s:type="expression">v0 - v1</s:term>.</s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="spec.stdlib.com.io7m.parasol.Vector3i">
      <s:section-title>Module com.io7m.parasol.Vector3i</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>add</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>add Definition</s:formal-item-title>
          <s:verbatim>function add (v0 : vector_3i, v1 : vector_3i) : vector_3i</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise addition  <s:term s:type="expression">v0 + v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>add_scalar</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>add_scalar Definition</s:formal-item-title>
          <s:verbatim>function add_scalar (v : vector_3i, x : integer) : vector_3i</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the addition  <s:term s:type="expression">(v[x] + s, v[y] + s, v[z] + s)</s:term>.</s:paragraph>
      </s:subsection>
      
      <s:subsection>
        <s:subsection-title>divide</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>divide Definition</s:formal-item-title>
          <s:verbatim>function divide (v0 : vector_3i, v1 : vector_3i) : vector_3i</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise division  <s:term s:type="expression">v0 / v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>divide_scalar</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>divide_scalar Definition</s:formal-item-title>
          <s:verbatim>function divide_scalar (v : vector_3i, x : integer) : vector_3i</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the division  <s:term s:type="expression">(v[x] / s, v[y] / s, v[z] / s)</s:term>.</s:paragraph>
      </s:subsection>
      
      <s:subsection>
        <s:subsection-title>dot</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>dot Definition</s:formal-item-title>
          <s:verbatim>function dot (v0 : vector_3i, v1 : vector_3i) : integer</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the dot product <s:term s:type="expression">v0 ‚ãÖ v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>interpolate</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>interpolate Definition</s:formal-item-title>
          <s:verbatim>function interpolate (v0 : vector_3i, v1 : vector_3i, t : float) : vector_3i</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the linear interpolation <s:term s:type="expression">(v0 ‚úï t) + (v1 ‚úï (1 - t))</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>magnitude</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>magnitude Definition</s:formal-item-title>
          <s:verbatim>function magnitude (v : vector_3i) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the magnitude of <s:term s:type="expression">v</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>multiply</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>multiply Definition</s:formal-item-title>
          <s:verbatim>function multiply (v0 : vector_3i, v1 : vector_3i) : vector_3i</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise multiplication <s:term s:type="expression">v0 ‚úï v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>multiply_scalar</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>multiply_scalar Definition</s:formal-item-title>
          <s:verbatim>function multiply_scalar (v0 : vector_3i, x : float) : vector_3i</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the multiplication <s:term s:type="expression">(v[x] ‚úï s, v[y] ‚úï s, v[z] ‚úï s)</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>negate</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>negate Definition</s:formal-item-title>
          <s:verbatim>function negate (v : vector_3i) : vector_3i</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise negation <s:term s:type="expression">-v</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>normalize</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>normalize Definition</s:formal-item-title>
          <s:verbatim>function normalize (v : vector_3i) : vector_3i</s:verbatim>
        </s:formal-item>
        <s:paragraph>
          Return a vector pointing in the same direction as <s:term s:type="expression">v</s:term>
          but with a magnitude of <s:term s:type="constant">1</s:term>.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>reflect</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>reflect Definition</s:formal-item-title>
          <s:verbatim>function reflect (i : vector_3i, n : vector_3i) : vector_3i</s:verbatim>
        </s:formal-item>
        <s:paragraph> 
          Return the reflection of the incident vector 
          <s:term s:type="expression">i</s:term> with respect to the vector <s:term s:type="expression">n</s:term>,
          as given by <s:term s:type="expression">i - 2.0 ‚úï dot(n, i) ‚úï n</s:term>.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>refract</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>refract Definition</s:formal-item-title>
          <s:verbatim>function refract (i : vector_3i, n : vector_3i, e : float) : vector_3i</s:verbatim>
        </s:formal-item>
        <s:paragraph> 
          Return the refraction vector of the incident vector 
          <s:term s:type="expression">i</s:term> with respect to the vector <s:term s:type="expression">n</s:term>,
          with the given ratio of indices of refraction <s:term s:type="expression">e</s:term>.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>subtract</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>subtract Definition</s:formal-item-title>
          <s:verbatim>function subtract (v0 : vector_3i, v1 : vector_3i) : vector_3i</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise subtraction <s:term s:type="expression">v0 - v1</s:term>.</s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="spec.stdlib.com.io7m.parasol.Vector4f">
      <s:section-title>Module com.io7m.parasol.Vector4f</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>add</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>add Definition</s:formal-item-title>
          <s:verbatim>function add (v0 : vector_4f, v1 : vector_4f) : vector_4f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise addition  <s:term s:type="expression">v0 + v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>add_scalar</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>add_scalar Definition</s:formal-item-title>
          <s:verbatim>function add_scalar (v : vector_4f, x : integer) : vector_4f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the addition <s:term s:type="expression">(v[x] + s, v[y] + s, v[z] + s, v[w] + s)</s:term>.</s:paragraph>
      </s:subsection>

      <s:subsection>
        <s:subsection-title>divide</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>divide Definition</s:formal-item-title>
          <s:verbatim>function divide (v0 : vector_4f, v1 : vector_4f) : vector_4f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise division  <s:term s:type="expression">v0 / v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>divide_scalar</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>divide_scalar Definition</s:formal-item-title>
          <s:verbatim>function divide_scalar (v : vector_4f, x : integer) : vector_4f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the division <s:term s:type="expression">(v[x] / s, v[y] / s, v[z] / s, v[w] / s)</s:term>.</s:paragraph>
      </s:subsection>
      
      <s:subsection>
        <s:subsection-title>dot</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>dot Definition</s:formal-item-title>
          <s:verbatim>function dot (v0 : vector_4f, v1 : vector_4f) : integer</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the dot product <s:term s:type="expression">v0 ‚ãÖ v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>interpolate</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>interpolate Definition</s:formal-item-title>
          <s:verbatim>function interpolate (v0 : vector_4f, v1 : vector_4f, t : float) : vector_4f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the linear interpolation <s:term s:type="expression">(v0 ‚úï t) + (v1 ‚úï (1 - t))</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>magnitude</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>magnitude Definition</s:formal-item-title>
          <s:verbatim>function magnitude (v : vector_4f) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the magnitude of <s:term s:type="expression">v</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>multiply</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>multiply Definition</s:formal-item-title>
          <s:verbatim>function multiply (v0 : vector_4f, v1 : vector_4f) : vector_4f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise multiplication <s:term s:type="expression">v0 ‚úï v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>multiply_scalar</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>multiply_scalar Definition</s:formal-item-title>
          <s:verbatim>function multiply_scalar (v0 : vector_4f, x : float) : vector_4f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the multiplication <s:term s:type="expression">(v[x] ‚úï s, v[y] ‚úï s, v[z] ‚úï s, v[w] ‚úï s)</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>negate</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>negate Definition</s:formal-item-title>
          <s:verbatim>function negate (v : vector_4f) : vector_4f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise negation <s:term s:type="expression">-v</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>normalize</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>normalize Definition</s:formal-item-title>
          <s:verbatim>function normalize (v : vector_4f) : vector_4f</s:verbatim>
        </s:formal-item>
        <s:paragraph>
          Return a vector pointing in the same direction as <s:term s:type="expression">v</s:term>
          but with a magnitude of <s:term s:type="constant">1</s:term>.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>reflect</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>reflect Definition</s:formal-item-title>
          <s:verbatim>function reflect (i : vector_4f, n : vector_4f) : vector_4f</s:verbatim>
        </s:formal-item>
        <s:paragraph> 
          Return the reflection of the incident vector 
          <s:term s:type="expression">i</s:term> with respect to the vector <s:term s:type="expression">n</s:term>,
          as given by <s:term s:type="expression">i - 2.0 ‚úï dot(n, i) ‚úï n</s:term>.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>refract</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>refract Definition</s:formal-item-title>
          <s:verbatim>function refract (i : vector_4f, n : vector_4f, e : float) : vector_4f</s:verbatim>
        </s:formal-item>
        <s:paragraph> 
          Return the refraction vector of the incident vector 
          <s:term s:type="expression">i</s:term> with respect to the vector <s:term s:type="expression">n</s:term>,
          with the given ratio of indices of refraction <s:term s:type="expression">e</s:term>.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>subtract</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>subtract Definition</s:formal-item-title>
          <s:verbatim>function subtract (v0 : vector_4f, v1 : vector_4f) : vector_4f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise subtraction <s:term s:type="expression">v0 - v1</s:term>.</s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="spec.stdlib.com.io7m.parasol.Vector4i">
      <s:section-title>Module com.io7m.parasol.Vector4i</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>add</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>add Definition</s:formal-item-title>
          <s:verbatim>function add (v0 : vector_4i, v1 : vector_4i) : vector_4i</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise addition  <s:term s:type="expression">v0 + v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>add_scalar</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>add_scalar Definition</s:formal-item-title>
          <s:verbatim>function add_scalar (v : vector_4i, x : integer) : vector_4i</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the addition  <s:term s:type="expression">(v[x] + s, v[y] + s, v[z] + s, v[w] + s)</s:term>.</s:paragraph>
      </s:subsection>

      <s:subsection>
        <s:subsection-title>divide</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>divide Definition</s:formal-item-title>
          <s:verbatim>function divide (v0 : vector_4i, v1 : vector_4i) : vector_4i</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise division  <s:term s:type="expression">v0 / v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>divide_scalar</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>divide_scalar Definition</s:formal-item-title>
          <s:verbatim>function divide_scalar (v : vector_4i, x : integer) : vector_4i</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the division  <s:term s:type="expression">(v[x] / s, v[y] / s, v[z] / s, v[w] / s)</s:term>.</s:paragraph>
      </s:subsection>

      <s:subsection>
        <s:subsection-title>dot</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>dot Definition</s:formal-item-title>
          <s:verbatim>function dot (v0 : vector_4i, v1 : vector_4i) : integer</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the dot product <s:term s:type="expression">v0 ‚ãÖ v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>interpolate</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>interpolate Definition</s:formal-item-title>
          <s:verbatim>function interpolate (v0 : vector_4i, v1 : vector_4i, t : float) : vector_4i</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the linear interpolation <s:term s:type="expression">(v0 ‚úï t) + (v1 ‚úï (1 - t))</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>magnitude</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>magnitude Definition</s:formal-item-title>
          <s:verbatim>function magnitude (v : vector_4i) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the magnitude of <s:term s:type="expression">v</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>multiply</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>multiply Definition</s:formal-item-title>
          <s:verbatim>function multiply (v0 : vector_4i, v1 : vector_4i) : vector_4i</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise multiplication <s:term s:type="expression">v0 ‚úï v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>multiply_scalar</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>multiply_scalar Definition</s:formal-item-title>
          <s:verbatim>function multiply_scalar (v0 : vector_4i, x : float) : vector_4i</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the multiplication <s:term s:type="expression">(v[x] ‚úï s, v[y] ‚úï s, v[z] ‚úï s, v[w] ‚úï s)</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>negate</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>negate Definition</s:formal-item-title>
          <s:verbatim>function negate (v : vector_4i) : vector_4i</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise negation <s:term s:type="expression">-v</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>normalize</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>normalize Definition</s:formal-item-title>
          <s:verbatim>function normalize (v : vector_4i) : vector_4i</s:verbatim>
        </s:formal-item>
        <s:paragraph>
          Return a vector pointing in the same direction as <s:term s:type="expression">v</s:term>
          but with a magnitude of <s:term s:type="constant">1</s:term>.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>reflect</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>reflect Definition</s:formal-item-title>
          <s:verbatim>function reflect (i : vector_4i, n : vector_4i) : vector_4i</s:verbatim>
        </s:formal-item>
        <s:paragraph> 
          Return the reflection of the incident vector 
          <s:term s:type="expression">i</s:term> with respect to the vector <s:term s:type="expression">n</s:term>,
          as given by <s:term s:type="expression">i - 2.0 ‚úï dot(n, i) ‚úï n</s:term>.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>refract</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>refract Definition</s:formal-item-title>
          <s:verbatim>function refract (i : vector_4i, n : vector_4i, e : float) : vector_4i</s:verbatim>
        </s:formal-item>
        <s:paragraph> 
          Return the refraction vector of the incident vector 
          <s:term s:type="expression">i</s:term> with respect to the vector <s:term s:type="expression">n</s:term>,
          with the given ratio of indices of refraction <s:term s:type="expression">e</s:term>.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>subtract</s:subsection-title>
        <s:formal-item s:kind="specifications">
          <s:formal-item-title>subtract Definition</s:formal-item-title>
          <s:verbatim>function subtract (v0 : vector_4i, v1 : vector_4i) : vector_4i</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise subtraction <s:term s:type="expression">v0 - v1</s:term>.</s:paragraph>
      </s:subsection>
    </s:section>
  </s:part>

  <s:part>
    <s:part-title>Appendices</s:part-title>
    <s:part-contents/>
    <s:section>
      <s:section-title>EBNF Grammar</s:section-title>
      <s:paragraph>
        The full EBNF grammar of the language is as follows:
      </s:paragraph>
      <s:formal-item s:kind="specifications">
        <s:formal-item-title>EBNF Grammar</s:formal-item-title>
        <s:verbatim><![CDATA[
(* Terminals *)

digit_nonzero =
  "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;

digit =
  "0" | digit_nonzero ;

letter_lower =
  "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" |
  "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" |
  "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" |
  "y" | "z" ;

letter_upper =
  "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" |
  "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" |
  "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" |
  "Y" | "Z" ;

letter =
  letter_lower | letter_upper ;

name_lower =
  letter_lower , { letter | digit | "-" | "_" } ;

name_upper =
  letter_upper , { letter | digit | "-" | "_" } ;

integer_literal =
  "0" | ( ["-"] , digit_nonzero , { digit } ) ;

real_literal =
  ["-"] , digit , { digit } , "." , digit , { digit } ;

boolean_literal =
  "true" | "false" ;

(* Non-terminals *)

package_path =
  name_lower , { "." , name_lower } ;

package_declaration =
  "package" , package_path ;

import_path =
  package_path , "." , name_upper ;

import_declaration =
  "import" , import_path , [ "as" , name_upper ] ;

import_declarations =
  { import_declaration , ";" } ;

type_path =
    name_lower
  | name_upper , "." , name_lower ;

term_path =
    name_lower
  | name_upper , "." , name_lower ;

shader_path =
    name_lower
  | name_upper , "." , name_lower ;

value_declaration =
  "value" , name_lower , [ ":" , type_path ] , "=" , expression ;

value_declarations =
  { value_declaration , ";" } ;

function_formal_parameter =
  name_lower , ":" , type_path ;

function_formal_parameters =
  "(" , function_formal_parameter, { "," , function_formal_parameter } , ")" ;

function_declaration =
  "function" , name_lower , function_formal_parameters , ":" , type_path , "=" , expression ;

term_declaration =
  value_declaration | function_declaration ;

record_type_field =
  name_lower , ":" , type_path ;

record_type_expression =
  "record" , record_type_field , { "," , record_type_field } , "end" ;

type_declaration =
  "type" , name_lower , "is" , type_expression ;

type_declarations =
  { type_declaration , ";" } ;

type_expression =
  record_type_expression
  ;

variable_or_application_expression =
  term_path [ "(" , expression , { "," , expression } , ")" ]
  ;

new_parameters =
  "(" , expression , { "," , expression } , ")" ;

new_expression =
  "new" , type_path , new_parameters ;

record_expression_fields =
  "{" , name_lower , "=" , expression , { "," name_lower , "=" , expression } , "}" ;

record_expression =
  "record" , type_path , record_expression_fields ;

local_declaration =
  "value" , name_lower , [ ":" , type_path ] , "=" , expression ;

local_declarations =
  local_declaration , ";" , { local_declarations } ;

let_expression =
  "let" , local_declarations , "in" , expression , "end" ;

conditional_expression =
  "if" , expression , "then" , expression , "else" , expression , "end" ;

expression_pre =
    integer_literal
  | real_literal
  | boolean_literal
  | variable_or_application_expression
  | conditional_expression
  | let_expression
  | new_expression
  | record_expression
  ;

expression_projection =
  "." , name_lower ;

expression_swizzle_names =
  "[" , name_lower , { "," , name_lower } , "]" ;

expression =
  expression_pre , { expression_swizzle | expression_projection } ;

shader_parameter_declaration =
  "parameter" , name_lower , ":" , type_path ;

shader_vertex_input_declaration =
  "in" , name_lower , ":" , type_path ;

shader_vertex_output_declaration =
  "out" , name_lower , ":" , type_path ;

shader_vertex_output_main_declaration =
  "out" , "vertex" , name_lower , ":" , type_path ;

shader_vertex_parameter =
    shader_parameter_declaration
  | shader_vertex_input_declaration
  | shader_vertex_output_declaration
  | shader_vertex_output_main_declaration ;

shader_vertex_parameters =
  { shader_vertex_parameter , ";" } ;

shader_vertex_output_assignment =
  "out" , name_lower , "=" , term_path ;

shader_vertex_output_assignments =
  shader_vertex_output_assignment , ";" , { shader_vertex_output_assignments } ;

shader_vertex_declaration =
  "vertex" , name_lower , "is" ,
  shader_vertex_parameters ,
  [ "with" , local_declarations ] ,
  "as" ,
  shader_vertex_output_assignments ,
  "end" ;

shader_fragment_input_declaration =
  "in" , name_lower , ":" , type_path ;

shader_fragment_output_declaration =
  "out" , name_lower , ":" , type_path , "as" , integer_literal ;

shader_fragment_output_depth_declaration =
  "out" , "depth", name_lower , ":" , type_path ;

shader_fragment_parameter =
    shader_parameter_declaration
  | shader_fragment_input_declaration
  | shader_fragment_output_declaration
  | shader_fragment_output_depth_declaration ;

shader_fragment_parameters =
  { shader_fragment_parameter , ";" } ;

shader_fragment_discard_declaration =
  "discard" , "(" , expression , ")" ;

shader_fragment_local_declaration =
    local_declaration
  | shader_fragment_discard_declaration ;

shader_fragment_local_declarations =
  shader_fragment_local_declaration , ";" , { shader_fragment_local_declarations } ;

shader_fragment_output_assignment =
  "out" , name_lower , "=" , term_path ;

shader_fragment_output_assignments =
  shader_fragment_output_assignment , ";" , { shader_fragment_output_assignments } ;

shader_fragment_declaration =
  "fragment" , name_lower , "is" ,
  shader_fragment_parameters ,
  [ "with" , shader_fragment_local_declarations ] ,
  "as" ,
  shader_fragment_output_assignments ,
  "end" ;

shader_program_declaration =
  "program" , name_lower , "is" ,
  "vertex" , shader_path , ";" ,
  "fragment" , shader_path , ";" ,
  "end" ;

shader_declaration =
  "shader" , ( shader_vertex_declaration | shader_fragment_declaration | shader_program_declaration ) ;

shader_declarations =
  { shader_declaration , ";" } ;

module_level_declarations =
  { value_declarations | function_declarations | type_declarations | shader_declarations } ;

module_declaration =
  "module" , name_upper , "is" ,
  import_declarations ,
  module_level_declarations ,
  "end" ;

module_declarations =
  module_declaration , ";" , { module_declaration , ";" } ;

unit =
  package_declaration , ";" ,
  module_declarations ;
]]></s:verbatim>
      </s:formal-item>
    </s:section>

    <s:section>
      <s:section-title>Type rules</s:section-title>
      <s:paragraph>
        The full type rules for the language are as follows:
      </s:paragraph>
      <s:formal-item s:kind="specifications">
        <s:formal-item-title>Type rules</s:formal-item-title>
        <s:image s:source="png/typing.png">Type rules</s:image>
      </s:formal-item>
    </s:section>

    <s:section>
      <s:section-title>Operational semantics</s:section-title>
      <s:paragraph>
        The full operational semantics for the language are as follows:
      </s:paragraph>
      <s:formal-item s:kind="specifications">
        <s:formal-item-title>Operational semantics</s:formal-item-title>
        <s:image s:source="png/op_semantics.png">Operational semantics</s:image>
      </s:formal-item>
    </s:section>

    <s:section xml:id="spec.glsl-identifiers">
      <s:section-title>GLSL identifiers</s:section-title>
      <s:paragraph>
        The complete list of reserved words in the OpenGL shading language
        as of version 4.3 are:
      </s:paragraph>
      <s:formal-item s:kind="specifications">
        <s:formal-item-title>GLSL identifiers</s:formal-item-title>
<s:list-unordered>
  <s:list-item><s:term s:type="keyword">active</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">asm</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">atomic_uint</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">attribute</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">bool</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">break</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">buffer</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">bvec2</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">bvec3</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">bvec4</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">case</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">cast</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">centroid</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">class</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">coherent</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">common</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">const</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">continue</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">default</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">discard</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">dmat2</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">dmat2x2</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">dmat2x3</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">dmat2x4</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">dmat3</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">dmat3x2</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">dmat3x3</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">dmat3x4</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">dmat4</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">dmat4x2</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">dmat4x3</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">dmat4x4</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">do</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">double</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">dvec2</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">dvec3</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">dvec4</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">else</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">enum</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">extern</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">external</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">false</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">filter</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">fixed</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">flat</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">float</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">for</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">fvec2</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">fvec3</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">fvec4</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">goto</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">half</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">highp</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">hvec2</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">hvec3</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">hvec4</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">if</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">iimage1D</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">iimage1DArray</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">iimage2D</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">iimage2DArray</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">iimage2DMS</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">iimage2DMSArray</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">iimage2DRect</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">iimage3D</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">iimageBuffer</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">iimageCube</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">iimageCubeArray</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">image1D</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">image1DArray</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">image2D</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">image2DArray</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">image2DMS</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">image2DMSArray</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">image2DRect</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">image3D</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">imageBuffer</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">imageCube</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">imageCubeArray</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">in</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">inline</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">inout</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">input</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">int</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">interface</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">invariant</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">isampler1D</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">isampler1DArray</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">isampler2D</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">isampler2DArray</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">isampler2DMS</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">isampler2DMSArray</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">isampler2DRect</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">isampler3D</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">isamplerBuffer</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">isamplerCube</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">isamplerCubeArray</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">ivec2</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">ivec3</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">ivec4</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">layout</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">long</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">lowp</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">mat2</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">mat2x2</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">mat2x3</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">mat2x4</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">mat3</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">mat3x2</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">mat3x3</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">mat3x4</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">mat4</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">mat4x2</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">mat4x3</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">mat4x4</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">mediump</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">namespace</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">noinline</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">noperspective</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">out</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">output</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">packed</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">partition</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">patch</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">precision</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">public</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">readonly</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">resource</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">restrict</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">return</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">row_major</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">sample</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">sampler1D</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">sampler1DArray</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">sampler1DArrayShadow</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">sampler1DShadow</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">sampler2D</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">sampler2DArray</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">sampler2DArrayShadow</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">sampler2DMS</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">sampler2DMSArray</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">sampler2DRect</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">sampler2DRectShadow</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">sampler2DShadow</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">sampler3D</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">sampler3DRect</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">samplerBuffer</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">samplerCube</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">samplerCubeArray</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">samplerCubeArrayShadow</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">samplerCubeShadow</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">shared</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">short</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">sizeof</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">smooth</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">static</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">struct</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">subroutine</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">superp</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">switch</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">template</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">this</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">true</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">typedef</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">uimage1D</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">uimage1DArray</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">uimage2D</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">uimage2DArray</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">uimage2DMS</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">uimage2DMSArray</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">uimage2DRect</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">uimage3D</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">uimageBuffer</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">uimageCube</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">uimageCubeArray</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">uint</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">uniform</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">union</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">unsigned</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">usampler1D</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">usampler1DArray</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">usampler2D</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">usampler2DArray</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">usampler2DMS</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">usampler2DMSArray</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">usampler2DRect</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">usampler3D</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">usamplerBuffer</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">usamplerCube</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">usamplerCubeArray</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">using</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">uvec2</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">uvec3</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">uvec4</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">varying</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">vec2</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">vec3</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">vec4</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">void</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">volatile</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">while</s:term></s:list-item>
  <s:list-item><s:term s:type="keyword">writeonly</s:term></s:list-item>
</s:list-unordered>
      </s:formal-item>
    </s:section>

    <s:section>
      <s:section-title>Lists</s:section-title>
      <s:formal-item s:kind="lists">
        <s:formal-item-title>List of specifications</s:formal-item-title>
        <s:formal-item-list s:kind="specifications"/>
      </s:formal-item>
      <s:formal-item s:kind="lists">
        <s:formal-item-title>List of examples</s:formal-item-title>
        <s:formal-item-list s:kind="examples"/>
      </s:formal-item>
    </s:section>
  </s:part>

</s:document>
