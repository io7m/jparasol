<?xml version="1.0" encoding="UTF-8"?>

<!--
  Copyright ¬© 2013 <code@io7m.com> http://io7m.com

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  -->

<s:document
  xmlns:s="http://www.io7m.com/schemas/structural/1.0.0"
  xmlns:xi="http://www.w3.org/2001/XInclude">
  <s:document-title>Parasol Language 1.0.0 Specification</s:document-title>
  <s:document-style>documentation.css</s:document-style>
  <s:document-contents/>

  <s:part xml:id="com.io7m.parasol.1.0.0.notation">
    <s:part-title>Notational Conventions</s:part-title>
    <s:part-contents/>

    <s:section>
      <s:section-title>Unicode</s:section-title>
      <s:paragraph>
        The specification makes reference to the
        <s:link-external target="http://unicode.org">Unicode</s:link-external>
        character set which, at the time of writing, is at version
        <s:term type="constant">6.2.0</s:term>. The specification
        often references specific Unicode characters, and does so using
        the standard notation <s:term type="expression">U+NNNN</s:term>,
        where <s:term type="variable">N</s:term> represents a hexadecimal
        digit. For example, <s:term type="constant">U+03BB</s:term>
        corresponds to the lowercase lambda symbol <s:term type="constant">Œª</s:term>.
      </s:paragraph>
    </s:section>

    <s:section>
      <s:section-title>EBNF</s:section-title>
      <s:paragraph>
        The specification gives grammar definitions in
        <s:term type="package">ISO/IEC 14977:1996</s:term> Extended Backus-Naur
        form.
      </s:paragraph>
    </s:section>

    <s:section>
      <s:section-title>Logic</s:section-title>
      <s:paragraph>
        The specification uses the following notation from
        propositional logic<s:footnote>
          <s:link-external target="http://en.wikipedia.org/wiki/Propositional_logic">http://en.wikipedia.org/wiki/Propositional_logic</s:link-external>
        </s:footnote>.
        A summary of the notation used is as follows:
      </s:paragraph>
      <s:formal-item kind="notations" type="notations">
        <s:formal-item-title>Set notations</s:formal-item-title>
        <s:table>
          <s:table-summary>Set notations</s:table-summary>
          <s:table-head>
            <s:table-column-name>Notation</s:table-column-name>
            <s:table-column-name>Description</s:table-column-name>
          </s:table-head>
          <s:table-body>
            <s:table-row>
              <s:table-cell><s:term type="expression">‚àÄx. P x</s:term></s:table-cell>
              <s:table-cell>Universal quantification; for all <s:term type="expression">x</s:term> the proposition <s:term type="expression">P</s:term> holds for <s:term type="expression">x</s:term></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="expression">‚àÉx. P x</s:term></s:table-cell>
              <s:table-cell>Existential quantification; there exists some <s:term type="expression">x</s:term> such that the proposition <s:term type="expression">P</s:term> holds for <s:term type="expression">x</s:term></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="expression">P ‚áí Q</s:term></s:table-cell>
              <s:table-cell>Implication; <s:term type="expression">P</s:term> implies <s:term type="expression">Q</s:term></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="expression">P ‚ãÄ Q</s:term></s:table-cell>
              <s:table-cell>Conjunction; <s:term type="expression">P</s:term> and <s:term type="expression">Q</s:term></s:table-cell>
            </s:table-row>
          </s:table-body>
        </s:table>
      </s:formal-item>
    </s:section>

    <s:section>
      <s:section-title>Sets</s:section-title>
      <s:paragraph>
        Where the specification refers to <s:term type="term">sets</s:term>, it
        is referring to sets as defined in ZFC<s:footnote>
          <s:link-external target="http://en.wikipedia.org/wiki/Zermelo-Fraenkel_set_theory">http://en.wikipedia.org/wiki/Zermelo-Fraenkel_set_theory</s:link-external>
        </s:footnote>.
      </s:paragraph>

      <s:formal-item kind="notations" type="notations">
        <s:formal-item-title>Set notations</s:formal-item-title>
        <s:table>
          <s:table-summary>Set notations</s:table-summary>
          <s:table-head>
            <s:table-column-name>Notation</s:table-column-name>
            <s:table-column-name>Description</s:table-column-name>
          </s:table-head>
          <s:table-body>
            <s:table-row>
              <s:table-cell><s:term type="expression">e ‚àà A</s:term></s:table-cell>
              <s:table-cell><s:term type="expression">e</s:term> is an element of the set <s:term type="expression">A</s:term></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="expression">e ‚àâ A</s:term></s:table-cell>
              <s:table-cell><s:term type="expression">e</s:term> is not an element of the set <s:term type="expression">A</s:term></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="expression">{ x‚ÇÄ, x‚ÇÅ, ... x‚Çô }</s:term></s:table-cell>
              <s:table-cell>A set consisting of values from <s:term type="expression">x‚ÇÄ</s:term> to <s:term type="expression">x‚Çô</s:term></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="expression">{ e ‚àà A | p(e) }</s:term></s:table-cell>
              <s:table-cell>A set consisting of the elements of <s:term type="expression">A</s:term> for which the proposition <s:term type="expression">p</s:term> holds</s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="expression">|A|</s:term></s:table-cell>
              <s:table-cell>The cardinality of the set <s:term type="expression">A</s:term>; a measure of the number of elements in <s:term type="expression">A</s:term></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="expression">‚àÖ</s:term></s:table-cell>
              <s:table-cell>The empty set</s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="expression">ùîπ</s:term></s:table-cell>
              <s:table-cell>The booleans</s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="expression">‚Ñï</s:term></s:table-cell>
              <s:table-cell>The natural numbers</s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="expression">‚Ñù</s:term></s:table-cell>
              <s:table-cell>The real numbers</s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="expression">‚Ñ§</s:term></s:table-cell>
              <s:table-cell>The integers</s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="expression">[a, b]</s:term></s:table-cell>
              <s:table-cell>A closed interval in a set (given separately or implicit from the types of <s:term type="expression">a</s:term> and <s:term type="expression">b</s:term>), from <s:term type="expression">a</s:term> to <s:term type="expression">b</s:term>, including <s:term type="expression">a</s:term> and <s:term type="expression">b</s:term></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="expression">(a, b]</s:term></s:table-cell>
              <s:table-cell>A closed interval in a set (given separately or implicit from the types of <s:term type="expression">a</s:term> and <s:term type="expression">b</s:term>), from <s:term type="expression">a</s:term> to <s:term type="expression">b</s:term>, excluding <s:term type="expression">a</s:term> but including <s:term type="expression">b</s:term></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="expression">[a, b)</s:term></s:table-cell>
              <s:table-cell>A closed interval in a set (given separately or implicit from the types of <s:term type="expression">a</s:term> and <s:term type="expression">b</s:term>), from <s:term type="expression">a</s:term> to <s:term type="expression">b</s:term>, including <s:term type="expression">a</s:term> but excluding <s:term type="expression">b</s:term></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="expression">(a, b)</s:term></s:table-cell>
              <s:table-cell>A closed interval in a set (given separately or implicit from the types of <s:term type="expression">a</s:term> and <s:term type="expression">b</s:term>), from <s:term type="expression">a</s:term> to <s:term type="expression">b</s:term>, excluding <s:term type="expression">a</s:term> and <s:term type="expression">b</s:term></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="expression">A ‚äÇ B</s:term></s:table-cell>
              <s:table-cell><s:term type="expression">A</s:term> is a subset of, and is not equal to, <s:term type="expression">B</s:term></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="expression">A ‚äÜ B</s:term></s:table-cell>
              <s:table-cell><s:term type="expression">A</s:term> is a subset of, or is equal to, <s:term type="expression">B</s:term></s:table-cell>
            </s:table-row>
          </s:table-body>
        </s:table>
      </s:formal-item>
    </s:section>

    <s:section>
      <s:section-title>Tuples</s:section-title>
      <s:paragraph>
        The notation <s:term type="expression">tuples(S, N)</s:term> denotes the
        set of n-tuples of length <s:term type="variable">N</s:term> of elements
        taken from the set <s:term type="variable">S</s:term>, where
        <s:term type="variable">N</s:term> is non-negative. For a given set
        <s:term type="variable">S</s:term>, the set of n-tuples may be defined
        inductively as follows:
      </s:paragraph>
      <s:formal-item kind="specifications" type="specifications">
        <s:formal-item-title>Tuples</s:formal-item-title>
        <s:list-unordered>
          <s:list-item>
            <s:term type="expression">tuples(S, 0)</s:term> is the set of
            0-tuples, containing one element denoted <s:term type="expression">()</s:term>.
          </s:list-item>
          <s:list-item>
            <s:term type="expression">tuples(S, N)</s:term> is an ordered pair
            <s:term type="expression">(x, tuples(S, N - 1))</s:term> where
            <s:term type="expression">x ‚àà S</s:term>.
          </s:list-item>
        </s:list-unordered>
      </s:formal-item>
      <s:paragraph>
        Some example sets of n-tuples are as follows:
      </s:paragraph>
      <s:formal-item kind="examples" type="examples">
        <s:formal-item-title>Example n-tuple sets</s:formal-item-title>
        <s:verbatim><![CDATA[S = { 1, 2, 3 }

tuples(S, 0) = { () }

tuples(S, 1) = {
  (1, ()),
  (2, ()),
  (3, ())
}

tuples(S, 2) = {
  (1, (1, ())),
  (2, (1, ())),
  (3, (1, ())),
  (1, (2, ())),
  (2, (2, ())),
  (3, (2, ())),
  (1, (3, ())),
  (2, (3, ())),
  (3, (3, ()))
}]]></s:verbatim>
      </s:formal-item>
      <s:paragraph>
        Specific n-tuples are denoted <s:term type="expression">P = (x‚ÇÄ, x‚ÇÅ, ..., x‚Çô)</s:term>,
        which is essentially shorthand for <s:term type="expression">P = (x‚ÇÄ, (x‚ÇÅ, (... (x‚Çô, ()))))</s:term>,
        with the <s:term type="expression">0th</s:term> element of
        <s:term type="expression">P</s:term> being <s:term type="expression">x‚ÇÄ</s:term> and
        the <s:term type="expression">nth</s:term> element being
        <s:term type="expression">x‚Çô</s:term>.
      </s:paragraph>
    </s:section>

    <s:section>
      <s:section-title>Types</s:section-title>
      <s:paragraph>
        The specification (and the <s:term type="package">parasol</s:term> language itself)
        uses notation and concepts taken from type theory
        <s:footnote>
          <s:link-external target="http://en.wikipedia.org/wiki/Type_theory">https://en.wikipedia.org/wiki/Type_theory</s:link-external>
        </s:footnote>.
        A summary of the notation used is as follows:
      </s:paragraph>
      <s:formal-item kind="notations" type="notations">
        <s:formal-item-title>Type notation</s:formal-item-title>
        <s:table>
          <s:table-summary>Type notation</s:table-summary>
          <s:table-head>
            <s:table-column-name>Notation</s:table-column-name>
            <s:table-column-name>Description</s:table-column-name>
            <s:table-column-name>Example</s:table-column-name>
          </s:table-head>
          <s:table-body>
            <s:table-row>
              <s:table-cell><s:term type="expression">x : A</s:term></s:table-cell>
              <s:table-cell>The term <s:term type="variable">x</s:term> is of type <s:term type="variable">A</s:term></s:table-cell>
              <s:table-cell><s:term type="expression">23 : ‚Ñï</s:term></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="expression">A ‚Üí B</s:term></s:table-cell>
              <s:table-cell>The type of functions from values of type <s:term type="variable">A</s:term> to values of type <s:term type="variable">B</s:term></s:table-cell>
              <s:table-cell><s:term type="expression">even : ‚Ñï ‚Üí ùîπ</s:term></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="expression">A √ó B</s:term></s:table-cell>
              <s:table-cell>The type of products of <s:term type="variable">A</s:term> and <s:term type="variable">B</s:term></s:table-cell>
              <s:table-cell><s:term type="expression">(23, true) : ‚Ñï √ó ùîπ</s:term></s:table-cell>
            </s:table-row>
          </s:table-body>
        </s:table>
      </s:formal-item>
      <s:paragraph>
        Product types are typically used to encode the notion of
        <s:term type="term">n-ary functions</s:term>,
        where <s:term type="expression">(A √ó B √ó C) ‚Üí D</s:term>
        is the type of functions that take three arguments of types
        <s:term type="expression">A</s:term>, <s:term type="expression">B</s:term>,
        and <s:term type="expression">C</s:term>, respectively, and return
        values of type <s:term type="expression">D</s:term>.
      </s:paragraph>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.notation.type_rules">
      <s:section-title>Type rules</s:section-title>
      <s:paragraph>
        Declarative type rules describe the precise rules for assigning
        <s:term type="term">types</s:term> to <s:term type="term">terms</s:term>.
        If no type rule matches a term, then that term is considered ill-typed.
      </s:paragraph>
      <s:paragraph>
        Type rules are given as zero or more <s:term type="term">premises</s:term>,
        and a single <s:term type="term">conclusion</s:term>, separated by a horizontal
        line. For a given rule, when all of the <s:term type="term">premises</s:term>
        are true, then the <s:term type="term">conclusion</s:term> is true. If a rule
        has no <s:term type="term">premises</s:term> then the rule is taken as an
        <s:term type="term">axiom</s:term>.
      </s:paragraph>
      <s:paragraph>
        The <s:term type="term">gamma</s:term> symbol <s:term type="constant">Œì</s:term>
        (<s:term type="constant">U+0393</s:term>)
        represents the current <s:term type="term">typing environment</s:term> and
        can be thought of as a mapping from distinct variables to their types, with
        the set of variables in environment denoted by <s:term type="expression">dom(Œì)</s:term>
        (the domain of <s:term type="constant">Œì</s:term>). The notation
        <s:term type="expression">Œì ‚ä¢ P</s:term> reads "<s:term type="expression">Œì</s:term>
        <s:term type="term">implies</s:term>
        <s:term type="expression">P</s:term>" and is used in type rules to assign types to terms.
        The empty typing environment is represented by <s:term type="constant">‚àÖ</s:term>
        (<s:term type="constant">U+2205</s:term>). The <s:term type="term">diamond</s:term> symbol
        <s:term type="constant">‚óá</s:term> (<s:term type="constant">U+25C7</s:term>)
        should be read as "is well-formed", so <s:term type="expression">Œì ‚ä¢ ‚óá</s:term>
        should be read as "the current typing environment is well-formed". The concept
        of well-formedness is often type-system-specific and is usually described when
        the rules are given. A summary of the notation is as follows:
      </s:paragraph>
      <s:formal-item kind="notations" type="notations">
        <s:formal-item-title>Type rule notation</s:formal-item-title>
        <s:table>
          <s:table-summary>Type rule notation</s:table-summary>
          <s:table-head>
            <s:table-column-name>Notation</s:table-column-name>
            <s:table-column-name>Description</s:table-column-name>
            <s:table-column-name>Example</s:table-column-name>
          </s:table-head>
          <s:table-body>
            <s:table-row>
              <s:table-cell><s:term type="constant">Œì</s:term></s:table-cell>
              <s:table-cell>The current typing environment</s:table-cell>
              <s:table-cell><s:term type="expression">Œì</s:term></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="constant">‚àÖ</s:term></s:table-cell>
              <s:table-cell>The empty typing environment</s:table-cell>
              <s:table-cell><s:term type="expression">‚àÖ</s:term></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="expression">Œì, x</s:term></s:table-cell>
              <s:table-cell>The typing environment <s:term type="constant">Œì</s:term>
                extended with the variable <s:term type="expression">x</s:term>
                <s:footnote>
                  Usually accompanied with a side condition that
                  <s:term type="variable">x</s:term> does not appear in
                  <s:term type="expression">dom(Œì)</s:term>)
                </s:footnote>
              </s:table-cell>
              <s:table-cell><s:term type="expression">Œì, x</s:term> where <s:term type="expression">x ‚àâ dom(Œì)</s:term></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="expression">dom(Œì)</s:term></s:table-cell>
              <s:table-cell>The set of distinct variables in <s:term type="constant">Œì</s:term></s:table-cell>
              <s:table-cell><s:term type="expression">dom((‚àÖ, x, y)) = { x, y }</s:term></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="expression">Œì ‚ä¢ P</s:term></s:table-cell>
              <s:table-cell>The environment <s:term type="constant">Œì</s:term> implies <s:term type="expression">P</s:term></s:table-cell>
              <s:table-cell><s:term type="expression">Œì ‚ä¢ 23 : ‚Ñï</s:term> (in the current typing environment, <s:term type="expression">23</s:term> is of type <s:term type="expression">‚Ñï</s:term>)</s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="expression">Œì ‚ä¢ ‚óá</s:term></s:table-cell>
              <s:table-cell>The environment <s:term type="constant">Œì</s:term> is <s:term type="term">well-formed</s:term></s:table-cell>
              <s:table-cell><s:term type="expression">‚àÖ ‚ä¢ ‚óá</s:term> (the empty typing environment is well-formed)</s:table-cell>
            </s:table-row>
          </s:table-body>
        </s:table>
      </s:formal-item>
      <s:paragraph>
        An example of typing rules for natural number addition:
      </s:paragraph>
      <s:formal-item kind="examples">
        <s:formal-item-title>Natural number addition typing</s:formal-item-title>
        <s:image source="tyex_typing_example.png">Natural number addition typing</s:image>
      </s:formal-item>
      <s:paragraph>
        The <s:term type="element">empty</s:term> rule states that the empty
        typing environment is well-formed. Because there are no premises above
        the horizontal line, this is taken as an <s:term type="term">axiom</s:term>.
        The <s:term type="element">extension</s:term> rule states that adding
        a term to the typing environment that is not already in that environment,
        results in a well-formed environment.
        The <s:term type="element">natural_intro</s:term> rule states that,
        given a well-formed typing environment, any expression that is
        syntactically a natural number (represented by
        <s:term type="variable">‚Ñï</s:term>) has type
        <s:term type="type">natural</s:term>. The
        <s:term type="element">natural_plus</s:term> rule states that, if variables
        <s:term type="variable">m</s:term> and <s:term type="variable">n</s:term>
        have type <s:term type="type">natural</s:term> in the current typing
        environment, then <s:term type="expression">m + n</s:term> has type
        <s:term type="type">natural</s:term>. When checking the type of the
        expression <s:term type="expression">m + n</s:term>, the rules are used
        to construct a <s:term type="term">derivation tree</s:term> as follows:
      </s:paragraph>
      <s:formal-item kind="examples">
        <s:formal-item-title>Natural number addition derivation</s:formal-item-title>
        <s:image source="tyex_typing_example_derivation.png">Natural number addition derivation</s:image>
      </s:formal-item>
      <s:paragraph>
        Intuitively, a term only has a valid type if there is a sequence of rules
        from the empty environment that can assign a type to the term.
      </s:paragraph>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.notation.op_semantics">
      <s:section-title>Operational Semantics</s:section-title>
      <s:paragraph>
        Operational semantics describe the precise rules for the evaluation
        of expressions in a given language. The rules make up the description
        of an <s:term type="term">abstract machine</s:term> which passes
        through different states, one rule (or <s:term type="term">step</s:term>)
        at a time, until the machine <s:term type="term">halts</s:term>
        and produces a <s:term type="term">value</s:term>.
      </s:paragraph>
      <s:paragraph>
        Typically, operational semantics begin by first giving a set of
        <s:term type="term">values</s:term>, indicating the final results
        of evaluation, and a set of identifiers syntactically identifying
        the set of evaluable <s:term type="term">expressions</s:term>. The
        evaluation rules themselves are given in a style similar to
        <s:link target="com.io7m.parasol.1.0.0.notation.type_rules">type rules</s:link>,
        where a rule applies if the
        <s:term type="term">premises</s:term> above the horizontal line are
        true, and the <s:term type="term">conclusion</s:term> indicates how
        the state of the abstract machine changes when the rule is applied.
      </s:paragraph>
      <s:paragraph>
        As an example, assume a language of conditional expressions.
        An example expression in this language would be:
      </s:paragraph>
      <s:formal-item kind="examples">
        <s:formal-item-title>Conditionals example</s:formal-item-title>
        <s:verbatim><![CDATA[if true then
  if false then
    true
  else
    if
      if true then
        false
      else
        true
      end
    then
      false
    else
      true
    end
  end
else
  true
end]]></s:verbatim>
      </s:formal-item>
      <s:paragraph>
        The <s:term type="term">values</s:term> of this language are
        <s:term type="constant">true</s:term> and <s:term type="constant">false</s:term>.
        The <s:term type="term">expressions</s:term> in this language
        include the <s:term type="term">values</s:term>, and the form
        <s:term type="expression">if e‚ÇÄ then e‚ÇÅ else e‚ÇÇ end</s:term>, where
        <s:term type="expression">e‚ÇÄ</s:term>,
        <s:term type="expression">e‚ÇÅ</s:term> and
        <s:term type="expression">e‚ÇÇ</s:term> are expressions. There
        are clearly multiple ways to evaluate expressions in this language,
        but in order to produce an algorithm that will execute on a computer,
        the evaluation rules should be:
      </s:paragraph>
      <s:formal-item kind="specifications">
        <s:formal-item-title>Evaluation characteristics</s:formal-item-title>
        <s:list-unordered>
          <s:list-item>
            Deterministic. That is, given a non-<s:term type="term">value</s:term> expression
            <s:term type="expression">e</s:term>,
            there must be <s:term type="term">at most</s:term> one evaluation rule that
            applies in order to work towards producing a value from
            <s:term type="expression">e</s:term>. If multiple rules apply, then
            evaluation is nondeterministic.
          </s:list-item>
          <s:list-item>
            Complete. That is, given a non-<s:term type="term">value</s:term> expression
            <s:term type="expression">e</s:term>,
            there must be <s:term type="term">at least</s:term> one evaluation rule that
            applies in order to work towards producing a value from
            <s:term type="expression">e</s:term>. If no rule applies, then
            evaluation is said to be <s:term type="term">stuck</s:term>.
          </s:list-item>
        </s:list-unordered>
      </s:formal-item>
      <s:paragraph>
        The operational semantics for the language could be written as
        follows:
      </s:paragraph>
      <s:formal-item kind="examples">
        <s:formal-item-title>Conditional semantics</s:formal-item-title>
        <s:image source="semantics_example.png">Conditional semantics</s:image>
      </s:formal-item>
      <s:paragraph>
        Expressions are assigned the identifiers
        <s:term type="expression">e‚ÇÄ</s:term> to
        <s:term type="expression">e‚Çô</s:term>, so terms of those forms
        are assumed to be evaluable expressions when they appear in rules.
      </s:paragraph>
      <s:paragraph>
        The notation <s:term type="expression">e ‚Üí e'</s:term> should be
        read "<s:term type="expression">e</s:term> evaluates to <s:term type="expression">e'</s:term>
        in a single step".
      </s:paragraph>
      <s:paragraph>
        The <s:term type="variable">if_true</s:term> rule states that
        if the condition of an <s:term type="keyword">if</s:term> expression
        is exactly <s:term type="constant">true</s:term>, then the expression
        evaluates to the expression given in the left branch, in one step.
      </s:paragraph>
      <s:paragraph>
        The <s:term type="variable">if_false</s:term> rule states that
        if the condition of an <s:term type="keyword">if</s:term> expression
        is exactly <s:term type="constant">false</s:term>, then the expression
        evaluates to the expression given in the right branch, in one step.
      </s:paragraph>
      <s:paragraph>
        The <s:term type="variable">if_condition</s:term> rule states that
        if the condition of an <s:term type="keyword">if</s:term> expression
        is not a value, then the condition is evaluated first.
      </s:paragraph>
      <s:paragraph>
        The example expression given earlier can now be evaluated completely
        and deterministically by following the given rules:
      </s:paragraph>
      <s:formal-item kind="examples">
        <s:formal-item-title>Conditionals example evaluation</s:formal-item-title>
        <s:verbatim><![CDATA[if true then
  if false then
    true
  else
    if
      if true then
        false
      else
        true
      end
    then
      false
    else
      true
    end
  end
else
  true
end

‚Üí by if_true to:

if false then
  true
else
  if
    if true then
      false
    else
      true
    end
  then
    false
  else
    true
  end
end

‚Üí by if_false to:

if
  if true then
    false
  else
    true
  end
then
  false
else
  true
end

‚Üí by if_condition to:

if
  false
then
  false
else
  true
end

‚Üí by if_false to:

true
]]></s:verbatim>
      </s:formal-item>
      <s:paragraph>
        The <s:term type="term">substitution</s:term> notation
        <s:term type="expression">e [x := y]</s:term> denotes
        the expression <s:term type="expression">e</s:term> where all
        occurences (if any) of the variable <s:term type="variable">x</s:term>
        have been replaced with <s:term type="variable">y</s:term>. This
        is used, for example, to describe function evaluation:
      </s:paragraph>
      <s:formal-item kind="examples">
        <s:formal-item-title>Function semantics</s:formal-item-title>
        <s:image source="semantics_example2.png">Function semantics</s:image>
      </s:formal-item>
      <s:paragraph>
        The <s:term type="variable">function_eval_0</s:term> and
        <s:term type="variable">function_eval_1</s:term> rules state that
        expressions are evaluated from left-to-right when applying
        <s:term type="expression">f</s:term> to a pair of arguments.
      </s:paragraph>
      <s:paragraph>
        The <s:term type="variable">function_eval_2</s:term> rule states
        that when all of the expressions passed to <s:term type="expression">f</s:term>
        have been reduced to values, the expression as a whole evaluates to
        the body of <s:term type="expression">f</s:term>, called
        <s:term type="expression">e</s:term>, with occurrences of
        the arguments <s:term type="variable">x</s:term> and
        <s:term type="variable">y</s:term> in
        <s:term type="expression">e</s:term> substituted with their
        values.
      </s:paragraph>
    </s:section>

    <s:section>
      <s:section-title>OpenGL</s:section-title>
      <s:paragraph>
        As the <s:term type="package">parasol</s:term> language is intended
        to be executed on programmable GPUs, familiarity with OpenGL and
        the OpenGL shading language is assumed.
      </s:paragraph>
    </s:section>
  </s:part>

  <s:part xml:id="com.io7m.parasol.1.0.0.lex">
    <s:part-title>Lexical Conventions</s:part-title>
    <s:part-contents/>

    <s:section xml:id="com.io7m.parasol.1.0.0.lex.units">
      <s:section-title>Units</s:section-title>
      <s:paragraph>
        The text of a <s:term type="package">parasol</s:term> program is a combination
        of the texts of separate <s:term type="term">units</s:term>, where a
        <s:term type="term">unit</s:term> typically corresponds to a file in the
        operating system under which the compiler is running.
      </s:paragraph>
      <s:paragraph>
        Units consist of a series of lexical <s:term type="term">tokens</s:term>
        separated by
        <s:link target="com.io7m.parasol.1.0.0.lex.whitespace">whitespace</s:link>.
        What constitutes a <s:term type="term">token</s:term> is the subject of
        the following sections.
      </s:paragraph>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.lex.charset">
      <s:section-title>Character set</s:section-title>
      <s:paragraph>
        The character set used for <s:term type="package">parasol</s:term>
        program source code is UTF-8. Inside of
        <s:link target="com.io7m.parasol.1.0.0.lex.comments">comments</s:link>,
        any Unicode character is permitted. Outside of comments, the subset
        of UTF-8 permitted for use in programs is detailed in the following
        sections.
      </s:paragraph>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.lex.whitespace">
      <s:section-title>Whitespace</s:section-title>
      <s:paragraph>
        The following characters are considered to be whitespace:
      </s:paragraph>
      <s:formal-item kind="specifications" type="specifications">
        <s:formal-item-title>Whitespace</s:formal-item-title>
        <s:table>
          <s:table-summary>Whitespace characters</s:table-summary>
          <s:table-head>
            <s:table-column-name>Codepoint</s:table-column-name>
            <s:table-column-name>Name</s:table-column-name>
          </s:table-head>
          <s:table-body>
            <s:table-row><s:table-cell>U+0009</s:table-cell><s:table-cell>Horizontal tab</s:table-cell></s:table-row>
            <s:table-row><s:table-cell>U+000A</s:table-cell><s:table-cell>Line feed</s:table-cell></s:table-row>
            <s:table-row><s:table-cell>U+000C</s:table-cell><s:table-cell>Form feed</s:table-cell></s:table-row>
            <s:table-row><s:table-cell>U+000D</s:table-cell><s:table-cell>Carriage return</s:table-cell></s:table-row>
            <s:table-row><s:table-cell>U+0020</s:table-cell><s:table-cell>Space</s:table-cell></s:table-row>
          </s:table-body>
        </s:table>
      </s:formal-item>
      <s:paragraph>
        Lines of source are separated with <s:term type="term">line_separator</s:term>, which
        may be any of the following:
      </s:paragraph>
      <s:formal-item kind="specifications" type="specifications">
        <s:formal-item-title>Line separators</s:formal-item-title>
        <s:table>
          <s:table-summary>Line separators</s:table-summary>
          <s:table-head>
            <s:table-column-name>Codepoint(s)</s:table-column-name>
            <s:table-column-name>Name</s:table-column-name>
          </s:table-head>
          <s:table-body>
            <s:table-row><s:table-cell>U+000A</s:table-cell><s:table-cell>Line feed</s:table-cell></s:table-row>
            <s:table-row><s:table-cell>U+000D</s:table-cell><s:table-cell>Carriage return</s:table-cell></s:table-row>
            <s:table-row><s:table-cell>U+000D U+000A</s:table-cell><s:table-cell>Carriage return immediately followed by line feed</s:table-cell></s:table-row>
          </s:table-body>
        </s:table>
      </s:formal-item>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.lex.comments">
      <s:section-title>Comments</s:section-title>
      <s:paragraph>
        A <s:term type="term">comment</s:term> starts with <s:term type="constant">--</s:term>
        (two adjacent <s:term type="constant">U+002D</s:term> characters) and extends to
        the end of the line. Comments may appear on any line in a
        <s:link target="com.io7m.parasol.1.0.0.lex.units">unit</s:link>.
        The contents of comments have no effect whatsoever on the semantics of
        <s:term type="package">parasol</s:term> programs.
      </s:paragraph>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.lex.tokens">
    <s:section-title>Tokens</s:section-title>

    <s:subsection xml:id="com.io7m.parasol.1.0.0.lex.tokens.integer-literal">
      <s:subsection-title>Integer literals</s:subsection-title>
      <s:paragraph>
        An <s:term type="term">integer_literal</s:term> is a sequence
        of one or more digits, optionally preceded by a minus sign
        (<s:term type="constant">U+002D</s:term>), representing
        a decimal integer. The precise syntax is given by the following EBNF:
      </s:paragraph>
      <s:formal-item kind="specifications" type="specifications">
        <s:formal-item-title>Integer literals</s:formal-item-title>
        <s:verbatim><![CDATA[digit_nonzero =
  "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;

digit =
  "0" | digit_nonzero ;

integer =
  "0" | ( ["-"] , digit_nonzero , { digit } ) ;]]></s:verbatim>
      </s:formal-item>
    </s:subsection>

    <s:subsection xml:id="com.io7m.parasol.1.0.0.lex.tokens.real-literal">
      <s:subsection-title>Real literals</s:subsection-title>
      <s:paragraph>
        A <s:term type="term">real_literal</s:term> consists of
        an integral and fractional part, separated by a dot
        (<s:term type="constant">U+002E</s:term>) and optionally
        preceded by a minus sign (<s:term type="constant">U+002D</s:term>),
        and represents a real number. The precise syntax is given by
        the following EBNF:
      </s:paragraph>
      <s:formal-item kind="specifications" type="specifications">
        <s:formal-item-title>Real literals</s:formal-item-title>
        <s:verbatim><![CDATA[real =
  ["-"] , digit , { digit } , "." , digit , { digit } ;]]></s:verbatim>
      </s:formal-item>
    </s:subsection>

    <s:subsection xml:id="com.io7m.parasol.1.0.0.lex.tokens.boolean-literal">
      <s:subsection-title>Boolean literals</s:subsection-title>
      <s:paragraph>
        A <s:term type="term">boolean_literal</s:term> is either
        <s:term type="constant">true</s:term> or
        <s:term type="constant">false</s:term>. The precise syntax is
        given by  the following EBNF:
      </s:paragraph>
      <s:formal-item kind="specifications" type="specifications">
        <s:formal-item-title>Boolean literals</s:formal-item-title>
        <s:verbatim><![CDATA[boolean_literal =
  "true" | "false" ;]]></s:verbatim>
      </s:formal-item>
    </s:subsection>

    <s:subsection xml:id="com.io7m.parasol.1.0.0.lex.tokens.identifier">
      <s:subsection-title>Identifiers</s:subsection-title>
      <s:paragraph>
        Identifiers are sequences of uppercase letters
        (<s:term type="constant">[U+0041, U+005A]</s:term>), lowercase
        letters (<s:term type="constant">[U+0061, U+007A]</s:term>),
        and underscores (<s:term type="constant">U+005F</s:term>). An
        identifier is uppercase iff its first character is an uppercase
        letter, or lowercase iff its first character is a lowercase letter.
        Identifiers cannot begin with underscores or digits. The precise
        syntax is given by the following EBNF:
      </s:paragraph>
      <s:formal-item kind="specifications" type="specifications">
        <s:formal-item-title>Identifiers</s:formal-item-title>
        <s:verbatim><![CDATA[letter_lower =
  "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" |
  "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" |
  "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" |
  "y" | "z" ;

letter_upper =
  "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" |
  "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" |
  "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" |
  "Y" | "Z" ;

letter =
  letter_lower | letter_upper ;

name_lower =
  letter_lower , { letter | digit | "-" | "_" } ;

name_upper =
  letter_upper , { letter | digit | "-" | "_" } ;]]></s:verbatim>
      </s:formal-item>
    </s:subsection>

    <s:subsection xml:id="com.io7m.parasol.1.0.0.lex.tokens.keywords">
      <s:subsection-title>Keywords</s:subsection-title>
      <s:paragraph>
        All of the following character sequences are reserved as keywords
        and cannot be used otherwise:
      </s:paragraph>
      <s:formal-item kind="specifications" type="specifications">
        <s:formal-item-title>Keywords</s:formal-item-title>
        <s:list-unordered>
<s:list-item><s:term type="keyword">:</s:term> (<s:term type="constant">U+003A</s:term>)</s:list-item>
<s:list-item><s:term type="keyword">,</s:term> (<s:term type="constant">U+002C</s:term>)</s:list-item>
<s:list-item><s:term type="keyword">{</s:term> (<s:term type="constant">U+007B</s:term>)</s:list-item>
<s:list-item><s:term type="keyword">}</s:term> (<s:term type="constant">U+007D</s:term>)</s:list-item>
<s:list-item><s:term type="keyword">.</s:term> (<s:term type="constant">U+002E</s:term>)</s:list-item>
<s:list-item><s:term type="keyword">=</s:term> (<s:term type="constant">U+003D</s:term>)</s:list-item>
<s:list-item><s:term type="keyword">(</s:term> (<s:term type="constant">U+0028</s:term>)</s:list-item>
<s:list-item><s:term type="keyword">)</s:term> (<s:term type="constant">U+0029</s:term>)</s:list-item>
<s:list-item><s:term type="keyword">;</s:term> (<s:term type="constant">U+003B</s:term>)</s:list-item>
<s:list-item><s:term type="keyword">[</s:term> (<s:term type="constant">U+005B</s:term>)</s:list-item>
<s:list-item><s:term type="keyword">]</s:term> (<s:term type="constant">U+005D</s:term>)</s:list-item>

<s:list-item><s:term type="keyword">as</s:term></s:list-item>
<s:list-item><s:term type="keyword">discard</s:term></s:list-item>
<s:list-item><s:term type="keyword">else</s:term></s:list-item>
<s:list-item><s:term type="keyword">end</s:term></s:list-item>
<s:list-item><s:term type="keyword">false</s:term></s:list-item>
<s:list-item><s:term type="keyword">fragment</s:term></s:list-item>
<s:list-item><s:term type="keyword">function</s:term></s:list-item>
<s:list-item><s:term type="keyword">if</s:term></s:list-item>
<s:list-item><s:term type="keyword">import</s:term></s:list-item>
<s:list-item><s:term type="keyword">in</s:term></s:list-item>
<s:list-item><s:term type="keyword">is</s:term></s:list-item>
<s:list-item><s:term type="keyword">let</s:term></s:list-item>
<s:list-item><s:term type="keyword">module</s:term></s:list-item>
<s:list-item><s:term type="keyword">new</s:term></s:list-item>
<s:list-item><s:term type="keyword">out</s:term></s:list-item>
<s:list-item><s:term type="keyword">package</s:term></s:list-item>
<s:list-item><s:term type="keyword">parameter</s:term></s:list-item>
<s:list-item><s:term type="keyword">program</s:term></s:list-item>
<s:list-item><s:term type="keyword">record</s:term></s:list-item>
<s:list-item><s:term type="keyword">shader</s:term></s:list-item>
<s:list-item><s:term type="keyword">then</s:term></s:list-item>
<s:list-item><s:term type="keyword">true</s:term></s:list-item>
<s:list-item><s:term type="keyword">type</s:term></s:list-item>
<s:list-item><s:term type="keyword">value</s:term></s:list-item>
<s:list-item><s:term type="keyword">vertex</s:term></s:list-item>
<s:list-item><s:term type="keyword">with</s:term></s:list-item>
        </s:list-unordered>
      </s:formal-item>
    </s:subsection>
    </s:section>
  </s:part>

  <s:part xml:id="com.io7m.parasol.1.0.0.declarations">
    <s:part-title>Declarations</s:part-title>
    <s:part-contents/>

    <s:section>
      <s:section-title>Overview</s:section-title>
      <s:paragraph>
        The <s:term type="package">parasol</s:term> language
        consists of <s:link target="com.io7m.parasol.1.0.0.declarations.terms">terms</s:link>,
        <s:link target="com.io7m.parasol.1.0.0.declarations.types">types</s:link>, and
        <s:link target="com.io7m.parasol.1.0.0.declarations.shaders">shaders</s:link>, which are
        organized into
        <s:link target="com.io7m.parasol.1.0.0.declarations.modules">modules</s:link>
        (which are further organized into
        <s:link target="com.io7m.parasol.1.0.0.declarations.packages">packages</s:link>).
      </s:paragraph>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.declarations.terms">
      <s:section-title>Terms</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          <s:term type="term">Terms</s:term> are the computational elements
          of the <s:term type="package">parasol</s:term> language. They consist
          of <s:link target="com.io7m.parasol.1.0.0.declarations.terms.values">values</s:link>,
          which effectively give names to expressions, and
          <s:link target="com.io7m.parasol.1.0.0.declarations.terms.functions">functions</s:link>,
          which are named computational rules in the mathematical sense.
        </s:paragraph>
      </s:subsection>

      <s:subsection>
        <s:subsection-title>Declarations</s:subsection-title>
        <s:paragraph>
          A <s:term type="term">term_declaration</s:term> may either be a
          <s:link target="com.io7m.parasol.1.0.0.declarations.terms.values">value_declaration</s:link>
          or a
          <s:link target="com.io7m.parasol.1.0.0.declarations.terms.functions">function_declaration</s:link>.
        </s:paragraph>
      </s:subsection>

      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.terms.names">
        <s:subsection-title>Names</s:subsection-title>
        <s:paragraph>
          The names selected for terms must be unique with respect to
          other terms within the <s:link target="com.io7m.parasol.1.0.0.declarations.modules">module</s:link>
          in which they are defined. That is, there cannot be two terms with the same name
          in the same module. Terms do not share a name space with
          <s:link target="com.io7m.parasol.1.0.0.declarations.types">types</s:link>
          or <s:link target="com.io7m.parasol.1.0.0.declarations.shaders">shaders</s:link>.
        </s:paragraph>
        <s:paragraph>
          The following restrictions apply when naming terms:
        </s:paragraph>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>Name restrictions</s:formal-item-title>
          <s:list-unordered>
            <s:list-item>
              Term names must begin with a <s:term type="term">lowercase</s:term>
              letter. This is directly implied by the
              <s:link target="com.io7m.parasol.1.0.0.declarations.terms.syntax">grammar</s:link>.
            </s:list-item>
            <s:list-item>
              Names cannot contain two adjacent underscores (<s:term type="constant">U+005F</s:term>).
            </s:list-item>
            <s:list-item>
              Names cannot end with underscores (<s:term type="constant">U+005F</s:term>).
            </s:list-item>
            <s:list-item>
              Names cannot start with the character sequence "<s:term type="constant">gl_</s:term>"
              (<s:term type="constant">U+0067</s:term>,
               <s:term type="constant">U+006C</s:term>,
               <s:term type="constant">U+005F</s:term>).
            </s:list-item>
            <s:list-item>
              Names cannot match any of the keywords or reserved words defined in
              any version of the OpenGL shading language. See the
              <s:link target="com.io7m.parasol.1.0.0.glsl-identifiers">GLSL identifiers</s:link>
              section for the complete list.
            </s:list-item>
          </s:list-unordered>
        </s:formal-item>
      </s:subsection>

      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.terms.recursion">
        <s:subsection-title>Recursion</s:subsection-title>
        <s:paragraph>
          No <s:term type="term">term_declaration</s:term> can be <s:term type="term">recursive</s:term>
          with respect to itself or any other <s:term type="term">term_declaration</s:term>
          in the <s:link target="com.io7m.parasol.1.0.0.declarations.modules">module</s:link>
          in which it appears.
        </s:paragraph>
        <s:paragraph>
          A term <s:term type="variable">d‚ÇÄ</s:term> is said to
          <s:term type="term">refer statically</s:term> to a
          term <s:term type="variable">d‚ÇÅ</s:term> if
          the <s:term type="term">free variables</s:term> of <s:term type="variable">d‚ÇÄ</s:term>
          contain the name of <s:term type="variable">d‚ÇÅ</s:term>.
        </s:paragraph>
        <s:paragraph>
          A <s:term type="term">term_declaration</s:term> <s:term type="variable">d</s:term>
          is (mutually) <s:term type="term">recursive</s:term> iff:
        </s:paragraph>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>Recursion conditions</s:formal-item-title>
          <s:list-unordered>
            <s:list-item>
              <s:term type="variable">d</s:term> refers statically to itself.
            </s:list-item>
            <s:list-item>
              There is a sequence of terms <s:term type="expression">t‚ÇÄ, t‚ÇÅ, ..., t‚Çô</s:term>
              such that <s:term type="variable">d</s:term> refers statically to
              <s:term type="variable">t‚ÇÄ</s:term>, and
              for all <s:term type="variable">m</s:term> where <s:term type="expression">0 &lt;= m &lt; n</s:term>,
              <s:term type="variable">t‚Çò</s:term> refers statically
              <s:term type="expression">t‚Çç‚Çò‚Çä‚ÇÅ‚Çé</s:term>, and
              <s:term type="variable">t‚Çô</s:term> refers statically to
              <s:term type="variable">d</s:term>.
            </s:list-item>
          </s:list-unordered>
        </s:formal-item>
      </s:subsection>

      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.terms.ordering">
        <s:subsection-title>Order of declarations</s:subsection-title>
        <s:paragraph>
          For the purposes of sorting term declarations based on their
          dependencies, terms can be <s:term type="term">partially ordered</s:term>
          based on the terms to which they refer statically. That is, if
          a term <s:term type="variable">t‚ÇÄ</s:term> refers statically to
          term <s:term type="variable">t‚ÇÅ</s:term>, then
          <s:term type="expression">t‚ÇÅ &lt; t‚ÇÄ</s:term>.
        </s:paragraph>
        <s:paragraph>
          Terms do not have to be declared in any given order. That is,
          if a term <s:term type="variable">t‚ÇÄ</s:term> refers statically
          to term <s:term type="variable">t‚ÇÅ</s:term> in the same module,
          there is no requirement that <s:term type="variable">t‚ÇÅ</s:term>
          be declared before <s:term type="variable">t‚ÇÄ</s:term>.
        </s:paragraph>
        <s:paragraph>
          Terms are sorted topologically prior to any evaluation based
          on the given partial order relation, and the
          restrictions on
          <s:link target="com.io7m.parasol.1.0.0.declarations.terms.recursion">recursion</s:link>
          ensure that it is always possible to sort terms in the order
          of their dependencies.
        </s:paragraph>
      </s:subsection>

      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.terms.values">
        <s:subsection-title>Values</s:subsection-title>
        <s:paragraph>
          A <s:term type="term">value_declaration</s:term> binds an
          <s:link target="com.io7m.parasol.1.0.0.expressions">expression</s:link>
          to a name.
        </s:paragraph>
        <s:paragraph>
          The <s:link target="com.io7m.parasol.1.0.0.types">type</s:link> of
          the <s:term type="term">value_declaration</s:term> will be inferred
          from the given expression, but the declaration can be optionally ascribed
          with the name of a type, in which case the type of the expression will be
          checked against the ascription and an error raised in the case of a
          mismatch.
        </s:paragraph>
      </s:subsection>

      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.terms.functions">
        <s:subsection-title>Functions</s:subsection-title>
        <s:paragraph>
          A <s:term type="term">function_declaration</s:term> binds an
          <s:link target="com.io7m.parasol.1.0.0.expressions">expression</s:link>
          <s:term type="variable">e</s:term> to a name along with a given
          <s:term type="term">return type</s:term>
          <s:term type="variable">t</s:term>
          and a set of <s:term type="term">formal parameters</s:term>,
          where <s:term type="variable">e</s:term> contains zero or more
          variables bound by the formal parameters and which, when
          evaluated, will result in a value of type <s:term type="variable">t</s:term>.
        </s:paragraph>
      </s:subsection>

      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.terms.type_rules">
        <s:subsection-title>Type rules</s:subsection-title>
        <s:paragraph>
          A <s:term type="term">value_declaration</s:term> of type
          <s:term type="variable">t</s:term> introduces a term of type
          <s:term type="variable">t</s:term> into the environment:
        </s:paragraph>
        <s:formal-item kind="specifications">
          <s:formal-item-title>Value declaration type rule (value_declaration)</s:formal-item-title>
          <s:image source="ty_value_declaration.png">Value declaration type rule (value_declaration)</s:image>
        </s:formal-item>
        <s:formal-item kind="specifications">
          <s:formal-item-title>Value declaration (ascribed) type rule (value_declaration_ascribed)</s:formal-item-title>
          <s:image source="ty_value_declaration_ascribed.png">Value declaration (ascribed) type rule (value_declaration_ascribed)</s:image>
        </s:formal-item>
        <s:paragraph>
          A <s:term type="term">function_declaration</s:term> with parameters of type
          <s:term type="expression">(s‚ÇÄ ‚úï s‚ÇÅ ‚úï ... s‚Çô)</s:term> that returns type
          <s:term type="variable">u</s:term> introduces a term of type
          <s:term type="variable">(s‚ÇÄ ‚úï s‚ÇÅ ‚úï ... s‚Çô) ‚Üí u</s:term> into the environment:
        </s:paragraph>
        <s:formal-item kind="specifications">
          <s:formal-item-title>Function declaration type rule (function_declaration)</s:formal-item-title>
          <s:image source="ty_function_declaration.png">Function declaration type rule (function_declaration)</s:image>
        </s:formal-item>
      </s:subsection>

      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.terms.semantics">
        <s:subsection-title>Operational semantics</s:subsection-title>
        <s:paragraph>
          With terms sorted according to their
          <s:link target="com.io7m.parasol.1.0.0.declarations.terms.ordering">partial order</s:link>,
          evaluation of <s:term type="term">value_declarations</s:term>
          in the current <s:link target="com.io7m.parasol.1.0.0.declarations.modules">module</s:link>
          proceeds from top-to-bottom, with the value of each evaluated
          <s:term type="term">value_declaration</s:term> being
          substituted into the terms that follow it:
        </s:paragraph>
        <s:formal-item kind="specifications">
          <s:formal-item-title>Top level evaluation (top_level)</s:formal-item-title>
          <s:image source="op_top_level.png">Top level evaluation (top_level)</s:image>
        </s:formal-item>
      </s:subsection>

      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.terms.syntax">
        <s:subsection-title>Syntax</s:subsection-title>
        <s:paragraph>
          The precise syntax of <s:term type="term">term_declarations</s:term>
          is given by the following EBNF:
        </s:paragraph>
      <s:formal-item kind="specifications" type="specifications">
        <s:formal-item-title>Term declaration syntax</s:formal-item-title>
        <s:verbatim><![CDATA[type_path =
    name_lower
  | name_upper , "." , name_lower ;

value_declaration =
  "value" , name_lower , [ ":" , type_path ] , "=" , expression ;

function_formal_parameter =
  name_lower , ":" , type_path ;

function_formal_parameters =
  "(" , function_formal_parameter, { "," , function_formal_parameter } , ")" ;

function_declaration =
  "function" , name_lower , function_formal_parameters , ":" , type_path , "=" , expression ;

term_declaration =
  value_declaration | function_declaration ;]]></s:verbatim>
        </s:formal-item>
      </s:subsection>

      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.terms.examples">
        <s:subsection-title>Examples</s:subsection-title>
        <s:formal-item kind="examples">
          <s:formal-item-title>Examples</s:formal-item-title>
          <s:verbatim><![CDATA[value x = 23;

value y = I.plus x 24;

function identity (
  x : integer
) : integer = x;]]></s:verbatim>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.declarations.types">
      <s:section-title>Types</s:section-title>

      <s:subsection>
        <s:subsection-title>Declarations</s:subsection-title>
        <s:paragraph>
          A <s:term type="term">type_declaration</s:term> declares
          a new
          <s:link target="com.io7m.parasol.1.0.0.declarations.types.records">record type</s:link>.
          This section documents the declarations themselves, while the
          <s:link target="com.io7m.parasol.1.0.0.types">types</s:link>
          section documents the actual type system itself.
        </s:paragraph>
      </s:subsection>

      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.types.names">
        <s:subsection-title>Names</s:subsection-title>
        <s:paragraph>
          The names selected for types must be unique with respect to
          other types within the <s:link target="com.io7m.parasol.1.0.0.declarations.modules">module</s:link>
          in which they are defined. That is, there cannot be two types with the same name
          in the same module. Types do not share a name space with
          <s:link target="com.io7m.parasol.1.0.0.declarations.terms">terms</s:link>
          or <s:link target="com.io7m.parasol.1.0.0.declarations.shaders">shaders</s:link>.
        </s:paragraph>
        <s:paragraph>
          The following restrictions apply when naming types:
        </s:paragraph>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>Name restrictions</s:formal-item-title>
          <s:list-unordered>
            <s:list-item>
              Type names must begin with a <s:term type="term">lowercase</s:term>
              letter. This is directly implied by the
              <s:link target="com.io7m.parasol.1.0.0.declarations.types.syntax">grammar</s:link>.
            </s:list-item>
            <s:list-item>
              Names cannot contain two adjacent underscores (<s:term type="constant">U+005F</s:term>).
            </s:list-item>
            <s:list-item>
              Names cannot end with underscores (<s:term type="constant">U+005F</s:term>).
            </s:list-item>
            <s:list-item>
              Names cannot start with the character sequence "<s:term type="constant">gl_</s:term>"
              (<s:term type="constant">U+0067</s:term>,
               <s:term type="constant">U+006C</s:term>,
               <s:term type="constant">U+005F</s:term>).
            </s:list-item>
            <s:list-item>
              Names cannot match any of the keywords or reserved words defined in
              any version of the OpenGL shading language. See the
              <s:link target="com.io7m.parasol.1.0.0.glsl-identifiers">GLSL identifiers</s:link>
              section for the complete list.
            </s:list-item>
          </s:list-unordered>
        </s:formal-item>
      </s:subsection>

      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.types.recursion">
        <s:subsection-title>Recursion</s:subsection-title>
        <s:paragraph>
          No <s:term type="term">type_declaration</s:term> can be <s:term type="term">recursive</s:term>
          with respect to itself or any other <s:term type="term">type_declaration</s:term>
          in the <s:link target="com.io7m.parasol.1.0.0.declarations.modules">module</s:link>
          in which it appears.
        </s:paragraph>
        <s:paragraph>
          A type <s:term type="variable">d‚ÇÄ</s:term> is said to
          <s:term type="term">refer statically</s:term> to a
          type <s:term type="variable">d‚ÇÅ</s:term> if
          <s:term type="variable">d‚ÇÄ</s:term> appears anywhere in the
          definition of <s:term type="variable">d‚ÇÅ</s:term>.
        </s:paragraph>
        <s:paragraph>
          A <s:term type="term">type_declaration</s:term> <s:term type="variable">d</s:term>
          is (mutually) <s:term type="term">recursive</s:term> iff:
        </s:paragraph>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>Recursion conditions</s:formal-item-title>
          <s:list-unordered>
            <s:list-item>
              <s:term type="variable">d</s:term> refers statically to itself.
            </s:list-item>
            <s:list-item>
              There is a sequence of types <s:term type="expression">t‚ÇÄ, t‚ÇÅ, ..., t‚Çô</s:term>
              such that <s:term type="variable">d</s:term> refers statically to
              <s:term type="variable">t‚ÇÄ</s:term>, and
              for all <s:term type="variable">m</s:term> where <s:term type="expression">0 &lt;= m &lt; n</s:term>,
              <s:term type="variable">t‚Çò</s:term> refers statically
              <s:term type="expression">t‚Çç‚Çò‚Çä‚ÇÅ‚Çé</s:term>, and
              <s:term type="variable">t‚Çô</s:term> refers statically to
              <s:term type="variable">d</s:term>.
            </s:list-item>
          </s:list-unordered>
        </s:formal-item>
      </s:subsection>

      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.types.records">
        <s:subsection-title>Records</s:subsection-title>
        <s:paragraph>
          A <s:term type="term">type_declaration</s:term> binds a
          <s:term type="term">record_type_expression</s:term> to a name.
          A <s:term type="term">record_type_expression</s:term> declares
          a set of named <s:term type="term">fields</s:term> and types.
        </s:paragraph>
        <s:paragraph>
          A <s:term type="term">record_type_expression</s:term> cannot
          contain two <s:term type="term">fields</s:term> with the
          same name, but two distinct
          <s:term type="term">record_type_expressions</s:term> can have
          <s:term type="term">fields</s:term> with the same names. To
          clarify, these are valid <s:term type="term">type_declarations</s:term>:
        </s:paragraph>
        <s:formal-item kind="examples">
          <s:formal-item-title>Valid type declarations</s:formal-item-title>
          <s:verbatim><![CDATA[type t is record
  x : integer,
  y : integer
end;

type u is record
  x : integer,
  y : integer
end;]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          However, this is not:
        </s:paragraph>
        <s:formal-item kind="examples">
          <s:formal-item-title>Invalid type declarations (duplicate field)</s:formal-item-title>
          <s:verbatim><![CDATA[type t is record
  x : integer,
  x : integer
end;]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          As described in the <s:link target="com.io7m.parasol.1.0.0.types">types</s:link>
          section, types have <s:term type="term">by-name equivalence</s:term> and
          therefore two identical <s:term type="term">record_type_expressions</s:term>
          bound to different names are not type-compatible.
        </s:paragraph>
      </s:subsection>

      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.types.type_rules">
        <s:subsection-title>Type rules</s:subsection-title>
        <s:paragraph>
          A <s:term type="term">type_declaration</s:term> introduces a new record
          type into the typing environment. See the rules for
          <s:link target="com.io7m.parasol.1.0.0.types.records">record types</s:link>
          for the effects that this has on typing rules.
        </s:paragraph>
      </s:subsection>

      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.types.syntax">
        <s:subsection-title>Syntax</s:subsection-title>
        <s:paragraph>
          The precise syntax of type declarations is given by the following
          EBNF:
        </s:paragraph>
      <s:formal-item kind="specifications" type="specifications">
        <s:formal-item-title>Type declaration syntax</s:formal-item-title>
        <s:verbatim><![CDATA[record_type_field =
  name_lower , ":" , type_path ;

record_type_expression =
  "record" , record_type_field , { "," , record_type_field } , "end" ;

type_declaration =
  "type" , name_lower , "is" , type_expression ;

type_expression =
  record_type_expression
  ;
        ]]></s:verbatim>
        </s:formal-item>
      </s:subsection>

      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.types.examples">
        <s:subsection-title>Examples</s:subsection-title>
        <s:formal-item kind="examples">
          <s:formal-item-title>Examples</s:formal-item-title>
          <s:verbatim><![CDATA[
type t is record
  x : integer,
  y : integer,
  z : integer
end;

type u is record
  v0 : t,
  v1 : t,
  v2 : t
end;]]></s:verbatim>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.declarations.shaders">
      <s:section-title>Shaders</s:section-title>

      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          <s:term type="term">Shaders</s:term> represent programs
          that will execute on the targeted graphics hardware. They
          are divided into
          <s:link target="com.io7m.parasol.1.0.0.declarations.shaders.vertex">vertex shaders</s:link>,
          <s:link target="com.io7m.parasol.1.0.0.declarations.shaders.fragment">fragment shaders</s:link>,
          and
          <s:link target="com.io7m.parasol.1.0.0.declarations.shaders.program">programs</s:link>,
          (which essentially aggregate other shaders into usable programs).
        </s:paragraph>
      </s:subsection>

      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.shaders.declarations">
        <s:subsection-title>Declarations</s:subsection-title>
        <s:paragraph>
          A <s:term type="term">shader_declaration</s:term> may either be a
          <s:link target="com.io7m.parasol.1.0.0.declarations.shaders.vertex">shader_vertex_declaration</s:link>,
          a
          <s:link target="com.io7m.parasol.1.0.0.declarations.shaders.fragment">shader_fragment_declaration</s:link>,
          or a
          <s:link target="com.io7m.parasol.1.0.0.declarations.shaders.program">shader_program_declaration</s:link>.
        </s:paragraph>
      </s:subsection>

      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.shaders.names">
        <s:subsection-title>Names</s:subsection-title>
        <s:paragraph>
          The names selected for shaders must be unique with respect to
          other shaders within the <s:link target="com.io7m.parasol.1.0.0.declarations.modules">module</s:link>
          in which they are defined. That is, there cannot be two shaders with the same name
          in the same module. Shaders do not share a name space with
          <s:link target="com.io7m.parasol.1.0.0.declarations.terms">terms</s:link>
          or <s:link target="com.io7m.parasol.1.0.0.declarations.types">types</s:link>.
        </s:paragraph>
        <s:paragraph>
          The following restrictions apply when naming shaders:
        </s:paragraph>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>Name restrictions</s:formal-item-title>
          <s:list-unordered>
            <s:list-item>
              Shader names must begin with a <s:term type="term">lowercase</s:term>
              letter. This is directly implied by the
              <s:link target="com.io7m.parasol.1.0.0.declarations.shaders.syntax">grammar</s:link>.
            </s:list-item>
            <s:list-item>
              Names cannot contain two adjacent underscores (<s:term type="constant">U+005F</s:term>).
            </s:list-item>
            <s:list-item>
              Names cannot end with underscores (<s:term type="constant">U+005F</s:term>).
            </s:list-item>
            <s:list-item>
              Names cannot start with the character sequence "<s:term type="constant">gl_</s:term>"
              (<s:term type="constant">U+0067</s:term>,
               <s:term type="constant">U+006C</s:term>,
               <s:term type="constant">U+005F</s:term>).
            </s:list-item>
            <s:list-item>
              Names cannot match any of the keywords or reserved words defined in
              any version of the OpenGL shading language. See the
              <s:link target="com.io7m.parasol.1.0.0.glsl-identifiers">GLSL identifiers</s:link>
              section for the complete list.
            </s:list-item>
          </s:list-unordered>
        </s:formal-item>
      </s:subsection>

      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.shaders.io">
        <s:subsection-title>Inputs/Outputs/Parameters</s:subsection-title>
        <s:paragraph>
          Shaders consume data from <s:term type="term">inputs</s:term>
          and <s:term type="term">parameters</s:term>, and produce data
          on <s:term type="term">outputs</s:term>.
        </s:paragraph>
        <s:paragraph>
          <s:term type="term">Inputs</s:term> are data sources that produce
          values that may change every time the shader is executed (once
          per vertex for <s:term type="term">vertex shaders</s:term> and
          once per fragment for
          <s:term type="term">fragment shaders</s:term>).
        </s:paragraph>
        <s:paragraph>
          <s:term type="term">Parameters</s:term> are data sources that
          produce values that may be constant over the entire lifetime
          of the program.
        </s:paragraph>
        <s:paragraph>
          <s:term type="term">Outputs</s:term> are data sinks that, when
          assigned values, pass those values to the next stage of the
          rendering pipeline. Typically,
          <s:term type="term">vertex shaders</s:term> linearly interpolate
          values written to <s:term type="term">outputs</s:term> and pass
          them on to the <s:term type="term">fragment shader</s:term>,
          and <s:term type="term">fragment shaders</s:term> send values
          written to <s:term type="term">outputs</s:term> to the
          <s:term type="term">framebuffer</s:term> for display.
        </s:paragraph>
        <s:paragraph>
          The following restrictions apply when naming
          <s:term type="term">inputs</s:term>, <s:term type="term">outputs</s:term>,
          and <s:term type="term">parameters</s:term>:
        </s:paragraph>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>Name restrictions</s:formal-item-title>
          <s:list-unordered>
            <s:list-item>
              Names must begin with a <s:term type="term">lowercase</s:term>
              letter. This is directly implied by the
              <s:link target="com.io7m.parasol.1.0.0.declarations.shaders.syntax">grammar</s:link>.
            </s:list-item>
            <s:list-item>
              Names cannot contain two adjacent underscores (<s:term type="constant">U+005F</s:term>).
            </s:list-item>
            <s:list-item>
              Names cannot end with underscores (<s:term type="constant">U+005F</s:term>).
            </s:list-item>
            <s:list-item>
              Names cannot start with the character sequence "<s:term type="constant">gl_</s:term>"
              (<s:term type="constant">U+0067</s:term>,
               <s:term type="constant">U+006C</s:term>,
               <s:term type="constant">U+005F</s:term>).
            </s:list-item>
            <s:list-item>
              Names cannot match any of the keywords or reserved words defined in
              any version of the OpenGL shading language. See the
              <s:link target="com.io7m.parasol.1.0.0.glsl-identifiers">GLSL identifiers</s:link>
              section for the complete list.
            </s:list-item>
          </s:list-unordered>
        </s:formal-item>
      </s:subsection>

      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.shaders.type_rules">
        <s:subsection-title>Type rules</s:subsection-title>
        <s:paragraph>
          Only a subset of the available types are permitted
          for <s:term type="term">inputs</s:term>, and
          <s:term type="term">outputs</s:term>:
        </s:paragraph>
        <s:formal-item kind="specifications">
          <s:formal-item-title>Input/Output types</s:formal-item-title>
          <s:list-unordered>
            <s:list-item><s:link target="com.io7m.parasol.1.0.0.types.integer">integer</s:link></s:list-item>
            <s:list-item><s:link target="com.io7m.parasol.1.0.0.types.float">float</s:link></s:list-item>
            <s:list-item><s:link target="com.io7m.parasol.1.0.0.types.vector">vector_NT</s:link></s:list-item>
          </s:list-unordered>
        </s:formal-item>
        <s:paragraph>
          <s:term type="term">Parameters</s:term> may be of any type
          <s:footnote>
            Notably, <s:term type="term">parameters</s:term> are the
            <s:term type="emphasis">only</s:term> means by which values
            of the <s:link target="com.io7m.parasol.1.0.0.types.samplers">sampler</s:link>
            types can be introduced into a program.
          </s:footnote>.
        </s:paragraph>
      </s:subsection>

      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.shaders.semantics">
        <s:subsection-title>Operational Semantics</s:subsection-title>
        <s:paragraph>
          ...
        </s:paragraph>
      </s:subsection>

      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.shaders.syntax">
        <s:subsection-title>Syntax</s:subsection-title>
        <s:paragraph>
          The precise syntax of shader declarations is given by the following
          EBNF:
        </s:paragraph>
      <s:formal-item kind="specifications" type="specifications">
        <s:formal-item-title>Shader declaration syntax</s:formal-item-title>
        <s:verbatim><![CDATA[shader_parameter_declaration =
  "parameter" , name_lower , ":" , type_path ;

shader_vertex_input_declaration =
  "in" , name_lower , ":" , type_path ;

shader_vertex_output_declaration =
  "out" , name_lower , ":" , type_path ;

shader_vertex_parameter =
    shader_parameter_declaration
  | shader_vertex_input_declaration
  | shader_vertex_output_declaration ;

shader_vertex_parameters =
  { shader_vertex_parameter , ";" } ;

shader_vertex_output_assignment =
  "out" , name_lower , "=" , term_path ;

shader_vertex_output_assignments =
  shader_vertex_output_assignment , ";" , { shader_vertex_output_assignments } ;

shader_vertex_declaration =
  "vertex" , name_lower , "is" ,
  shader_vertex_parameters ,
  [ "with" , local_declarations ] ,
  "as" ,
  shader_vertex_output_assignments ,
  "end" ;

shader_fragment_input_declaration =
  "in" , name_lower , ":" , type_path ;

shader_fragment_output_declaration =
  "out" , name_lower , ":" , type_path , "as" , integer_literal ;

shader_fragment_parameter =
    shader_parameter_declaration
  | shader_fragment_input_declaration
  | shader_fragment_output_declaration ;

shader_fragment_parameters =
  { shader_fragment_parameter , ";" } ;

shader_fragment_discard_declaration =
  "discard" , "(" , expression , ")" ;

shader_fragment_local_declaration =
    local_declaration
  | shader_fragment_discard_declaration ;

shader_fragment_local_declarations =
  shader_fragment_local_declaration , ";" , { shader_fragment_local_declarations } ;

shader_fragment_output_assignment =
  "out" , name_lower , "=" , term_path ;

shader_fragment_output_assignments =
  shader_fragment_output_assignment , ";" , { shader_fragment_output_assignments } ;

shader_fragment_declaration =
  "fragment" , name_lower , "is" ,
  shader_fragment_parameters ,
  [ "with" , shader_fragment_local_declarations ] ,
  "as" ,
  shader_fragment_output_assignments ,
  "end" ;

shader_program_declaration =
  "program" , name_lower , "is" ,
  "vertex" , shader_path , ";" ,
  "fragment" , shader_path , ";" ,
  "end" ;

shader_declaration =
  "shader" , ( shader_vertex_declaration | shader_fragment_declaration | shader_program_declaration ) ;

shader_declarations =
  { shader_declaration , ";" } ;]]></s:verbatim>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.declarations.shaders.vertex">
      <s:section-title>Vertex shaders</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          <s:term type="term">Vertex shaders</s:term> are programs that
          process data on a per-vertex basis in OpenGL.
        </s:paragraph>
      </s:subsection>

      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.shaders.vertex.declarations">
        <s:subsection-title>Declarations</s:subsection-title>
        <s:paragraph>
          A <s:term type="term">shader_vertex_declaration</s:term> declares a set
          of <s:link target="com.io7m.parasol.1.0.0.declarations.shaders.io">inputs,
          outputs, and parameters</s:link>, as well as a sequence of zero or more
          <s:term type="term">local_value_declarations</s:term>, similar
          in semantics and typing to that found in a
          <s:link target="com.io7m.parasol.1.0.0.expressions.let">let expression</s:link>,
          and a sequence of assignments of values to the declared
          <s:term type="term">outputs</s:term>. A vertex shader must also define exactly
          one output of type <s:link target="com.io7m.parasol.1.0.0.types.vectors">vector_4f</s:link>,
          to which must be assigned a value representing the current homogeneous vertex
          position.
        </s:paragraph>
        <s:paragraph>
          It is required that there be exactly one
          <s:term type="term">shader_vertex_output_assignment</s:term> for each
          <s:term type="term">shader_vertex_output_declaration</s:term>.
        </s:paragraph>
      </s:subsection>

      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.shaders.vertex.type_rules">
        <s:subsection-title>Type rules</s:subsection-title>
        <s:paragraph>
          Each
          <s:term type="term">shader_parameter_declaration</s:term> and
          <s:term type="term">shader_vertex_input_declaration</s:term> introduces
          a new term of the given type into the environment, accessible only
          within the scope of the shader definition,
          as shown by the <s:term type="constant">shader_vertex_inputs_parameters</s:term> rule:
        </s:paragraph>
        <s:formal-item kind="specifications">
          <s:formal-item-title>Vertex shader inputs/parameters (shader_vertex_inputs_parameters)</s:formal-item-title>
          <s:image source="ty_shader_vertex_inputs_parameters.png">Vertex shader inputs/parameters (shader_vertex_inputs_parameters)</s:image>
        </s:formal-item>
        <s:paragraph>
          Each <s:term type="term">local_value_declaration</s:term> introduces
          a new term of the given type into the environment, accessible in each
          successive <s:term type="term">local_value_declaration</s:term> and
          in the <s:term type="term">shader_vertex_output_assignments</s:term>,
          as shown by the
          <s:term type="constant">shader_vertex_values</s:term> rule:
        </s:paragraph>
        <s:formal-item kind="specifications">
          <s:formal-item-title>Vertex shader values (shader_vertex_values)</s:formal-item-title>
          <s:image source="ty_shader_vertex_values.png">Vertex shader values (shader_vertex_values)</s:image>
        </s:formal-item>
        <s:paragraph>
          Finally, each output assigned in a <s:term type="term">shader_vertex_output_assignment</s:term>
          must be of the correct type, as shown by the
          <s:term type="constant">shader_vertex_output_assignment</s:term> rule:
        </s:paragraph>
        <s:formal-item kind="specifications">
          <s:formal-item-title>Vertex shader output assignments (shader_vertex_output)</s:formal-item-title>
          <s:image source="ty_shader_vertex_output.png">Vertex shader output assignments (shader_vertex_output)</s:image>
        </s:formal-item>
      </s:subsection>

      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.shaders.vertex.semantics">
        <s:subsection-title>Operational Semantics</s:subsection-title>
        <s:paragraph>
          The <s:term type="term">local_value_declarations</s:term> are evaluated from
          top-to-bottom, in an identical manner to
          <s:link target="com.io7m.parasol.1.0.0.expressions.let">let expressions</s:link>,
          as shown by the
          <s:term type="variable">shader_vertex_values</s:term> rule:
        </s:paragraph>
        <s:formal-item kind="specifications">
          <s:formal-item-title>Vertex shader local declarations (shader_vertex_values)</s:formal-item-title>
          <s:image source="op_shader_vertex_values.png">Vertex shader local declarations (shader_vertex_values)</s:image>
        </s:formal-item>
      </s:subsection>

      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.shaders.vertex.examples">
        <s:subsection-title>Examples</s:subsection-title>
        <s:formal-item kind="examples">
          <s:formal-item-title>Examples</s:formal-item-title>
          <s:verbatim><![CDATA[
shader vertex v is
  parameter mm_modelview  : matrix_4x4f;
  parameter mm_projection : matrix_4x4f;
  parameter mm_normal     : matrix_3x3f;
  in position             : vector_4f;
  in normal               : vector_3f;
  out vertex r_position   : vector_4f;
  out r_normal            : vector_3f;
with
  value p_result = M4.multiply_vector (M4.multiply (mm_projection, mm_modelview), position);
  value n_result = M3.multiply_vector (mm_normal, normal);
as
  out r_position = p_result;
  out r_normal   = n_result;
end;]]></s:verbatim>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.declarations.shaders.fragment">
      <s:section-title>Fragment shaders</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          <s:term type="term">Fragment shaders</s:term> are programs that
          process data on a per-fragment basis in OpenGL.
        </s:paragraph>
      </s:subsection>
      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.shaders.fragment.declarations">
        <s:subsection-title>Declarations</s:subsection-title>
        <s:paragraph>
          A <s:term type="term">shader_fragment_declaration</s:term> declares a set
          of <s:link target="com.io7m.parasol.1.0.0.declarations.shaders.io">inputs,
          outputs, and parameters</s:link>, as well as a sequence of zero or more
          <s:term type="term">shader_fragment_local_declaration</s:term>, and a sequence
          of assignments of values to the declared
          <s:term type="term">outputs</s:term>.
        </s:paragraph>
        <s:paragraph>
          A <s:term type="term">shader_fragment_local_declaration</s:term> is
          either a <s:term type="term">local_value_declaration</s:term>, similar
          in semantics and typing to that found in a
          <s:link target="com.io7m.parasol.1.0.0.expressions.let">let expression</s:link>,
          or a
          <s:link target="com.io7m.parasol.1.0.0.declarations.shaders.fragment.discard">shader_fragment_discard_declaration</s:link>.
        </s:paragraph>
      </s:subsection>
      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.shaders.fragment.discard">
        <s:subsection-title>Discard</s:subsection-title>
        <s:paragraph>
          A <s:term type="term">shader_fragment_discard_declaration</s:term> statement
          halts evaluation of the current fragment shader iff the given
          <s:term type="term">expression</s:term> evaluates to
          <s:term type="constant">true</s:term>.
        </s:paragraph>
      </s:subsection>
      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.shaders.fragment.type_rules">
        <s:subsection-title>Type rules</s:subsection-title>
        <s:paragraph>
          Each
          <s:term type="term">shader_parameter_declaration</s:term> and
          <s:term type="term">shader_fragment_input_declaration</s:term> introduces
          a new term of the given type into the environment, accessible only
          within the scope of the shader definition,
          as shown by the <s:term type="constant">shader_fragment_inputs_parameters</s:term> rule:
        </s:paragraph>
        <s:formal-item kind="specifications">
          <s:formal-item-title>Fragment shader inputs/parameters (shader_fragment_inputs_parameters)</s:formal-item-title>
          <s:image source="ty_shader_fragment_inputs_parameters.png">Vertex shader inputs/parameters (shader_fragment_inputs_parameters)</s:image>
        </s:formal-item>
        <s:paragraph>
          Each <s:term type="term">local_value_declaration</s:term> introduces
          a new term of the given type into the environment, accessible in each
          successive <s:term type="term">local_value_declaration</s:term> and
          in the <s:term type="term">shader_fragment_output_assignments</s:term>,
          as shown by the
          <s:term type="constant">shader_fragment_values</s:term> rule:
        </s:paragraph>
        <s:formal-item kind="specifications">
          <s:formal-item-title>Fragment shader values (shader_fragment_values)</s:formal-item-title>
          <s:image source="ty_shader_fragment_values.png">Vertex shader values (shader_fragment_values)</s:image>
        </s:formal-item>
        <s:paragraph>
          Each output assigned in a <s:term type="term">shader_fragment_output_assignment</s:term>
          must be of the correct type, as shown by the
          <s:term type="constant">shader_fragment_output_assignment</s:term> rule:
        </s:paragraph>
        <s:formal-item kind="specifications">
          <s:formal-item-title>Fragment shader output assignments (shader_fragment_output)</s:formal-item-title>
          <s:image source="ty_shader_fragment_output.png">Vertex shader output assignments (shader_fragment_output)</s:image>
        </s:formal-item>
        <s:paragraph>
          Finally, the expression passed to a <s:term type="term">shader_fragment_discard_declaration</s:term>
          must be of a <s:link target="com.io7m.parasol.1.0.0.types.boolean">boolean</s:link> type
          as shown by the <s:term type="constant">shader_fragment_discard</s:term> rule <s:footnote>
            The <s:term type="term">shader_fragment_discard_declaration</s:term> is described
            as having type <s:link target="com.io7m.parasol.1.0.0.types.boolean">boolean</s:link>, but
            the result of the expression is effectively consumed by the
            <s:term type="package">parasol</s:term> language runtime and so this is
            not observable in practice.
          </s:footnote>:
        </s:paragraph>
        <s:formal-item kind="specifications">
          <s:formal-item-title>Fragment shader discard (shader_fragment_discard)</s:formal-item-title>
          <s:image source="ty_shader_fragment_discard.png">Fragment shader discard (shader_fragment_discard)</s:image>
        </s:formal-item>
      </s:subsection>

      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.shaders.fragment.semantics">
        <s:subsection-title>Operational Semantics</s:subsection-title>
        <s:paragraph>
          The <s:term type="term">shader_fragment_local_declaration</s:term> are evaluated from
          top-to-bottom, in an identical manner to
          <s:link target="com.io7m.parasol.1.0.0.expressions.let">let expressions</s:link>,
          as shown by the
          <s:term type="variable">shader_fragment_values</s:term> rule:
        </s:paragraph>
        <s:formal-item kind="specifications">
          <s:formal-item-title>Fragment shader local declarations (shader_fragment_values)</s:formal-item-title>
          <s:image source="op_shader_fragment_values.png">Fragment shader local declarations (shader_fragment_values)</s:image>
        </s:formal-item>
        <s:paragraph>
          Evaluation halts immediately upon evaluating any
          <s:term type="term">shader_fragment_discard_declaration</s:term> where
          the condition evaluates to <s:term type="constant">true</s:term>.
        </s:paragraph>
      </s:subsection>

      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.shaders.fragment.examples">
        <s:subsection-title>Examples</s:subsection-title>
        <s:formal-item kind="examples">
          <s:formal-item-title>Examples</s:formal-item-title>
          <s:verbatim><![CDATA[
shader fragment f is
  parameter texture_0 : sampler_2d;
  in uv               : vector_2f;
  out out0            : vector_4f as 0;
with
  value rgba = T.texture (texture_0, uv);
as
  out out0 = rgba;
end;]]></s:verbatim>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.declarations.shaders.program">
      <s:section-title>Programs</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          <s:term type="term">Programs</s:term> aggregate
          <s:link target="com.io7m.parasol.1.0.0.declarations.shaders.vertex">vertex</s:link> and
          <s:link target="com.io7m.parasol.1.0.0.declarations.shaders.fragment">fragment</s:link>
          shaders into single entities that are executed on the
          targeted graphics hardware.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Declarations</s:subsection-title>
        <s:paragraph>
          A <s:term type="term">shader_program_declaration</s:term> declares a dependency
          on a <s:link target="com.io7m.parasol.1.0.0.declarations.shaders.vertex">vertex shader</s:link>
          and a <s:link target="com.io7m.parasol.1.0.0.declarations.shaders.fragment">fragment shader</s:link>.
        </s:paragraph>
      </s:subsection>
      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.shaders.program.type_rules">
        <s:subsection-title>Compatibility</s:subsection-title>
        <s:paragraph>
          In order for a given <s:term type="term">vertex shader</s:term> and
          <s:term type="term">fragment shader</s:term> to be used in a
          <s:term type="term">program</s:term>, the set of
          <s:term type="term">inputs</s:term> <s:term type="expression">I</s:term> of the
          fragment shader must be <s:term type="term">compatible</s:term> with the set of
          <s:term type="term">outputs</s:term>
          <s:term type="expression">O</s:term> of
          the vertex shader. Specifically, for each
          <s:term type="expression">0 &lt;= s &lt;= |I| - 1</s:term>, there must be some
          <s:term type="expression">0 &lt;= t &lt;= |O| - 1</s:term> such that
          the <s:term type="term">name</s:term> and
          <s:term type="term">type</s:term> of
          <s:term type="expression">I‚Çõ</s:term> matches that of
          <s:term type="expression">O‚Çú</s:term>:
        </s:paragraph>
        <s:formal-item kind="specifications">
          <s:formal-item-title>Input/output compatibility</s:formal-item-title>
          <s:verbatim><![CDATA[‚àÄs. 0 <= s <= |I| - 1 ‚áí
  ‚àÉt. (0 <= t <= |O| - 1 ‚ãÄ ((name(I‚Çõ) = name(O‚Çú) ‚ãÄ  type(I‚Çõ) = type(O‚Çú)))]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          The set of <s:term type="term">parameters</s:term>
          <s:term type="expression">P</s:term> of the given
          given vertex shader, and the set of
          <s:term type="term">parameters</s:term>
          <s:term type="expression">Q</s:term> of the given
          fragment shader must be type-compatible if they
          share any of the same names. That is, for each
          <s:term type="expression">0 &lt;= s &lt;= |P| - 1</s:term>,
          if there is some
          <s:term type="expression">0 &lt;= t &lt;= |Q| - 1</s:term> such that
          the name of <s:term type="expression">P‚Çõ</s:term> equals
          that of <s:term type="expression">Q‚Çú</s:term>, then the
          type of <s:term type="expression">P‚Çõ</s:term> must equal
          that of <s:term type="expression">Q‚Çú</s:term>.
        </s:paragraph>
        <s:formal-item kind="specifications">
          <s:formal-item-title>Input/output compatibility</s:formal-item-title>
          <s:verbatim><![CDATA[‚àÄs. 0 <= s <= |P| - 1 ‚áí
  ‚àÉt. (0 <= t <= |Q| - 1 ‚ãÄ name(I‚Çõ) = name(O‚Çú)) ‚áí
    type(I‚Çõ) = type(O‚Çú)]]></s:verbatim>
        </s:formal-item>
      </s:subsection>
      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.shaders.program.examples">
        <s:subsection-title>Examples</s:subsection-title>
        <s:formal-item kind="examples">
          <s:formal-item-title>Examples</s:formal-item-title>
          <s:verbatim><![CDATA[
shader program p is
  vertex p;
  fragment f;
end;]]></s:verbatim>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.declarations.modules">
      <s:section-title>Modules</s:section-title>

      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          A <s:term type="term">module</s:term> is a organizational unit
          containing
          <s:link target="com.io7m.parasol.1.0.0.declarations.terms">terms</s:link>,
          <s:link target="com.io7m.parasol.1.0.0.declarations.types">types</s:link>, and
          <s:link target="com.io7m.parasol.1.0.0.declarations.shaders">shaders</s:link>.
          Modules exist solely to partition the namespace into separate sections
          to allow for ease of code re-use across projects.
        </s:paragraph>
      </s:subsection>

      <s:subsection>
        <s:subsection-title>Declarations</s:subsection-title>
        <s:paragraph>
          A <s:term type="term">module_declaration</s:term> declares
          a new <s:term type="term">module</s:term>.
        </s:paragraph>
      </s:subsection>

      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.modules.names">
        <s:subsection-title>Names</s:subsection-title>
        <s:paragraph>
          The names selected for modules must be unique with respect to
          other modules within the <s:link target="com.io7m.parasol.1.0.0.declarations.packages">package</s:link>
          in which they are defined. That is, there cannot be two modules with the same name
          in the same package.
        </s:paragraph>
        <s:paragraph>
          The following restrictions apply when naming modules:
        </s:paragraph>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>Name restrictions</s:formal-item-title>
          <s:list-unordered>
            <s:list-item>
              Module names must begin with an <s:term type="term">uppercase</s:term>
              letter. This is directly implied by the
              <s:link target="com.io7m.parasol.1.0.0.declarations.modules.syntax">grammar</s:link>.
            </s:list-item>
            <s:list-item>
              Names cannot contain two adjacent underscores (<s:term type="constant">U+005F</s:term>).
            </s:list-item>
            <s:list-item>
              Names cannot end with underscores (<s:term type="constant">U+005F</s:term>).
            </s:list-item>
            <s:list-item>
              Names cannot start with the character sequence "<s:term type="constant">GL_</s:term>"
              (<s:term type="constant">U+0047</s:term>,
               <s:term type="constant">U+004C</s:term>,
               <s:term type="constant">U+005F</s:term>).
            </s:list-item>
            <s:list-item>
              Names cannot match any of the keywords or reserved words defined in
              any version of the OpenGL shading language. See the
              <s:link target="com.io7m.parasol.1.0.0.glsl-identifiers">GLSL identifiers</s:link>
              section for the complete list.
            </s:list-item>
          </s:list-unordered>
        </s:formal-item>
      </s:subsection>

      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.modules.imports">
        <s:subsection-title>Imports</s:subsection-title>
        <s:paragraph>
          A <s:term type="term">module</s:term> may <s:term type="term">import</s:term>
          any number of modules via <s:term type="term">import_declarations</s:term>. An
          <s:term type="term">import_declaration</s:term>, given in module
          <s:term type="variable">X</s:term>,
          specifies a name of a module <s:term type="variable">Y</s:term>
          prefixed with the name of the
          <s:link target="com.io7m.parasol.1.0.0.declarations.packages">package</s:link>
          in which the module <s:term type="variable">Y</s:term> was defined. The
          <s:term type="term">terms</s:term>, <s:term type="term">types</s:term>, and
          <s:term type="term">shaders</s:term> of <s:term type="variable">Y</s:term>
          are then accessible in
          <s:term type="variable">X</s:term> by qualifying
          their names with <s:term type="variable">Y</s:term>. As an example:
        </s:paragraph>
        <s:formal-item kind="examples">
          <s:formal-item-title>Module import example</s:formal-item-title>
          <s:verbatim><![CDATA[package com.example;

module Y is
  value k = 23;
end;

module X is
  import com.example.Y;
  value z = Y.k;
end;]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          The value of <s:term type="expression">X.z</s:term> is
          <s:term type="expression">23</s:term>.
        </s:paragraph>
        <s:paragraph>
          Because two modules defined in different packages can have the
          same names, it is possible for imports to <s:term type="term">collide</s:term>:
          If a <s:term type="variable">X</s:term> imports both
          modules <s:term type="expression">com.example_0.Y</s:term> and
          <s:term type="expression">com.example_1.Y</s:term>, then
          the name <s:term type="expression">Y</s:term> will be introduced twice.
          An <s:term type="term">import_declaration</s:term> may therefore provide
          an optional name to disambiguate imported modules:
        </s:paragraph>
        <s:formal-item kind="examples">
          <s:formal-item-title>Module import renaming</s:formal-item-title>
          <s:verbatim><![CDATA[package com.example;

module X is
  import com.example_0.Y;
  import com.example_1.Y as Z;

  value z = Y.k;
  value q = Z.p;
end;]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          If a module <s:term type="variable">X</s:term>
          imports a module
          <s:term type="variable">Y</s:term> as <s:term type="variable">Z</s:term>,
          the
          <s:term type="term">terms</s:term>, <s:term type="term">types</s:term>, and
          <s:term type="term">shaders</s:term> of <s:term type="variable">Y</s:term>
          are then accessible in
          <s:term type="variable">X</s:term> by qualifying
          their names with <s:term type="variable">Z</s:term>.
        </s:paragraph>
        <s:paragraph>
          The imported names of modules are <s:term type="emphasis">not</s:term>
          visible outside of the module in which they are imported. For example, if
          a module <s:term type="variable">X</s:term> imports a module
          <s:term type="variable">Y</s:term>, and <s:term type="variable">Y</s:term>
          imports a module <s:term type="variable">Z</s:term>, the module
          <s:term type="variable">Z</s:term> is
          <s:term type="emphasis">not</s:term>
          visible as
          <s:term type="variable">Y.Z</s:term>.
        </s:paragraph>
      </s:subsection>

      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.modules.recursion">
        <s:subsection-title>Recursion</s:subsection-title>
        <s:paragraph>
          No <s:term type="term">module_declaration</s:term> can be <s:term type="term">recursive</s:term>
          with respect to itself or any other <s:term type="term">module_declaration</s:term>.
        </s:paragraph>
        <s:paragraph>
          A <s:term type="term">module_declaration</s:term> <s:term type="variable">d</s:term>
          is (mutually) <s:term type="term">recursive</s:term> iff:
        </s:paragraph>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>Recursion conditions</s:formal-item-title>
          <s:list-unordered>
            <s:list-item>
              <s:term type="variable">d</s:term> imports itself.
            </s:list-item>
            <s:list-item>
              There is a sequence of modules <s:term type="expression">d‚ÇÄ, d‚ÇÅ, ..., d‚Çô</s:term>
              such that <s:term type="variable">d</s:term> imports
              <s:term type="variable">d‚ÇÄ</s:term>, and
              for all <s:term type="variable">m</s:term> where <s:term type="expression">0 &lt;= m &lt; n</s:term>,
              <s:term type="variable">d‚Çò</s:term> imports
              <s:term type="expression">d‚Çç‚Çò‚Çä‚ÇÅ‚Çé</s:term>, and
              <s:term type="variable">d‚Çô</s:term> imports
              <s:term type="variable">d</s:term>.
            </s:list-item>
          </s:list-unordered>
        </s:formal-item>
      </s:subsection>

      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.modules.syntax">
        <s:subsection-title>Syntax</s:subsection-title>
        <s:paragraph>
          The precise syntax of module declarations is given by the following
          EBNF:
        </s:paragraph>
      <s:formal-item kind="specifications" type="specifications">
        <s:formal-item-title>Module declaration syntax</s:formal-item-title>
        <s:verbatim><![CDATA[package_path =
  name_lower , { "." , name_lower } ;

import_path =
  package_path , "." , name_upper ;

import_declaration =
  "import" , import_path , [ "as" , name_upper ] ;

import_declarations =
  { import_declaration , ";" } ;

module_level_declarations =
  { value_declarations | function_declarations | type_declarations | shader_declarations } ;

module_declaration =
  "module" , name_upper , "is" ,
  import_declarations ,
  module_level_declarations ,
  "end" ;

module_declarations =
  module_declaration , ";" , { module_declaration , ";" } ;]]></s:verbatim>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.declarations.packages">
      <s:section-title>Packages</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          <s:term type="term">Packages</s:term> are to
          <s:link target="com.io7m.parasol.1.0.0.declarations.modules">modules</s:link>
          as
          <s:link target="com.io7m.parasol.1.0.0.declarations.modules">modules</s:link>
          are to
          <s:link target="com.io7m.parasol.1.0.0.declarations.terms">terms</s:link>,
          <s:link target="com.io7m.parasol.1.0.0.declarations.types">types</s:link>, and
          <s:link target="com.io7m.parasol.1.0.0.declarations.shaders">shaders</s:link>.
          <s:term type="term">Packages</s:term> provide a non-hierarchical partitioned
          namespace that separates <s:term type="term">modules</s:term> for ease
          of code re-use across projects.
        </s:paragraph>
      </s:subsection>

      <s:subsection>
        <s:subsection-title>Declarations</s:subsection-title>
        <s:paragraph>
          A <s:term type="term">package_declaration</s:term> declares that the
          current <s:link target="com.io7m.parasol.1.0.0.lex.units">unit</s:link>
          will contain declarations that will be placed in the named package.
        </s:paragraph>
        <s:paragraph>
          Multiple <s:term type="term">units</s:term> can contain the same
          <s:term type="term">package_declaration</s:term>, however a single
          <s:term type="term">unit</s:term> must contain exactly one
          <s:term type="term">package_declaration</s:term>.
        </s:paragraph>
      </s:subsection>

      <s:subsection xml:id="com.io7m.parasol.1.0.0.declarations.packages.syntax">
        <s:subsection-title>Syntax</s:subsection-title>
        <s:paragraph>
          The precise syntax of package declarations is given by the following
          EBNF:
        </s:paragraph>
      <s:formal-item kind="specifications" type="specifications">
        <s:formal-item-title>Package declaration syntax</s:formal-item-title>
        <s:verbatim><![CDATA[package_path =
  name_lower , { "." , name_lower } ;

package_declaration =
  "package" , package_path ;]]></s:verbatim>
        </s:formal-item>
      </s:subsection>
    </s:section>
  </s:part>

  <s:part xml:id="com.io7m.parasol.1.0.0.expressions">
    <s:part-title>Expressions</s:part-title>
    <s:part-contents/>

    <s:section xml:id="com.io7m.parasol.1.0.0.expressions.overview">
      <s:section-title>Description</s:section-title>
      <s:subsection>
        <s:subsection-title>Overview</s:subsection-title>
        <s:paragraph>
          An <s:term type="term">expression</s:term> is a computation
          that evaluates to a <s:term type="term">value</s:term>
          of a single <s:link target="com.io7m.parasol.1.0.0.types">type</s:link>
          according to the rules given in the
          operational semantics for each expression form.
          Expressions may be one of the following forms:
        </s:paragraph>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>Expression forms</s:formal-item-title>
          <s:list-unordered>
            <s:list-item>An <s:link target="com.io7m.parasol.1.0.0.expressions.integer_literal">integer literal</s:link>. For example: <s:term type="expression">23</s:term></s:list-item>
            <s:list-item>A <s:link target="com.io7m.parasol.1.0.0.expressions.real_literal">real literal</s:link>. For example: <s:term type="expression">23.0</s:term></s:list-item>
            <s:list-item>A <s:link target="com.io7m.parasol.1.0.0.expressions.boolean_literal">boolean literal</s:link>. For example: <s:term type="expression">true</s:term></s:list-item>
            <s:list-item>A <s:link target="com.io7m.parasol.1.0.0.expressions.variable">variable</s:link>. For example: <s:term type="expression">x</s:term></s:list-item>
            <s:list-item>A <s:link target="com.io7m.parasol.1.0.0.expressions.function_application">function application</s:link>. For example: <s:term type="expression">f (x, y)</s:term></s:list-item>
            <s:list-item>A <s:link target="com.io7m.parasol.1.0.0.expressions.conditional">conditional</s:link>. For example: <s:term type="expression">if x then y else z end</s:term></s:list-item>
            <s:list-item>A <s:link target="com.io7m.parasol.1.0.0.expressions.let">let</s:link> block. For example: <s:term type="expression">let value x = 23; value y = 23; in f (x, y) end</s:term></s:list-item>
            <s:list-item>The construction of a <s:link target="com.io7m.parasol.1.0.0.expressions.new">new</s:link> value. For example: <s:term type="expression">new vector_3f (1.0, 2.0, 3.0)</s:term></s:list-item>
            <s:list-item>A <s:link target="com.io7m.parasol.1.0.0.expressions.record">record</s:link> value. For example: <s:term type="expression">record t { x = 23, y = 24 }</s:term></s:list-item>
            <s:list-item>A <s:link target="com.io7m.parasol.1.0.0.expressions.record_projection">record projection</s:link>. For example: <s:term type="expression">e.x</s:term>, for some expression <s:term type="variable">e</s:term>.</s:list-item>
            <s:list-item>A vector <s:link target="com.io7m.parasol.1.0.0.expressions.swizzle">swizzle</s:link>. For example: <s:term type="expression">e [x x y z]</s:term>, for some expression <s:term type="variable">e</s:term>.</s:list-item>
          </s:list-unordered>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Operational Semantics</s:subsection-title>
        <s:paragraph>
          The operational semantics for each expression form appears
          in the respective sections for each. The following syntactic forms
          are considered to be values:
        </s:paragraph>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>Values (values)</s:formal-item-title>
          <s:image source="op_values.png">Values (values)</s:image>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.expressions.syntax">
      <s:section-title>Syntax</s:section-title>
      <s:paragraph>
        The precise syntax of expressions is given by the following
        EBNF:
      </s:paragraph>
      <s:formal-item kind="specifications" type="specifications">
        <s:formal-item-title>Expression syntax</s:formal-item-title>
        <s:verbatim><![CDATA[term_path =
    name_lower
  | name_upper , "." , name_lower ;

type_path =
    name_lower
  | name_upper , "." , name_lower ;

variable_or_application_expression =
  term_path [ "(" , expression , { "," , expression } , ")" ]
  ;

new_parameters =
  "(" , expression , { "," , expression } , ")" ;

new_expression =
  "new" , type_path , new_parameters ;

record_expression_fields =
  "{" , name_lower , "=" , expression , { "," name_lower , "=" , expression } , "}" ;

record_expression =
  "record" , type_path , record_expression_fields ;

local_declaration =
  "value" , name_lower , [ ":" , type_path ] , "=" , expression ;

local_declarations =
  local_declaration , ";" , { local_declarations } ;

let_expression =
  "let" , local_declarations , "in" , expression , "end" ;

conditional_expression =
  "if" , expression , "then" , expression , "else" , expression , "end" ;

expression_pre =
    integer_literal
  | real_literal
  | boolean_literal
  | variable_or_application_expression
  | conditional_expression
  | let_expression
  | new_expression
  | record_expression
  ;

expression_projection =
  "." , name_lower ;

expression_swizzle_names =
  "[" , name_lower , { "," , name_lower } , "]" ;

expression =
  expression_pre , { expression_swizzle | expression_projection } ;
]]></s:verbatim>
      </s:formal-item>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.expressions.integer_literal">
      <s:section-title>Integer literal</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          An <s:term type="term">integer_literal</s:term> is a simple
          integer value.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Type rules</s:subsection-title>
        <s:paragraph>
          <s:term type="term">integer_literal</s:term> expressions are of type
          <s:link target="com.io7m.parasol.1.0.0.types.integer">integer</s:link>,
          where <s:term type="variable">‚Ñ§</s:term> represents the
          literal:
        </s:paragraph>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>Integer literal type rule (integer_constant)</s:formal-item-title>
          <s:image source="ty_integer_constant.png">Integer literal type rule (integer_constant)</s:image>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Operational semantics</s:subsection-title>
        <s:paragraph>
          <s:term type="term">integer_literal</s:term> expressions are <s:term type="term">values</s:term>
          by definition, and are equal to the value of the literal.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.expressions.real_literal">
      <s:section-title>Real literal</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          A <s:term type="term">real_literal</s:term> is a simple
          real-number value.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Type rules</s:subsection-title>
        <s:paragraph>
          <s:term type="term">Real literal</s:term> expressions are of type
          <s:link target="com.io7m.parasol.1.0.0.types.float">float</s:link>,
          where <s:term type="variable">‚Ñù</s:term> represents the
          literal:
        </s:paragraph>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>Real literal type rule (float_constant)</s:formal-item-title>
          <s:image source="ty_float_constant.png">Real literal type rule (float_constant)</s:image>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Operational semantics</s:subsection-title>
        <s:paragraph>
          <s:term type="term">real_literal</s:term> expressions are <s:term type="term">values</s:term>
          by definition, and are equal to the value of the literal.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.expressions.boolean_literal">
      <s:section-title>Boolean literal</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          A <s:term type="term">boolean_literal</s:term> is a simple
          <s:term type="keyword">true</s:term> or
          <s:term type="keyword">false</s:term> value.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Type rules</s:subsection-title>
        <s:paragraph>
          <s:term type="term">boolean_literal</s:term> expressions are of type
          <s:link target="com.io7m.parasol.1.0.0.types.boolean">boolean</s:link>:
        </s:paragraph>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>Boolean true literal type rule (true_constant)</s:formal-item-title>
          <s:image source="ty_true_constant.png">Boolean true literal type rule (true_constant)</s:image>
        </s:formal-item>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>Boolean false literal type rule (false_constant)</s:formal-item-title>
          <s:image source="ty_false_constant.png">Boolean false literal type rule (false_constant)</s:image>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Operational semantics</s:subsection-title>
        <s:paragraph>
          <s:term type="term">Boolean literal</s:term> expressions are <s:term type="term">values</s:term>
          by definition, and are equal to the value of the literal.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.expressions.variable">
      <s:section-title>Variable</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          A <s:term type="term">variable</s:term> expression is a simple
          reference to a variable in the current environment.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Type rules</s:subsection-title>
        <s:paragraph>
          For <s:term type="term">variable</s:term> expressions, if a variable <s:term type="variable">x</s:term>
          is of type <s:term type="variable">t</s:term> in the current environment, then
          the result of evaluating the variable has type <s:term type="variable">t</s:term>:
        </s:paragraph>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>Variable type rule (variable)</s:formal-item-title>
          <s:image source="ty_variable.png">Variable type rule (variable)</s:image>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Operational semantics</s:subsection-title>
        <s:paragraph>
          Variables are replaced with their values during the evaluation of
          <s:link target="com.io7m.parasol.1.0.0.expressions.function_application">functions</s:link>,
          <s:link target="com.io7m.parasol.1.0.0.expressions.let">let</s:link> expressions, and
          top-level
          <s:link target="com.io7m.parasol.1.0.0.declarations.terms.semantics">value</s:link>
          declarations.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.expressions.function_application">
      <s:section-title>Function application</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          A <s:term type="term">function_application</s:term> expression applies
          a given function <s:term type="variable">f</s:term> to an n-tuple of
          argument expressions.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Type rules</s:subsection-title>
        <s:paragraph>
          For <s:term type="term">function_application</s:term> expressions, if a function <s:term type="variable">f</s:term>
          takes an n-tuple of values of types <s:term type="type">(t‚ÇÄ ‚úï ... ‚úï t‚Çô)</s:term> and
          returns a value of type <s:term type="type">u</s:term>, then applying
          <s:term type="variable">f</s:term> to an n-tuple of expressions of the
          corresponding types, results in a value of type <s:term type="type">u</s:term>:
        </s:paragraph>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>Function application type rule (function_application)</s:formal-item-title>
          <s:image source="ty_function_application.png">Function application type rule (function_application)</s:image>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Operational semantics</s:subsection-title>
        <s:paragraph>
          For a <s:term type="term">function_application</s:term> expression
          <s:term type="expression">e</s:term>, expressions
          passed to the function are evaluated from left-to-right by rules
          <s:term type="constant">function_application_left_0</s:term> and
          <s:term type="constant">function_application_left_1</s:term>, and when all of
          the arguments have evaluated to values, the variables in the body of the
          function are substituted with the values of the arguments and the expression
          as a whole is evaluated, by rule
          <s:term type="constant">function_application_body</s:term>.
        </s:paragraph>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>Function application semantics (function_application)</s:formal-item-title>
          <s:image source="op_function_application.png">Function application semantics (function_application)</s:image>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.expressions.conditional">
      <s:section-title>Conditional</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          A <s:term type="term">conditional</s:term> expression evaluates
          to the expression in either of its defined
          <s:term type="term">branches</s:term> based on a given
          <s:term type="term">condition</s:term>.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Type rules</s:subsection-title>
        <s:paragraph>
          For <s:term type="term">conditional</s:term> expressions, if the condition is of type
          <s:link target="com.io7m.parasol.1.0.0.types.boolean">boolean</s:link>, and both
          branches are of type <s:term type="type">t</s:term>, then evaluating
          the expression results in a value of type <s:term type="type">t</s:term>:
        </s:paragraph>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>Conditional type rule (conditional)</s:formal-item-title>
          <s:image source="ty_conditional.png">Conditional type rule (conditional)</s:image>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Operational semantics</s:subsection-title>
        <s:paragraph>
          For a <s:term type="term">conditional</s:term> expression
          <s:term type="expression">e</s:term>, the
          condition of the expression is evaluated, if it is not already a
          <s:term type="term">value</s:term>, by rule
          <s:term type="constant">if_condition</s:term>. If the
          condition is <s:term type="constant">true</s:term>,
          <s:term type="expression">e</s:term>
          evaluates to the expression in the left branch, by rule
          <s:term type="constant">if_true</s:term>. If the condition is
          <s:term type="constant">false</s:term>,
          <s:term type="expression">e</s:term> evaluates
          to the expression in the right branch, by rule
          <s:term type="constant">if_false</s:term>.
        </s:paragraph>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>Conditional semantics (condition)</s:formal-item-title>
          <s:image source="op_conditional.png">Conditional semantics (condition)</s:image>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.expressions.let">
      <s:section-title>Let</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          A <s:term type="term">let_expression</s:term> consists of a sequence of
          <s:term type="term">local_value_declarations</s:term> and a body consisting
          of a single <s:term type="term">expression</s:term>. The
          <s:term type="term">local_value_declarations</s:term> differ from
          top-level <s:link target="com.io7m.parasol.1.0.0.declarations.terms.values">value_declarations</s:link>
          in that the order of declaration is significant, and it is legal for
          multiple <s:term type="term">local_value_declarations</s:term> to have
          the same name, with each new declaration hiding any previous declarations
          (including top level declarations) with the same name.
        </s:paragraph>
        <s:paragraph>
          The same rules apply for <s:term type="term">local_value_declarations</s:term> with regards to
          <s:link target="com.io7m.parasol.1.0.0.declarations.terms.recursion">recursion</s:link> as
          any other term declaration.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Type rules</s:subsection-title>
        <s:paragraph>
          For <s:term type="term">let_expressions</s:term>, if each successive
          <s:term type="term">local_value_declaration</s:term> is well-typed (with
          respect to the environment and the preceding
          <s:term type="term">local_value_declarations</s:term>), and
          the body of the expression (denoted <s:term type="variable">y</s:term>)
          is of type <s:term type="type">t</s:term>,
          then evaluating the expression results in a value of type
          <s:term type="type">t</s:term>:
        </s:paragraph>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>Let type rule (let)</s:formal-item-title>
          <s:image source="ty_let.png">Let type rule (let)</s:image>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Operational semantics</s:subsection-title>
        <s:paragraph>
          For a <s:term type="term">let</s:term> expression
          <s:term type="expression">e</s:term>, the
          <s:term type="term">local_value_declarations</s:term> are evaluated
          from top-to-bottom with each of the previously evaluated
          declarations being substituted into the current declaration
          before evaluation, by rule
          <s:term type="constant">let_locals</s:term>. When all
          of the declarations have been evaluated, the values of the
          declarations are subsituted into the body of the
          <s:term type="term">let</s:term>
          and <s:term type="expression">e</s:term> evaluates to the
          resulting expression, by rule
          <s:term type="constant">let_body</s:term>.
        </s:paragraph>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>Let semantics (let)</s:formal-item-title>
          <s:image source="op_let.png">Let semantics (let)</s:image>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.expressions.record_projection">
      <s:section-title>Record Projection</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          A <s:term type="term">record_projection</s:term> expression returns
          the value of a field from an expression
          <s:term type="expression">r</s:term>, which is expected to be of a
          <s:link target="com.io7m.parasol.1.0.0.types.records">record</s:link>
          type.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Type rules</s:subsection-title>
        <s:paragraph>
          For <s:term type="term">record_projection</s:term> expressions, if an expression
          <s:term type="expression">r</s:term> is of type <s:term type="type">t</s:term>,
          and <s:term type="type">t</s:term> is a record type
          with fields <s:term type="variable">ùîΩ‚Çò</s:term>
          to <s:term type="variable">ùîΩ‚Çô</s:term>, of types
          <s:term type="type">t‚Çò</s:term> to <s:term type="type">t‚Çô</s:term>,
          then accessing field <s:term type="variable">ùîΩ‚Çñ</s:term> of
          <s:term type="expression">r</s:term>, where
          <s:term type="expression">k ‚àà [m, n]</s:term>, results in
          a value of type <s:term type="type">t‚Çñ</s:term>:
        </s:paragraph>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>Record projection type rule (record_projection)</s:formal-item-title>
          <s:image source="ty_record_projection.png">Record projection type rule (record_projection)</s:image>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Operational semantics</s:subsection-title>
        <s:paragraph>
          For a <s:term type="term">record_projection</s:term> expression
          <s:term type="expression">e</s:term>,
          the left hand side of the expression is evaluated, by rule
          <s:term type="constant">record_projection_pre</s:term>, and then
          <s:term type="expression">e</s:term> evaluates to the
          value associated with the label <s:term type="expression">k</s:term>
          by rule <s:term type="constant">record_projection_value</s:term>.
        </s:paragraph>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>Record projection semantics (record_projection)</s:formal-item-title>
          <s:image source="op_record_projection.png">Record projection semantics (record_projection)</s:image>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.expressions.record">
      <s:section-title>Record</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          A <s:term type="term">record_expression</s:term> constructs
          a new value of a
          <s:link target="com.io7m.parasol.1.0.0.types.records">record</s:link>
          type.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Type rules</s:subsection-title>
        <s:paragraph>
          If a record type <s:term type="type">t</s:term> exists in the current
          environment, then a record expression creates a new value of type
          <s:term type="type">t</s:term>. Note that the type rule implies that
          all <s:term type="term">fields</s:term> of the corresponding
          record type must be specified exactly once.
        </s:paragraph>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>Record expression type rule (record_expression)</s:formal-item-title>
          <s:image source="ty_record_expression.png">Record expression type rule (record_expression)</s:image>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Operational semantics</s:subsection-title>
        <s:paragraph>
          A <s:term type="term">record_expression</s:term> is
          a set of distinct
          <s:link target="com.io7m.parasol.1.0.0.types.records">record</s:link>
          field labels with associated expressions. The expressions
          associated with each field are evaluated in the order that they appear
          in the source code, by rules
          <s:term type="constant">record_expression_0</s:term> and
          <s:term type="constant">record_expression_1</s:term>, resulting in
          a new value of type <s:term type="type">t</s:term>.
        </s:paragraph>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>Record expression semantics (record_expression)</s:formal-item-title>
          <s:image source="op_record_expression.png">Record expression semantics (record_expression)</s:image>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.expressions.swizzle">
      <s:section-title>Swizzle</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          A <s:term type="term">swizzle_expression</s:term> selects one or
          more named components of an expression of a
          <s:link target="com.io7m.parasol.1.0.0.types.vector">vector</s:link>
          type, returning either a
          scalar value, or another <s:term type="term">vector</s:term>.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Type rules</s:subsection-title>
        <s:paragraph>
          For <s:term type="term">swizzle_expressions</s:term>, special type rules
          apply as described in the
          <s:link target="com.io7m.parasol.1.0.0.types.vector">Vectors</s:link>
          section of the
          <s:link target="com.io7m.parasol.1.0.0.types">Types</s:link> section.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Operational semantics</s:subsection-title>
        <s:paragraph>
          For a <s:term type="term">swizzle_expression</s:term>
          <s:term type="expression">e</s:term>,
          the left hand side of the expression is evaluated, by rule
          <s:term type="constant">swizzle_pre</s:term>, and the
          resulting expression is a new vector or scalar value.
        </s:paragraph>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>Swizzle semantics (swizzle)</s:formal-item-title>
          <s:image source="op_swizzle.png">Swizzle semantics (swizzle)</s:image>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.expressions.new">
      <s:section-title>New</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          A <s:term type="term">new_expression</s:term> creates a new
          value of a given type, initialized with the values of the given
          expressions.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Type rules</s:subsection-title>
        <s:paragraph>
          For <s:term type="term">new_expression</s:term>,
          that construct values of types with the
          <s:term type="keyword">new</s:term> keyword, special type rules
          apply as described in the
          <s:link target="com.io7m.parasol.1.0.0.types.constructors">Constructors</s:link>
          section of the
          <s:link target="com.io7m.parasol.1.0.0.types">Types</s:link> section.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Operational semantics</s:subsection-title>
        <s:paragraph>
          A <s:term type="term">new_expression</s:term> is of the
          form <s:term type="expression">new t x</s:term>, where
          the <s:term type="expression">x</s:term> is an n-tuple
          of expressions given as
          <s:link target="com.io7m.parasol.1.0.0.types.constructors">constructor</s:link>
          arguments. The expressions given are evaluated from left-to-right
          by rules <s:term type="constant">new_left_0</s:term> and
          <s:term type="constant">new_left_1</s:term>, resulting in
          a new value of type <s:term type="type">t</s:term>.
        </s:paragraph>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>New semantics (new)</s:formal-item-title>
          <s:image source="op_new.png">New semantics (new)</s:image>
        </s:formal-item>
      </s:subsection>
    </s:section>
  </s:part>

  <s:part xml:id="com.io7m.parasol.1.0.0.types">
    <s:part-title>Types</s:part-title>
    <s:part-contents/>

    <s:section>
      <s:section-title>Overview</s:section-title>
      <s:paragraph>
        A <s:term type="term">type</s:term> classifies a set of
        values. Types in the <s:term type="package">parasol</s:term>
        language have <s:term type="term">by-name equivalence</s:term>
        (that is, two types are equal iff they have the same name) and
        the types of all terms are checked <s:term type="term">statically</s:term>.
        All well-typed <s:term type="term">terms</s:term> in the
        language have exactly one <s:term type="term">type</s:term>.
      </s:paragraph>
      <s:paragraph>
        The language defines a set of <s:term type="term">basic types</s:term>,
        and allows the declaration of new types. The set of basic types is:
      </s:paragraph>
      <s:formal-item kind="specifications" type="specifications">
        <s:formal-item-title>Basic types</s:formal-item-title>
        <s:list-unordered>
          <s:list-item><s:link target="com.io7m.parasol.1.0.0.types.integer">integer</s:link></s:list-item>
          <s:list-item><s:link target="com.io7m.parasol.1.0.0.types.float">float</s:link></s:list-item>
          <s:list-item><s:link target="com.io7m.parasol.1.0.0.types.boolean">boolean</s:link></s:list-item>
          <s:list-item><s:link target="com.io7m.parasol.1.0.0.types.vector">vector_2i</s:link></s:list-item>
          <s:list-item><s:link target="com.io7m.parasol.1.0.0.types.vector">vector_3i</s:link></s:list-item>
          <s:list-item><s:link target="com.io7m.parasol.1.0.0.types.vector">vector_4i</s:link></s:list-item>
          <s:list-item><s:link target="com.io7m.parasol.1.0.0.types.vector">vector_2f</s:link></s:list-item>
          <s:list-item><s:link target="com.io7m.parasol.1.0.0.types.vector">vector_3f</s:link></s:list-item>
          <s:list-item><s:link target="com.io7m.parasol.1.0.0.types.vector">vector_4f</s:link></s:list-item>
          <s:list-item><s:link target="com.io7m.parasol.1.0.0.types.matrix">matrix_3x3f</s:link></s:list-item>
          <s:list-item><s:link target="com.io7m.parasol.1.0.0.types.matrix">matrix_4x4f</s:link></s:list-item>
          <s:list-item><s:link target="com.io7m.parasol.1.0.0.types.samplers">sampler_2d</s:link></s:list-item>
          <s:list-item><s:link target="com.io7m.parasol.1.0.0.types.samplers">sampler_cube</s:link></s:list-item>
        </s:list-unordered>
      </s:formal-item>
      <s:paragraph>
        Values of the basic types may be introduced via certain
        <s:link target="com.io7m.parasol.1.0.0.expressions">literal expressions</s:link>,
        or via the use of the <s:term type="keyword">new</s:term>
        keyword, which invokes an appropriate
        <s:link target="com.io7m.parasol.1.0.0.types.constructors">constructor function</s:link>
        for the given type. The <s:term type="term">constructor function</s:term>
        chosen is based upon the n-tuple of arguments presented to the
        <s:term type="keyword">new</s:term> keyword, and if no appropriate function
        exists, the expression is rejected as ill-typed.
      </s:paragraph>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.types.constructors">
      <s:section-title>Constructors</s:section-title>
      <s:paragraph>
        Each of the basic types have zero or more associated
        anonymous <s:term type="term">constructor functions</s:term>
        (often abbreviated to <s:term type="term">constructors</s:term>)
        which are responsible for introducing values of the types into the
        environment. An expression of the form
        <s:term type="expression">new s (x‚ÇÄ : t‚ÇÄ, ..., x‚Çô : t‚Çô)</s:term> has
        type <s:term type="type">s</s:term> iff
        there is a <s:term type="term">constructor</s:term> for
        <s:term type="type">s</s:term> of type
        <s:term type="type">(t‚ÇÄ ‚úï ... t‚Çô) ‚Üí s</s:term>.
      </s:paragraph>
      <s:paragraph>
        The descriptions for each of the basic types describe the
        available <s:term type="term">constructors</s:term> for
        each.
      </s:paragraph>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.types.integer">
      <s:section-title>Integer</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          The <s:term type="type">integer</s:term> type represents a signed,
          <s:term type="constant">32</s:term> bit, two's-complement integer.
          Values outside of the range
          <s:term type="expression">[-(2¬≥¬π), (2¬≥¬π) - 1]</s:term> are silently
          wrapped to produce the low-order <s:term type="constant">32</s:term>
          bits of the result.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Constructors</s:subsection-title>
        <s:paragraph>
          The type has a single <s:term type="term">constructor</s:term> of
          type <s:term type="type">integer ‚Üí integer</s:term>.
        </s:paragraph>
        <s:paragraph>
          The <s:term type="type">integer</s:term> type is a
          <s:term type="term">scalar</s:term> type. As with the other
          <s:term type="term">scalar</s:term> types, the
          type rule for the construction of values of type
          <s:term type="type">integer</s:term> is:
        </s:paragraph>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>Scalar new type rule (new_scalar)</s:formal-item-title>
          <s:image source="ty_new_scalar.png">Scalar new type rule (new_scalar)</s:image>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.types.float">
      <s:section-title>Float</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          The <s:term type="type">float</s:term> type represents a single-precision
          IEEE754 floating point number.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Constructors</s:subsection-title>
        <s:paragraph>
          The type has a single <s:term type="term">constructor</s:term> of
          type <s:term type="type">float ‚Üí float</s:term>.
        </s:paragraph>
        <s:paragraph>
          The <s:term type="type">float</s:term> type is a
          <s:term type="term">scalar</s:term> type. As with the other
          <s:term type="term">scalar</s:term> types, the
          type rule for the construction of values of type
          <s:term type="type">float</s:term> is:
        </s:paragraph>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>Scalar new type rule (new_scalar)</s:formal-item-title>
          <s:image source="ty_new_scalar.png">Scalar new type rule (new_scalar)</s:image>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.types.boolean">
      <s:section-title>Boolean</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          The <s:term type="type">boolean</s:term> type represents a
          <s:term type="constant">true</s:term> or <s:term type="constant">false</s:term>
          value.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Constructors</s:subsection-title>
        <s:paragraph>
          The type has a single <s:term type="term">constructor</s:term> of
          type <s:term type="type">boolean ‚Üí boolean</s:term>.
        </s:paragraph>
        <s:paragraph>
          The <s:term type="type">boolean</s:term> type is a
          <s:term type="term">scalar</s:term> type. As with the other
          <s:term type="term">scalar</s:term> types, the
          type rule for the construction of values of type
          <s:term type="type">boolean</s:term> is:
        </s:paragraph>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>Scalar new type rule (new_scalar)</s:formal-item-title>
          <s:image source="ty_new_scalar.png">Scalar new type rule (new_scalar)</s:image>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.types.vector">
      <s:section-title>Vectors</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          The <s:term type="type">vector_NT</s:term> types represent
          fixed-length vectors, where <s:term type="expression">N ‚àà [2, 4]</s:term>
          and represents the number of components in the vector,
          and <s:term type="expression">T ‚àà {f, i}</s:term>
          where <s:term type="constant">f</s:term> indicates that the components
          of the vector are of type
          <s:link target="com.io7m.parasol.1.0.0.types.float">float</s:link>
          and <s:term type="constant">i</s:term>
          indicates that the components of the vector are of type
          <s:link target="com.io7m.parasol.1.0.0.types.integer">integer</s:link>.
        </s:paragraph>
        <s:paragraph>
          The components of the <s:term type="type">vector_NT</s:term> types
          are labelled, in order, from the n-tuple of labels
          <s:term type="expression">K = (x, y, z, w)</s:term>.
          At most <s:term type="expression">N</s:term> labels are used for each type,
          so the first, second, third, and fourth elements of the
          <s:term type="type">vector_4T</s:term> types are labelled
          <s:term type="constant">x</s:term>, <s:term type="constant">y</s:term>,
          <s:term type="constant">z</s:term>, and <s:term type="constant">w</s:term>,
          respectively. The <s:term type="type">vector_3T</s:term> types lack a
          <s:term type="constant">w</s:term> component, and the
          <s:term type="type">vector_2T</s:term> types lack both
          <s:term type="constant">z</s:term> and <s:term type="constant">w</s:term>
          components.
        </s:paragraph>
        <s:paragraph>
          The values of the components of the <s:term type="type">vector_NT</s:term> types
          are extracted via <s:term type="term">swizzle</s:term> expressions. A
          <s:term type="term">swizzle</s:term> expression consists of an n-tuple
          <s:term type="expression">S‚Çö</s:term>
          of labels taken from the set <s:term type="expression">S = tuples(L, M)</s:term> of
          n-tuples, where
          <s:term type="expression">M &lt;= N</s:term>,
          <s:term type="expression">L</s:term> is the first
          <s:term type="expression">M - 1</s:term> elements of <s:term type="expression">K</s:term>,
          and <s:term type="expression">0 &lt;= P &lt;= |S|</s:term>,
          and evaluates to
          a value of type <s:term type="type">vector_MT</s:term>
          or, in the case that <s:term type="expression">M = 1</s:term>,
          a scalar value of type <s:term type="type">T</s:term>,
          consisting of the values of the components named in <s:term type="expression">S‚Çö</s:term>:
        </s:paragraph>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>Swizzle vector type rule (vector_swizzle)</s:formal-item-title>
          <s:image source="ty_vector_swizzle.png">Swizzle vector type rule (vector_swizzle)</s:image>
        </s:formal-item>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>Swizzle scalar type rule (vector_swizzle_single)</s:formal-item-title>
          <s:image source="ty_vector_swizzle_single.png">Swizzle scalar type rule (vector_swizzle_single)</s:image>
        </s:formal-item>
        <s:paragraph>
          Algebraically, <s:term type="term">swizzling</s:term> is analogous to
          multiplication of a vector <s:term type="variable">v</s:term> of size
          <s:term type="expression">N</s:term>
          by an <s:term type="expression">NxN</s:term> matrix
          <s:term type="variable">p</s:term>, where each row of
          <s:term type="variable">p</s:term> consists of
          <s:term type="expression">N - 1</s:term> zeroes and exactly one
          <s:term type="expression">1</s:term>:
        </s:paragraph>
        <s:formal-item kind="examples">
          <s:formal-item-title>Swizzle matrix example</s:formal-item-title>
          <s:image source="ex_matrix_swizzle_example.png">Swizzle matrix example</s:image>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Constructors</s:subsection-title>
        <s:paragraph>
          The <s:term type="term">constructors</s:term> of the
          <s:term type="type">vector_NT</s:term> types
          can be conceptually divided into <s:term type="term">primary</s:term>
          and <s:term type="term">auxiliary constructors</s:term>. Each
          <s:term type="type">vector_NT</s:term> type has exactly one
          <s:term type="term">primary constructor</s:term> which initializes
          the components of the resulting <s:term type="type">vector_NT</s:term>
          value to the values of the expressions in the exact order given.
          There is no practical or visible difference between a
          <s:term type="term">primary</s:term> and
          <s:term type="term">auxiliary constructor</s:term>; the distinction
          is simply made for the purposes of describing the typing rules.
        </s:paragraph>
        <s:paragraph>
          The types of the <s:term type="term">primary constructors</s:term> for
          each type are:
        </s:paragraph>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>Vector primary constructors</s:formal-item-title>
          <s:table>
            <s:table-summary>Vector primary constructors</s:table-summary>
            <s:table-head>
              <s:table-column-name>Type</s:table-column-name>
              <s:table-column-name>Constructor type</s:table-column-name>
            </s:table-head>
            <s:table-body>
              <s:table-row>
                <s:table-cell><s:term type="type">vector_2i</s:term></s:table-cell>
                <s:table-cell><s:term type="type">(integer, integer) ‚Üí vector_2i</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term type="type">vector_3i</s:term></s:table-cell>
                <s:table-cell><s:term type="type">(integer, integer, integer) ‚Üí vector_3i</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term type="type">vector_4i</s:term></s:table-cell>
                <s:table-cell><s:term type="type">(integer, integer, integer, integer) ‚Üí vector_4i</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term type="type">vector_2f</s:term></s:table-cell>
                <s:table-cell><s:term type="type">(float, float) ‚Üí vector_2f</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term type="type">vector_3f</s:term></s:table-cell>
                <s:table-cell><s:term type="type">(float, float, float) ‚Üí vector_3f</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term type="type">vector_4f</s:term></s:table-cell>
                <s:table-cell><s:term type="type">(float, float, float, float) ‚Üí vector_4f</s:term></s:table-cell>
              </s:table-row>
            </s:table-body>
          </s:table>
        </s:formal-item>
        <s:paragraph>
          Given the presence of <s:term type="term">primary constructors</s:term>,
          the type rule for the construction of a vector using the
          <s:term type="keyword">new</s:term> keyword is:
        </s:paragraph>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>Vector new type rule (vector_new)</s:formal-item-title>
          <s:image source="ty_vector_new.png">Vector new type rule (vector_new)</s:image>
        </s:formal-item>
        <s:paragraph>
          The <s:term type="term">auxiliary constructors</s:term> for the
          <s:term type="type">vector_NT</s:term> types are:
        </s:paragraph>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>Vector auxiliary constructors</s:formal-item-title>
          <s:table>
            <s:table-summary>Vector auxiliary constructors</s:table-summary>
            <s:table-head>
              <s:table-column-name>Type</s:table-column-name>
              <s:table-column-name>Constructor type</s:table-column-name>
            </s:table-head>
            <s:table-body>
              <s:table-row>
                <s:table-cell><s:term type="type">vector_2i</s:term></s:table-cell>
                <s:table-cell><s:term type="type">vector_2i ‚Üí vector_2i</s:term></s:table-cell>
              </s:table-row>

              <s:table-row>
                <s:table-cell><s:term type="type">vector_3i</s:term></s:table-cell>
                <s:table-cell><s:term type="type">(integer, vector_2i) ‚Üí vector_3i</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term type="type">vector_3i</s:term></s:table-cell>
                <s:table-cell><s:term type="type">(vector_2i, integer) ‚Üí vector_3i</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term type="type">vector_3i</s:term></s:table-cell>
                <s:table-cell><s:term type="type">vector_3i ‚Üí vector_3i</s:term></s:table-cell>
              </s:table-row>

              <s:table-row>
                <s:table-cell><s:term type="type">vector_4i</s:term></s:table-cell>
                <s:table-cell><s:term type="type">(vector_2i, integer, integer) ‚Üí vector_4i</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term type="type">vector_4i</s:term></s:table-cell>
                <s:table-cell><s:term type="type">(integer, vector_2i, integer) ‚Üí vector_4i</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term type="type">vector_4i</s:term></s:table-cell>
                <s:table-cell><s:term type="type">(vector_2i, vector_2i) ‚Üí vector_4i</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term type="type">vector_4i</s:term></s:table-cell>
                <s:table-cell><s:term type="type">(integer, integer, vector_2i) ‚Üí vector_4i</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term type="type">vector_4i</s:term></s:table-cell>
                <s:table-cell><s:term type="type">(vector_3i, integer) ‚Üí vector_4i</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term type="type">vector_4i</s:term></s:table-cell>
                <s:table-cell><s:term type="type">(integer, vector_3i) ‚Üí vector_4i</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term type="type">vector_4i</s:term></s:table-cell>
                <s:table-cell><s:term type="type">vector_4i ‚Üí vector_4i</s:term></s:table-cell>
              </s:table-row>

              <s:table-row>
                <s:table-cell><s:term type="type">vector_2f</s:term></s:table-cell>
                <s:table-cell><s:term type="type">vector_2f ‚Üí vector_2f</s:term></s:table-cell>
              </s:table-row>

              <s:table-row>
                <s:table-cell><s:term type="type">vector_3f</s:term></s:table-cell>
                <s:table-cell><s:term type="type">(float, vector_2f) ‚Üí vector_3f</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term type="type">vector_3f</s:term></s:table-cell>
                <s:table-cell><s:term type="type">(vector_2f, float) ‚Üí vector_3f</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term type="type">vector_3f</s:term></s:table-cell>
                <s:table-cell><s:term type="type">vector_3f ‚Üí vector_3f</s:term></s:table-cell>
              </s:table-row>

              <s:table-row>
                <s:table-cell><s:term type="type">vector_4f</s:term></s:table-cell>
                <s:table-cell><s:term type="type">(vector_2f, float, float) ‚Üí vector_4f</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term type="type">vector_4f</s:term></s:table-cell>
                <s:table-cell><s:term type="type">(float, vector_2f, float) ‚Üí vector_4f</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term type="type">vector_4f</s:term></s:table-cell>
                <s:table-cell><s:term type="type">(vector_2f, vector_2f) ‚Üí vector_4f</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term type="type">vector_4f</s:term></s:table-cell>
                <s:table-cell><s:term type="type">(float, float, vector_2f) ‚Üí vector_4f</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term type="type">vector_4f</s:term></s:table-cell>
                <s:table-cell><s:term type="type">(vector_3f, float) ‚Üí vector_4f</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term type="type">vector_4f</s:term></s:table-cell>
                <s:table-cell><s:term type="type">(float, vector_3f) ‚Üí vector_4f</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term type="type">vector_4f</s:term></s:table-cell>
                <s:table-cell><s:term type="type">vector_4f ‚Üí vector_4f</s:term></s:table-cell>
              </s:table-row>
            </s:table-body>
          </s:table>
        </s:formal-item>
        <s:paragraph>
          For each <s:term type="term">auxiliary constructor</s:term> for a given
          <s:term type="type">vector_NT</s:term> type, the values of the scalars (if any),
          and the values of the components of the given vectors (if any), are concatenated
          together in the order given to produce an n-tuple of length
          <s:term type="variable">N</s:term>
          which is then passed directly to the
          <s:term type="term">primary constructor</s:term> for the given type.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.types.matrix">
      <s:section-title>Matrices</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          The <s:term type="type">matrix_NxNf</s:term> types represent
          square matrices, where <s:term type="expression">N ‚àà [3, 4]</s:term>
          and represents the number of rows/columns in the matrix.
          Only matrices with elements of type
          <s:link target="com.io7m.parasol.1.0.0.types.float">float</s:link>
          are provided.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Constructors</s:subsection-title>
        <s:paragraph>
          Values of the <s:term type="type">matrix_NxNf</s:term> types are
          constructed by providing exactly <s:term type="expression">N</s:term>
          <s:term type="term">column vectors</s:term> of size
          <s:term type="expression">N</s:term>. This is reflected in the
          available <s:term type="term">constructors</s:term> for the
          <s:term type="type">matrix_NxNf</s:term> types:
        </s:paragraph>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>Matrix constructors</s:formal-item-title>
          <s:table>
            <s:table-summary>Matrix constructors</s:table-summary>
            <s:table-head>
              <s:table-column-name>Type</s:table-column-name>
              <s:table-column-name>Constructor type</s:table-column-name>
            </s:table-head>
            <s:table-body>
              <s:table-row>
                <s:table-cell><s:term type="type">matrix_3x3f</s:term></s:table-cell>
                <s:table-cell><s:term type="type">(vector_3f, vector_3f, vector_3f) ‚Üí matrix_3x3f</s:term></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term type="type">matrix_4x4f</s:term></s:table-cell>
                <s:table-cell><s:term type="type">(vector_4f, vector_4f, vector_4f, vector_4f) ‚Üí matrix_4x4f</s:term></s:table-cell>
              </s:table-row>
            </s:table-body>
          </s:table>
        </s:formal-item>
        <s:paragraph>
          The type rule for the construction of matrices with the
          <s:term type="keyword">new</s:term> keyword is:
        </s:paragraph>
        <s:formal-item kind="specifications" type="specifications">
          <s:formal-item-title>Matrix new type rule (matrix_new)</s:formal-item-title>
          <s:image source="ty_matrix_new.png">Matrix new type rule (matrix_new)</s:image>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.types.samplers">
      <s:section-title>Samplers</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          The <s:term type="type">sampler_2d</s:term> and
          <s:term type="type">sampler_cube</s:term> types represent
          abstract <s:term type="term">handles</s:term> to two-dimensional
          and cube textures, respectively.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Constructors</s:subsection-title>
        <s:paragraph>
          The types have no constructors and there is no way to
          create new values of the types in the language. They are
          intended for use as parameters to
          <s:link target="com.io7m.parasol.1.0.0.declarations.shaders">shaders</s:link>.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.types.records">
      <s:section-title>Records</s:section-title>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          Record types are composite types consisting of labelled
          fields. Values of record types are constructed with the
          <s:term type="keyword">new</s:term> keyword, and values
          of fields are accessed with
          <s:link target="com.io7m.parasol.1.0.0.expressions.record_projection">record_projection</s:link>
          expressions.
        </s:paragraph>
        <s:paragraph>
          Only a subset of the available types can be used as fields in records:
        </s:paragraph>
        <s:formal-item kind="specifications">
          <s:formal-item-title>Record field types</s:formal-item-title>
          <s:list-unordered>
            <s:list-item><s:link target="com.io7m.parasol.1.0.0.types.integer">integer</s:link></s:list-item>
            <s:list-item><s:link target="com.io7m.parasol.1.0.0.types.float">float</s:link></s:list-item>
            <s:list-item><s:link target="com.io7m.parasol.1.0.0.types.boolean">boolean</s:link></s:list-item>
            <s:list-item><s:link target="com.io7m.parasol.1.0.0.types.vector">vector_NT</s:link></s:list-item>
            <s:list-item><s:link target="com.io7m.parasol.1.0.0.types.matrix">matrix_NxNf</s:link></s:list-item>
            <s:list-item>User-defined <s:link target="com.io7m.parasol.1.0.0.types.records">record</s:link> types</s:list-item>
          </s:list-unordered>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Constructors</s:subsection-title>
        <s:paragraph>
          Record types do not have <s:term type="term">constructors</s:term>
          and values of record types can only be introduced with
          <s:link target="com.io7m.parasol.1.0.0.expressions.record">record expressions</s:link>.
        </s:paragraph>
      </s:subsection>
    </s:section>
  </s:part>

  <s:part xml:id="com.io7m.parasol.1.0.0.execution">
    <s:part-title>Compilation and Execution</s:part-title>
    <s:part-contents/>
    <s:section>
      <s:section-title>Overview</s:section-title>
      <s:paragraph>
        This section attempts to informally document the typical life cycle
        of a <s:term type="package">parasol</s:term> program, from its initial
        state as a set of source code, to its final state executing on a GPU,
        from a somewhat abstract and idealized viewpoint. The intention is to
        allow the reader to better understand how the given operational
        semantics fit together and how the language as structured results
        in a working program.
      </s:paragraph>
    </s:section>
    <s:section>
      <s:section-title>Lifecycle</s:section-title>
      <s:paragraph>
        First, the intended program is <s:term type="term">compiled</s:term>:
      </s:paragraph>
      <s:formal-item kind="examples">
        <s:formal-item-title>Compilation</s:formal-item-title>
        <s:list-ordered>
          <s:list-item>
            The user submits a series of <s:link target="com.io7m.parasol.1.0.0.lex.units">units</s:link>,
            in no particular order, to the
            <s:term type="package">parasol</s:term> implementation compiler, along with the
            fully-qualified name of a
            <s:link target="com.io7m.parasol.1.0.0.declarations.shaders.program">program</s:link>.
          </s:list-item>
          <s:list-item>
            The compiler combines the <s:term type="term">units</s:term>, checks
            for <s:link target="com.io7m.parasol.1.0.0.declarations.modules">module</s:link>
            name collisions, checks the sanity of the submitted modules,
            resolves all names, and checks the
            <s:link target="com.io7m.parasol.1.0.0.types">types</s:link>
            of all
            <s:link target="com.io7m.parasol.1.0.0.declarations.terms">terms</s:link>.
          </s:list-item>
          <s:list-item>
            The compiler then erases all <s:term type="term">module_declarations</s:term> from
            the environment, renaming all <s:term type="term">terms</s:term> to result in a set
            of <s:term type="term">terms</s:term> with unique names.
          </s:list-item>
          <s:list-item>
            The compiler then determines all <s:term type="term">terms</s:term> upon which
            the <s:link target="com.io7m.parasol.1.0.0.declarations.shaders.program">program</s:link>
            depends, removing all unused <s:term type="term">terms</s:term> and sorting
            the resulting <s:term type="term">terms</s:term> topologically.
          </s:list-item>
        </s:list-ordered>
      </s:formal-item>
      <s:paragraph>
        At this point,
        the environment contains a
        <s:link target="com.io7m.parasol.1.0.0.declarations.shaders.vertex">vertex shader</s:link>
        <s:term type="expression">V</s:term>
        with an associated ordered set of <s:term type="term">terms</s:term>
        <s:term type="expression">T</s:term>, and
        <s:link target="com.io7m.parasol.1.0.0.declarations.shaders.fragment">fragment shader</s:link>
        <s:term type="expression">F</s:term>
        with an associated ordered set of <s:term type="term">terms</s:term>
        <s:term type="expression">U</s:term>.
      </s:paragraph>
      <s:paragraph>
        <s:term type="term">Execution</s:term> then proceeds as follows:
      </s:paragraph>
      <s:formal-item kind="examples">
        <s:formal-item-title>Execution</s:formal-item-title>
        <s:list-ordered>
          <s:list-item>
            Execution of <s:term type="expression">V</s:term> begins.
          </s:list-item>
          <s:list-item>
            The <s:term type="term">terms</s:term> in <s:term type="expression">T</s:term> are
            evaluated in the order given.
          </s:list-item>
          <s:list-item>
            The operational semantics imply that the values of the terms in
            <s:term type="expression">T</s:term> have been substituted into the
            <s:link target="com.io7m.parasol.1.0.0.declarations.shaders.vertex.declarations">local declarations</s:link>
            of <s:term type="expression">V</s:term>. The
            local declarations defined in <s:term type="expression">V</s:term> are evaluated.
          </s:list-item>
          <s:list-item>
            The values resulting from evaluation are written to the
            outputs of <s:term type="expression">V</s:term>.
          </s:list-item>
          <s:list-item>
            Execution of <s:term type="expression">F</s:term> begins.
          </s:list-item>
          <s:list-item>
            The <s:term type="term">terms</s:term> in <s:term type="expression">U</s:term> are
            evaluated in the order given.
          </s:list-item>
          <s:list-item>
            The operational semantics imply that the values of the terms in
            <s:term type="expression">U</s:term> have been substituted into the
            <s:link target="com.io7m.parasol.1.0.0.declarations.shaders.fragment.declarations">local declarations</s:link>
            of <s:term type="expression">F</s:term>. The
            local declarations defined in <s:term type="expression">F</s:term> are evaluated.
          </s:list-item>
          <s:list-item>
            If <s:term type="expression">F</s:term> contains a
            <s:link target="com.io7m.parasol.1.0.0.declarations.shaders.fragment.discard">discard</s:link>
            declaration, and the condition evaluates to <s:term type="constant">true</s:term>,
            execution of <s:term type="expression">F</s:term> halts and no
            output is produced.
          </s:list-item>
          <s:list-item>
            The values resulting from evaluation are written to the
            outputs of <s:term type="expression">F</s:term>.
          </s:list-item>
        </s:list-ordered>
      </s:formal-item>
    </s:section>
  </s:part>

  <s:part xml:id="com.io7m.parasol.1.0.0.stdlib">
    <s:part-title>Standard Library Reference</s:part-title>
    <s:part-contents/>
    <s:section xml:id="com.io7m.parasol.1.0.0.stdlib.com.io7m.parasol.Float">
      <s:section-title>Module com.io7m.parasol.Float</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>absolute</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>absolute Definition</s:formal-item-title>
          <s:verbatim>function absolute (x : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the absolute value of <s:term type="variable">x</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>add</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>add Definition</s:formal-item-title>
          <s:verbatim>function add (x : float, y : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return <s:term type="expression">x + y</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>arc_cosine</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>arc_cosine Definition</s:formal-item-title>
          <s:verbatim>function arc_cosine (x : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the arc cosine <s:term type="expression">acos(x)</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>arc_sine</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>arc_sine Definition</s:formal-item-title>
          <s:verbatim>function arc_sine (x : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the arc sine <s:term type="expression">asin(x)</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>arc_tangent</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>arc_tangent Definition</s:formal-item-title>
          <s:verbatim>function arc_tangent (x : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the arc tangent <s:term type="expression">atan(x)</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>ceiling</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>ceiling Definition</s:formal-item-title>
          <s:verbatim>function ceiling (x : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return a value equal to the nearest integer that is greater than or equal to <s:term type="variable">x</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>clamp</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>clamp Definition</s:formal-item-title>
          <s:verbatim>function clamp (x : float, min : float, max : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return <s:term type="expression">x</s:term> constrainted to the range <s:term type="expression">[min, max]</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>cosine</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>cosine Definition</s:formal-item-title>
          <s:verbatim>function cosine (x : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the cosine <s:term type="expression">cos(x)</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>equals</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>equals Definition</s:formal-item-title>
          <s:verbatim>function equals (x : float, y : float) : boolean</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return <s:term type="constant">true</s:term> iff <s:term type="expression">x == y</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>floor</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>floor Definition</s:formal-item-title>
          <s:verbatim>function floor (x : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return a value equal to the nearest integer that is less than or equal to <s:term type="variable">x</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>greater</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>greater Definition</s:formal-item-title>
          <s:verbatim>function greater (x : float, y : float) : boolean</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return <s:term type="constant">true</s:term> iff <s:term type="expression">x > y</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>interpolate</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>interpolate Definition</s:formal-item-title>
          <s:verbatim>function interpolate (x : float, y : float, a : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>
          Return a linearly interpolated value in the range <s:term type="expression">[x, y]</s:term>
          given by <s:term type="expression">(x ‚úï (1 - a)) + (y ‚úï a)</s:term>.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>is_infinite</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>is_infinite Definition</s:formal-item-title>
          <s:verbatim>function is_infinite (x : float) : boolean</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return <s:term type="constant">true</s:term> iff <s:term type="expression">x == infinity</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>is_nan</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>is_nan Definition</s:formal-item-title>
          <s:verbatim>function is_nan (x : float) : boolean</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return <s:term type="constant">true</s:term> iff <s:term type="expression">x</s:term> is not a number.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>lesser</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>lesser Definition</s:formal-item-title>
          <s:verbatim>function lesser (x : float, y : float) : boolean</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return <s:term type="constant">true</s:term> iff <s:term type="expression">x &lt; y</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>maximum</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>maximum Definition</s:formal-item-title>
          <s:verbatim>function maximum (x : float, y : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the maximum value of <s:term type="expression">x</s:term> and <s:term type="expression">y</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>minimum</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>minimum Definition</s:formal-item-title>
          <s:verbatim>function minimum (x : float, y : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the minimum value of <s:term type="expression">x</s:term> and <s:term type="expression">y</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>modulo</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>modulo Definition</s:formal-item-title>
          <s:verbatim>function modulo (x : float, y : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the value of <s:term type="expression">x mod y</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>multiply</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>multiply Definition</s:formal-item-title>
          <s:verbatim>function multiply (x : float, y : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the value of <s:term type="expression">x ‚úï y</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>power</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>power Definition</s:formal-item-title>
          <s:verbatim>function power (x : float, n : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the value of <s:term type="expression">x‚Åø</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>round</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>round Definition</s:formal-item-title>
          <s:verbatim>function round (x : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the value of the nearest integer to <s:term type="expression">x</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>sign</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>sign Definition</s:formal-item-title>
          <s:verbatim>function sign (x : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return <s:term type="expression">0.0</s:term> iff <s:term type="expression">x == 0.0</s:term>,
        <s:term type="expression">1.0</s:term> iff <s:term type="expression">x > 0.0</s:term>, and
        <s:term type="expression">-1.0</s:term> otherwise.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>sine</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>sine Definition</s:formal-item-title>
          <s:verbatim>function sine (x : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the sine <s:term type="expression">sin(x)</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>square_root</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>square_root Definition</s:formal-item-title>
          <s:verbatim>function square_root (x : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the square root of <s:term type="expression">x</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>subtract</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>subtract Definition</s:formal-item-title>
          <s:verbatim>function subtract (x : float, y : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the value of of <s:term type="expression">x - y</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>tangent</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>tangent Definition</s:formal-item-title>
          <s:verbatim>function tangent (x : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the tangent <s:term type="expression">tan(x)</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>truncate</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>truncate Definition</s:formal-item-title>
          <s:verbatim>function truncate (x : float) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>
          Return the nearest integer to <s:term type="expression">x</s:term> whose absolute value is
          not greater than the absolute value of <s:term type="expression">x</s:term>.
        </s:paragraph>
      </s:subsection>
    </s:section>
    <s:section xml:id="com.io7m.parasol.1.0.0.stdlib.com.io7m.parasol.Integer">
      <s:section-title>Module com.io7m.parasol.Integer</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>add</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>add Definition</s:formal-item-title>
          <s:verbatim>function add (x : integer, y : integer) : integer</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return <s:term type="expression">x + y</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>subtract</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>subtract Definition</s:formal-item-title>
          <s:verbatim>function subtract (x : integer, y : integer) : integer</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return <s:term type="expression">x - y</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>multiply</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>multiply Definition</s:formal-item-title>
          <s:verbatim>function multiply (x : integer, y : integer) : integer</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return <s:term type="expression">x ‚úï y</s:term>.</s:paragraph>
      </s:subsection>
    </s:section>
    <s:section xml:id="com.io7m.parasol.1.0.0.stdlib.com.io7m.parasol.Matrix3x3f">
      <s:section-title>Module com.io7m.parasol.Matrix3x3f</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>multiply</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>multiply Definition</s:formal-item-title>
          <s:verbatim>function multiply (m0 : matrix_3x3f, m1 : matrix_3x3f) : matrix_3x3f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return <s:term type="expression">m0 ‚úï m1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>multiply_vector</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>multiply_vector Definition</s:formal-item-title>
          <s:verbatim>function multiply_vector (m : matrix_3x3f, v : vector_3f) : vector_3f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return <s:term type="expression">m ‚úï v</s:term>.</s:paragraph>
      </s:subsection>
    </s:section>
    <s:section xml:id="com.io7m.parasol.1.0.0.stdlib.com.io7m.parasol.Matrix4x4f">
      <s:section-title>Module com.io7m.parasol.Matrix4x4f</s:section-title>
      <s:subsection>
        <s:subsection-title>multiply</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>multiply Definition</s:formal-item-title>
          <s:verbatim>function multiply (m0 : matrix_4x4f, m1 : matrix_4x4f) : matrix_4x4f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return <s:term type="expression">m0 ‚úï m1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>multiply_vector</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>multiply_vector Definition</s:formal-item-title>
          <s:verbatim>function multiply_vector (m : matrix_4x4f, v : vector_4f) : vector_4f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return <s:term type="expression">m ‚úï v</s:term>.</s:paragraph>
      </s:subsection>
    </s:section>
    <s:section xml:id="com.io7m.parasol.1.0.0.stdlib.com.io7m.parasol.Sampler2D">
      <s:section-title>Module com.io7m.parasol.Sampler2D</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>texture</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>texture Definition</s:formal-item-title>
          <s:verbatim>function texture (t : sampler_2d, uv : vector_2f) : vector_4f</s:verbatim>
        </s:formal-item>
        <s:paragraph>
          Retrieve a texel from the texture <s:term type="variable">t</s:term>
          from the texture coordinate <s:term type="variable">uv</s:term>.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.stdlib.com.io7m.parasol.Vector2f">
      <s:section-title>Module com.io7m.parasol.Vector2f</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>add</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>add Definition</s:formal-item-title>
          <s:verbatim>function add (v0 : vector_2f, v1 : vector_2f) : vector_2f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise addition  <s:term type="expression">v0 + v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>dot</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>dot Definition</s:formal-item-title>
          <s:verbatim>function dot (v0 : vector_2f, v1 : vector_2f) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the dot product <s:term type="expression">v0 ‚ãÖ v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>magnitude</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>magnitude Definition</s:formal-item-title>
          <s:verbatim>function magnitude (v : vector_2f) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the magnitude of <s:term type="expression">v</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>multiply</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>multiply Definition</s:formal-item-title>
          <s:verbatim>function multiply (v0 : vector_2f, v1 : vector_2f) : vector_2f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise multiplication <s:term type="expression">v0 ‚úï v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>normalize</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>normalize Definition</s:formal-item-title>
          <s:verbatim>function normalize (v : vector_2f) : vector_2f</s:verbatim>
        </s:formal-item>
        <s:paragraph>
          Return a vector pointing in the same direction as <s:term type="expression">v</s:term>
          but with a magnitude of <s:term type="constant">1</s:term>.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>subtract</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>subtract Definition</s:formal-item-title>
          <s:verbatim>function subtract (v0 : vector_2f, v1 : vector_2f) : vector_2f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise subtraction <s:term type="expression">v0 - v1</s:term>.</s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.stdlib.com.io7m.parasol.Vector2i">
      <s:section-title>Module com.io7m.parasol.Vector2i</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>add</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>add Definition</s:formal-item-title>
          <s:verbatim>function add (v0 : vector_2i, v1 : vector_2i) : vector_2i</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise addition  <s:term type="expression">v0 + v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>dot</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>dot Definition</s:formal-item-title>
          <s:verbatim>function dot (v0 : vector_2i, v1 : vector_2i) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the dot product <s:term type="expression">v0 ‚ãÖ v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>magnitude</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>magnitude Definition</s:formal-item-title>
          <s:verbatim>function magnitude (v : vector_2i) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the magnitude of <s:term type="expression">v</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>multiply</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>multiply Definition</s:formal-item-title>
          <s:verbatim>function multiply (v0 : vector_2i, v1 : vector_2i) : vector_2i</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise multiplication <s:term type="expression">v0 ‚úï v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>normalize</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>normalize Definition</s:formal-item-title>
          <s:verbatim>function normalize (v : vector_2i) : vector_2i</s:verbatim>
        </s:formal-item>
        <s:paragraph>
          Return a vector pointing in the same direction as <s:term type="expression">v</s:term>
          but with a magnitude of <s:term type="constant">1</s:term>.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>subtract</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>subtract Definition</s:formal-item-title>
          <s:verbatim>function subtract (v0 : vector_2i, v1 : vector_2i) : vector_2i</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise subtraction <s:term type="expression">v0 - v1</s:term>.</s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.stdlib.com.io7m.parasol.Vector3f">
      <s:section-title>Module com.io7m.parasol.Vector3f</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>add</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>add Definition</s:formal-item-title>
          <s:verbatim>function add (v0 : vector_3f, v1 : vector_3f) : vector_3f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise addition  <s:term type="expression">v0 + v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>dot</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>dot Definition</s:formal-item-title>
          <s:verbatim>function dot (v0 : vector_3f, v1 : vector_3f) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the dot product <s:term type="expression">v0 ‚ãÖ v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>magnitude</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>magnitude Definition</s:formal-item-title>
          <s:verbatim>function magnitude (v : vector_3f) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the magnitude of <s:term type="expression">v</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>multiply</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>multiply Definition</s:formal-item-title>
          <s:verbatim>function multiply (v0 : vector_3f, v1 : vector_3f) : vector_3f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise multiplication <s:term type="expression">v0 ‚úï v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>normalize</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>normalize Definition</s:formal-item-title>
          <s:verbatim>function normalize (v : vector_3f) : vector_3f</s:verbatim>
        </s:formal-item>
        <s:paragraph>
          Return a vector pointing in the same direction as <s:term type="expression">v</s:term>
          but with a magnitude of <s:term type="constant">1</s:term>.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>subtract</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>subtract Definition</s:formal-item-title>
          <s:verbatim>function subtract (v0 : vector_3f, v1 : vector_3f) : vector_3f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise subtraction <s:term type="expression">v0 - v1</s:term>.</s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.stdlib.com.io7m.parasol.Vector3i">
      <s:section-title>Module com.io7m.parasol.Vector3i</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>add</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>add Definition</s:formal-item-title>
          <s:verbatim>function add (v0 : vector_3i, v1 : vector_3i) : vector_3i</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise addition  <s:term type="expression">v0 + v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>dot</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>dot Definition</s:formal-item-title>
          <s:verbatim>function dot (v0 : vector_3i, v1 : vector_3i) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the dot product <s:term type="expression">v0 ‚ãÖ v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>magnitude</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>magnitude Definition</s:formal-item-title>
          <s:verbatim>function magnitude (v : vector_3i) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the magnitude of <s:term type="expression">v</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>multiply</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>multiply Definition</s:formal-item-title>
          <s:verbatim>function multiply (v0 : vector_3i, v1 : vector_3i) : vector_3i</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise multiplication <s:term type="expression">v0 ‚úï v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>normalize</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>normalize Definition</s:formal-item-title>
          <s:verbatim>function normalize (v : vector_3i) : vector_3i</s:verbatim>
        </s:formal-item>
        <s:paragraph>
          Return a vector pointing in the same direction as <s:term type="expression">v</s:term>
          but with a magnitude of <s:term type="constant">1</s:term>.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>subtract</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>subtract Definition</s:formal-item-title>
          <s:verbatim>function subtract (v0 : vector_3i, v1 : vector_3i) : vector_3i</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise subtraction <s:term type="expression">v0 - v1</s:term>.</s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.stdlib.com.io7m.parasol.Vector4f">
      <s:section-title>Module com.io7m.parasol.Vector4f</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>add</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>add Definition</s:formal-item-title>
          <s:verbatim>function add (v0 : vector_4f, v1 : vector_4f) : vector_4f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise addition  <s:term type="expression">v0 + v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>dot</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>dot Definition</s:formal-item-title>
          <s:verbatim>function dot (v0 : vector_4f, v1 : vector_4f) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the dot product <s:term type="expression">v0 ‚ãÖ v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>magnitude</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>magnitude Definition</s:formal-item-title>
          <s:verbatim>function magnitude (v : vector_4f) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the magnitude of <s:term type="expression">v</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>multiply</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>multiply Definition</s:formal-item-title>
          <s:verbatim>function multiply (v0 : vector_4f, v1 : vector_4f) : vector_4f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise multiplication <s:term type="expression">v0 ‚úï v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>normalize</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>normalize Definition</s:formal-item-title>
          <s:verbatim>function normalize (v : vector_4f) : vector_4f</s:verbatim>
        </s:formal-item>
        <s:paragraph>
          Return a vector pointing in the same direction as <s:term type="expression">v</s:term>
          but with a magnitude of <s:term type="constant">1</s:term>.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>subtract</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>subtract Definition</s:formal-item-title>
          <s:verbatim>function subtract (v0 : vector_4f, v1 : vector_4f) : vector_4f</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise subtraction <s:term type="expression">v0 - v1</s:term>.</s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.stdlib.com.io7m.parasol.Vector4i">
      <s:section-title>Module com.io7m.parasol.Vector4i</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>add</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>add Definition</s:formal-item-title>
          <s:verbatim>function add (v0 : vector_4i, v1 : vector_4i) : vector_4i</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise addition  <s:term type="expression">v0 + v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>dot</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>dot Definition</s:formal-item-title>
          <s:verbatim>function dot (v0 : vector_4i, v1 : vector_4i) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the dot product <s:term type="expression">v0 ‚ãÖ v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>magnitude</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>magnitude Definition</s:formal-item-title>
          <s:verbatim>function magnitude (v : vector_4i) : float</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the magnitude of <s:term type="expression">v</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>multiply</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>multiply Definition</s:formal-item-title>
          <s:verbatim>function multiply (v0 : vector_4i, v1 : vector_4i) : vector_4i</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise multiplication <s:term type="expression">v0 ‚úï v1</s:term>.</s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>normalize</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>normalize Definition</s:formal-item-title>
          <s:verbatim>function normalize (v : vector_4i) : vector_4i</s:verbatim>
        </s:formal-item>
        <s:paragraph>
          Return a vector pointing in the same direction as <s:term type="expression">v</s:term>
          but with a magnitude of <s:term type="constant">1</s:term>.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>subtract</s:subsection-title>
        <s:formal-item kind="specifications">
          <s:formal-item-title>subtract Definition</s:formal-item-title>
          <s:verbatim>function subtract (v0 : vector_4i, v1 : vector_4i) : vector_4i</s:verbatim>
        </s:formal-item>
        <s:paragraph>Return the component-wise subtraction <s:term type="expression">v0 - v1</s:term>.</s:paragraph>
      </s:subsection>
    </s:section>
  </s:part>

  <s:part>
    <s:part-title>Appendices</s:part-title>
    <s:part-contents/>
    <s:section>
      <s:section-title>EBNF Grammar</s:section-title>
      <s:paragraph>
        The full EBNF grammar of the language is as follows:
      </s:paragraph>
      <s:formal-item kind="specifications">
        <s:formal-item-title>EBNF Grammar</s:formal-item-title>
        <s:verbatim><![CDATA[
(* Terminals *)

digit_nonzero =
  "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;

digit =
  "0" | digit_nonzero ;

letter_lower =
  "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" |
  "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" |
  "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" |
  "y" | "z" ;

letter_upper =
  "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" |
  "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" |
  "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" |
  "Y" | "Z" ;

letter =
  letter_lower | letter_upper ;

name_lower =
  letter_lower , { letter | digit | "-" | "_" } ;

name_upper =
  letter_upper , { letter | digit | "-" | "_" } ;

integer_literal =
  "0" | ( ["-"] , digit_nonzero , { digit } ) ;

real_literal =
  ["-"] , digit , { digit } , "." , digit , { digit } ;

boolean_literal =
  "true" | "false" ;

(* Non-terminals *)

package_path =
  name_lower , { "." , name_lower } ;

package_declaration =
  "package" , package_path ;

import_path =
  package_path , "." , name_upper ;

import_declaration =
  "import" , import_path , [ "as" , name_upper ] ;

import_declarations =
  { import_declaration , ";" } ;

type_path =
    name_lower
  | name_upper , "." , name_lower ;

term_path =
    name_lower
  | name_upper , "." , name_lower ;

shader_path =
    name_lower
  | name_upper , "." , name_lower ;

value_declaration =
  "value" , name_lower , [ ":" , type_path ] , "=" , expression ;

value_declarations =
  { value_declaration , ";" } ;

function_formal_parameter =
  name_lower , ":" , type_path ;

function_formal_parameters =
  "(" , function_formal_parameter, { "," , function_formal_parameter } , ")" ;

function_declaration =
  "function" , name_lower , function_formal_parameters , ":" , type_path , "=" , expression ;

term_declaration =
  value_declaration | function_declaration ;

record_type_field =
  name_lower , ":" , type_path ;

record_type_expression =
  "record" , record_type_field , { "," , record_type_field } , "end" ;

type_declaration =
  "type" , name_lower , "is" , type_expression ;

type_declarations =
  { type_declaration , ";" } ;

type_expression =
  record_type_expression
  ;

variable_or_application_expression =
  term_path [ "(" , expression , { "," , expression } , ")" ]
  ;

new_parameters =
  "(" , expression , { "," , expression } , ")" ;

new_expression =
  "new" , type_path , new_parameters ;

record_expression_fields =
  "{" , name_lower , "=" , expression , { "," name_lower , "=" , expression } , "}" ;

record_expression =
  "record" , type_path , record_expression_fields ;

local_declaration =
  "value" , name_lower , [ ":" , type_path ] , "=" , expression ;

local_declarations =
  local_declaration , ";" , { local_declarations } ;

let_expression =
  "let" , local_declarations , "in" , expression , "end" ;

conditional_expression =
  "if" , expression , "then" , expression , "else" , expression , "end" ;

expression_pre =
    integer_literal
  | real_literal
  | boolean_literal
  | variable_or_application_expression
  | conditional_expression
  | let_expression
  | new_expression
  | record_expression
  ;

expression_projection =
  "." , name_lower ;

expression_swizzle_names =
  "[" , name_lower , { "," , name_lower } , "]" ;

expression =
  expression_pre , { expression_swizzle | expression_projection } ;

shader_parameter_declaration =
  "parameter" , name_lower , ":" , type_path ;

shader_vertex_input_declaration =
  "in" , name_lower , ":" , type_path ;

shader_vertex_output_declaration =
  "out" , name_lower , ":" , type_path ;

shader_vertex_output_main_declaration =
  "out" , "vertex" , name_lower , ":" , type_path ;

shader_vertex_parameter =
    shader_parameter_declaration
  | shader_vertex_input_declaration
  | shader_vertex_output_declaration
  | shader_vertex_output_main_declaration ;

shader_vertex_parameters =
  { shader_vertex_parameter , ";" } ;

shader_vertex_output_assignment =
  "out" , name_lower , "=" , term_path ;

shader_vertex_output_assignments =
  shader_vertex_output_assignment , ";" , { shader_vertex_output_assignments } ;

shader_vertex_declaration =
  "vertex" , name_lower , "is" ,
  shader_vertex_parameters ,
  [ "with" , local_declarations ] ,
  "as" ,
  shader_vertex_output_assignments ,
  "end" ;

shader_fragment_input_declaration =
  "in" , name_lower , ":" , type_path ;

shader_fragment_output_declaration =
  "out" , name_lower , ":" , type_path , "as" , integer_literal ;

shader_fragment_parameter =
    shader_parameter_declaration
  | shader_fragment_input_declaration
  | shader_fragment_output_declaration ;

shader_fragment_parameters =
  { shader_fragment_parameter , ";" } ;

shader_fragment_discard_declaration =
  "discard" , "(" , expression , ")" ;

shader_fragment_local_declaration =
    local_declaration
  | shader_fragment_discard_declaration ;

shader_fragment_local_declarations =
  shader_fragment_local_declaration , ";" , { shader_fragment_local_declarations } ;

shader_fragment_output_assignment =
  "out" , name_lower , "=" , term_path ;

shader_fragment_output_assignments =
  shader_fragment_output_assignment , ";" , { shader_fragment_output_assignments } ;

shader_fragment_declaration =
  "fragment" , name_lower , "is" ,
  shader_fragment_parameters ,
  [ "with" , shader_fragment_local_declarations ] ,
  "as" ,
  shader_fragment_output_assignments ,
  "end" ;

shader_program_declaration =
  "program" , name_lower , "is" ,
  "vertex" , shader_path , ";" ,
  "fragment" , shader_path , ";" ,
  "end" ;

shader_declaration =
  "shader" , ( shader_vertex_declaration | shader_fragment_declaration | shader_program_declaration ) ;

shader_declarations =
  { shader_declaration , ";" } ;

module_level_declarations =
  { value_declarations | function_declarations | type_declarations | shader_declarations } ;

module_declaration =
  "module" , name_upper , "is" ,
  import_declarations ,
  module_level_declarations ,
  "end" ;

module_declarations =
  module_declaration , ";" , { module_declaration , ";" } ;

unit =
  package_declaration , ";" ,
  module_declarations ;
]]></s:verbatim>
      </s:formal-item>
    </s:section>

    <s:section>
      <s:section-title>Type rules</s:section-title>
      <s:paragraph>
        The full type rules for the language are as follows:
      </s:paragraph>
      <s:formal-item kind="specifications">
        <s:formal-item-title>Type rules</s:formal-item-title>
        <s:image source="typing.png">Type rules</s:image>
      </s:formal-item>
    </s:section>

    <s:section>
      <s:section-title>Operational semantics</s:section-title>
      <s:paragraph>
        The full operational semantics for the language are as follows:
      </s:paragraph>
      <s:formal-item kind="specifications">
        <s:formal-item-title>Operational semantics</s:formal-item-title>
        <s:image source="op_semantics.png">Operational semantics</s:image>
      </s:formal-item>
    </s:section>

    <s:section xml:id="com.io7m.parasol.1.0.0.glsl-identifiers">
      <s:section-title>GLSL identifiers</s:section-title>
      <s:paragraph>
        The complete list of reserved words in the OpenGL shading language
        as of version 4.3 are:
      </s:paragraph>
      <s:formal-item kind="specifications">
        <s:formal-item-title>GLSL identifiers</s:formal-item-title>
<s:list-unordered>
  <s:list-item><s:term type="keyword">active</s:term></s:list-item>
  <s:list-item><s:term type="keyword">asm</s:term></s:list-item>
  <s:list-item><s:term type="keyword">atomic_uint</s:term></s:list-item>
  <s:list-item><s:term type="keyword">attribute</s:term></s:list-item>
  <s:list-item><s:term type="keyword">bool</s:term></s:list-item>
  <s:list-item><s:term type="keyword">break</s:term></s:list-item>
  <s:list-item><s:term type="keyword">buffer</s:term></s:list-item>
  <s:list-item><s:term type="keyword">bvec2</s:term></s:list-item>
  <s:list-item><s:term type="keyword">bvec3</s:term></s:list-item>
  <s:list-item><s:term type="keyword">bvec4</s:term></s:list-item>
  <s:list-item><s:term type="keyword">case</s:term></s:list-item>
  <s:list-item><s:term type="keyword">cast</s:term></s:list-item>
  <s:list-item><s:term type="keyword">centroid</s:term></s:list-item>
  <s:list-item><s:term type="keyword">class</s:term></s:list-item>
  <s:list-item><s:term type="keyword">coherent</s:term></s:list-item>
  <s:list-item><s:term type="keyword">common</s:term></s:list-item>
  <s:list-item><s:term type="keyword">const</s:term></s:list-item>
  <s:list-item><s:term type="keyword">continue</s:term></s:list-item>
  <s:list-item><s:term type="keyword">default</s:term></s:list-item>
  <s:list-item><s:term type="keyword">discard</s:term></s:list-item>
  <s:list-item><s:term type="keyword">dmat2</s:term></s:list-item>
  <s:list-item><s:term type="keyword">dmat2x2</s:term></s:list-item>
  <s:list-item><s:term type="keyword">dmat2x3</s:term></s:list-item>
  <s:list-item><s:term type="keyword">dmat2x4</s:term></s:list-item>
  <s:list-item><s:term type="keyword">dmat3</s:term></s:list-item>
  <s:list-item><s:term type="keyword">dmat3x2</s:term></s:list-item>
  <s:list-item><s:term type="keyword">dmat3x3</s:term></s:list-item>
  <s:list-item><s:term type="keyword">dmat3x4</s:term></s:list-item>
  <s:list-item><s:term type="keyword">dmat4</s:term></s:list-item>
  <s:list-item><s:term type="keyword">dmat4x2</s:term></s:list-item>
  <s:list-item><s:term type="keyword">dmat4x3</s:term></s:list-item>
  <s:list-item><s:term type="keyword">dmat4x4</s:term></s:list-item>
  <s:list-item><s:term type="keyword">do</s:term></s:list-item>
  <s:list-item><s:term type="keyword">double</s:term></s:list-item>
  <s:list-item><s:term type="keyword">dvec2</s:term></s:list-item>
  <s:list-item><s:term type="keyword">dvec3</s:term></s:list-item>
  <s:list-item><s:term type="keyword">dvec4</s:term></s:list-item>
  <s:list-item><s:term type="keyword">else</s:term></s:list-item>
  <s:list-item><s:term type="keyword">enum</s:term></s:list-item>
  <s:list-item><s:term type="keyword">extern</s:term></s:list-item>
  <s:list-item><s:term type="keyword">external</s:term></s:list-item>
  <s:list-item><s:term type="keyword">false</s:term></s:list-item>
  <s:list-item><s:term type="keyword">filter</s:term></s:list-item>
  <s:list-item><s:term type="keyword">fixed</s:term></s:list-item>
  <s:list-item><s:term type="keyword">flat</s:term></s:list-item>
  <s:list-item><s:term type="keyword">float</s:term></s:list-item>
  <s:list-item><s:term type="keyword">for</s:term></s:list-item>
  <s:list-item><s:term type="keyword">fvec2</s:term></s:list-item>
  <s:list-item><s:term type="keyword">fvec3</s:term></s:list-item>
  <s:list-item><s:term type="keyword">fvec4</s:term></s:list-item>
  <s:list-item><s:term type="keyword">goto</s:term></s:list-item>
  <s:list-item><s:term type="keyword">half</s:term></s:list-item>
  <s:list-item><s:term type="keyword">highp</s:term></s:list-item>
  <s:list-item><s:term type="keyword">hvec2</s:term></s:list-item>
  <s:list-item><s:term type="keyword">hvec3</s:term></s:list-item>
  <s:list-item><s:term type="keyword">hvec4</s:term></s:list-item>
  <s:list-item><s:term type="keyword">if</s:term></s:list-item>
  <s:list-item><s:term type="keyword">iimage1D</s:term></s:list-item>
  <s:list-item><s:term type="keyword">iimage1DArray</s:term></s:list-item>
  <s:list-item><s:term type="keyword">iimage2D</s:term></s:list-item>
  <s:list-item><s:term type="keyword">iimage2DArray</s:term></s:list-item>
  <s:list-item><s:term type="keyword">iimage2DMS</s:term></s:list-item>
  <s:list-item><s:term type="keyword">iimage2DMSArray</s:term></s:list-item>
  <s:list-item><s:term type="keyword">iimage2DRect</s:term></s:list-item>
  <s:list-item><s:term type="keyword">iimage3D</s:term></s:list-item>
  <s:list-item><s:term type="keyword">iimageBuffer</s:term></s:list-item>
  <s:list-item><s:term type="keyword">iimageCube</s:term></s:list-item>
  <s:list-item><s:term type="keyword">iimageCubeArray</s:term></s:list-item>
  <s:list-item><s:term type="keyword">image1D</s:term></s:list-item>
  <s:list-item><s:term type="keyword">image1DArray</s:term></s:list-item>
  <s:list-item><s:term type="keyword">image2D</s:term></s:list-item>
  <s:list-item><s:term type="keyword">image2DArray</s:term></s:list-item>
  <s:list-item><s:term type="keyword">image2DMS</s:term></s:list-item>
  <s:list-item><s:term type="keyword">image2DMSArray</s:term></s:list-item>
  <s:list-item><s:term type="keyword">image2DRect</s:term></s:list-item>
  <s:list-item><s:term type="keyword">image3D</s:term></s:list-item>
  <s:list-item><s:term type="keyword">imageBuffer</s:term></s:list-item>
  <s:list-item><s:term type="keyword">imageCube</s:term></s:list-item>
  <s:list-item><s:term type="keyword">imageCubeArray</s:term></s:list-item>
  <s:list-item><s:term type="keyword">in</s:term></s:list-item>
  <s:list-item><s:term type="keyword">inline</s:term></s:list-item>
  <s:list-item><s:term type="keyword">inout</s:term></s:list-item>
  <s:list-item><s:term type="keyword">input</s:term></s:list-item>
  <s:list-item><s:term type="keyword">int</s:term></s:list-item>
  <s:list-item><s:term type="keyword">interface</s:term></s:list-item>
  <s:list-item><s:term type="keyword">invariant</s:term></s:list-item>
  <s:list-item><s:term type="keyword">isampler1D</s:term></s:list-item>
  <s:list-item><s:term type="keyword">isampler1DArray</s:term></s:list-item>
  <s:list-item><s:term type="keyword">isampler2D</s:term></s:list-item>
  <s:list-item><s:term type="keyword">isampler2DArray</s:term></s:list-item>
  <s:list-item><s:term type="keyword">isampler2DMS</s:term></s:list-item>
  <s:list-item><s:term type="keyword">isampler2DMSArray</s:term></s:list-item>
  <s:list-item><s:term type="keyword">isampler2DRect</s:term></s:list-item>
  <s:list-item><s:term type="keyword">isampler3D</s:term></s:list-item>
  <s:list-item><s:term type="keyword">isamplerBuffer</s:term></s:list-item>
  <s:list-item><s:term type="keyword">isamplerCube</s:term></s:list-item>
  <s:list-item><s:term type="keyword">isamplerCubeArray</s:term></s:list-item>
  <s:list-item><s:term type="keyword">ivec2</s:term></s:list-item>
  <s:list-item><s:term type="keyword">ivec3</s:term></s:list-item>
  <s:list-item><s:term type="keyword">ivec4</s:term></s:list-item>
  <s:list-item><s:term type="keyword">layout</s:term></s:list-item>
  <s:list-item><s:term type="keyword">long</s:term></s:list-item>
  <s:list-item><s:term type="keyword">lowp</s:term></s:list-item>
  <s:list-item><s:term type="keyword">mat2</s:term></s:list-item>
  <s:list-item><s:term type="keyword">mat2x2</s:term></s:list-item>
  <s:list-item><s:term type="keyword">mat2x3</s:term></s:list-item>
  <s:list-item><s:term type="keyword">mat2x4</s:term></s:list-item>
  <s:list-item><s:term type="keyword">mat3</s:term></s:list-item>
  <s:list-item><s:term type="keyword">mat3x2</s:term></s:list-item>
  <s:list-item><s:term type="keyword">mat3x3</s:term></s:list-item>
  <s:list-item><s:term type="keyword">mat3x4</s:term></s:list-item>
  <s:list-item><s:term type="keyword">mat4</s:term></s:list-item>
  <s:list-item><s:term type="keyword">mat4x2</s:term></s:list-item>
  <s:list-item><s:term type="keyword">mat4x3</s:term></s:list-item>
  <s:list-item><s:term type="keyword">mat4x4</s:term></s:list-item>
  <s:list-item><s:term type="keyword">mediump</s:term></s:list-item>
  <s:list-item><s:term type="keyword">namespace</s:term></s:list-item>
  <s:list-item><s:term type="keyword">noinline</s:term></s:list-item>
  <s:list-item><s:term type="keyword">noperspective</s:term></s:list-item>
  <s:list-item><s:term type="keyword">out</s:term></s:list-item>
  <s:list-item><s:term type="keyword">output</s:term></s:list-item>
  <s:list-item><s:term type="keyword">packed</s:term></s:list-item>
  <s:list-item><s:term type="keyword">partition</s:term></s:list-item>
  <s:list-item><s:term type="keyword">patch</s:term></s:list-item>
  <s:list-item><s:term type="keyword">precision</s:term></s:list-item>
  <s:list-item><s:term type="keyword">public</s:term></s:list-item>
  <s:list-item><s:term type="keyword">readonly</s:term></s:list-item>
  <s:list-item><s:term type="keyword">resource</s:term></s:list-item>
  <s:list-item><s:term type="keyword">restrict</s:term></s:list-item>
  <s:list-item><s:term type="keyword">return</s:term></s:list-item>
  <s:list-item><s:term type="keyword">row_major</s:term></s:list-item>
  <s:list-item><s:term type="keyword">sample</s:term></s:list-item>
  <s:list-item><s:term type="keyword">sampler1D</s:term></s:list-item>
  <s:list-item><s:term type="keyword">sampler1DArray</s:term></s:list-item>
  <s:list-item><s:term type="keyword">sampler1DArrayShadow</s:term></s:list-item>
  <s:list-item><s:term type="keyword">sampler1DShadow</s:term></s:list-item>
  <s:list-item><s:term type="keyword">sampler2D</s:term></s:list-item>
  <s:list-item><s:term type="keyword">sampler2DArray</s:term></s:list-item>
  <s:list-item><s:term type="keyword">sampler2DArrayShadow</s:term></s:list-item>
  <s:list-item><s:term type="keyword">sampler2DMS</s:term></s:list-item>
  <s:list-item><s:term type="keyword">sampler2DMSArray</s:term></s:list-item>
  <s:list-item><s:term type="keyword">sampler2DRect</s:term></s:list-item>
  <s:list-item><s:term type="keyword">sampler2DRectShadow</s:term></s:list-item>
  <s:list-item><s:term type="keyword">sampler2DShadow</s:term></s:list-item>
  <s:list-item><s:term type="keyword">sampler3D</s:term></s:list-item>
  <s:list-item><s:term type="keyword">sampler3DRect</s:term></s:list-item>
  <s:list-item><s:term type="keyword">samplerBuffer</s:term></s:list-item>
  <s:list-item><s:term type="keyword">samplerCube</s:term></s:list-item>
  <s:list-item><s:term type="keyword">samplerCubeArray</s:term></s:list-item>
  <s:list-item><s:term type="keyword">samplerCubeArrayShadow</s:term></s:list-item>
  <s:list-item><s:term type="keyword">samplerCubeShadow</s:term></s:list-item>
  <s:list-item><s:term type="keyword">shared</s:term></s:list-item>
  <s:list-item><s:term type="keyword">short</s:term></s:list-item>
  <s:list-item><s:term type="keyword">sizeof</s:term></s:list-item>
  <s:list-item><s:term type="keyword">smooth</s:term></s:list-item>
  <s:list-item><s:term type="keyword">static</s:term></s:list-item>
  <s:list-item><s:term type="keyword">struct</s:term></s:list-item>
  <s:list-item><s:term type="keyword">subroutine</s:term></s:list-item>
  <s:list-item><s:term type="keyword">superp</s:term></s:list-item>
  <s:list-item><s:term type="keyword">switch</s:term></s:list-item>
  <s:list-item><s:term type="keyword">template</s:term></s:list-item>
  <s:list-item><s:term type="keyword">this</s:term></s:list-item>
  <s:list-item><s:term type="keyword">true</s:term></s:list-item>
  <s:list-item><s:term type="keyword">typedef</s:term></s:list-item>
  <s:list-item><s:term type="keyword">uimage1D</s:term></s:list-item>
  <s:list-item><s:term type="keyword">uimage1DArray</s:term></s:list-item>
  <s:list-item><s:term type="keyword">uimage2D</s:term></s:list-item>
  <s:list-item><s:term type="keyword">uimage2DArray</s:term></s:list-item>
  <s:list-item><s:term type="keyword">uimage2DMS</s:term></s:list-item>
  <s:list-item><s:term type="keyword">uimage2DMSArray</s:term></s:list-item>
  <s:list-item><s:term type="keyword">uimage2DRect</s:term></s:list-item>
  <s:list-item><s:term type="keyword">uimage3D</s:term></s:list-item>
  <s:list-item><s:term type="keyword">uimageBuffer</s:term></s:list-item>
  <s:list-item><s:term type="keyword">uimageCube</s:term></s:list-item>
  <s:list-item><s:term type="keyword">uimageCubeArray</s:term></s:list-item>
  <s:list-item><s:term type="keyword">uint</s:term></s:list-item>
  <s:list-item><s:term type="keyword">uniform</s:term></s:list-item>
  <s:list-item><s:term type="keyword">union</s:term></s:list-item>
  <s:list-item><s:term type="keyword">unsigned</s:term></s:list-item>
  <s:list-item><s:term type="keyword">usampler1D</s:term></s:list-item>
  <s:list-item><s:term type="keyword">usampler1DArray</s:term></s:list-item>
  <s:list-item><s:term type="keyword">usampler2D</s:term></s:list-item>
  <s:list-item><s:term type="keyword">usampler2DArray</s:term></s:list-item>
  <s:list-item><s:term type="keyword">usampler2DMS</s:term></s:list-item>
  <s:list-item><s:term type="keyword">usampler2DMSArray</s:term></s:list-item>
  <s:list-item><s:term type="keyword">usampler2DRect</s:term></s:list-item>
  <s:list-item><s:term type="keyword">usampler3D</s:term></s:list-item>
  <s:list-item><s:term type="keyword">usamplerBuffer</s:term></s:list-item>
  <s:list-item><s:term type="keyword">usamplerCube</s:term></s:list-item>
  <s:list-item><s:term type="keyword">usamplerCubeArray</s:term></s:list-item>
  <s:list-item><s:term type="keyword">using</s:term></s:list-item>
  <s:list-item><s:term type="keyword">uvec2</s:term></s:list-item>
  <s:list-item><s:term type="keyword">uvec3</s:term></s:list-item>
  <s:list-item><s:term type="keyword">uvec4</s:term></s:list-item>
  <s:list-item><s:term type="keyword">varying</s:term></s:list-item>
  <s:list-item><s:term type="keyword">vec2</s:term></s:list-item>
  <s:list-item><s:term type="keyword">vec3</s:term></s:list-item>
  <s:list-item><s:term type="keyword">vec4</s:term></s:list-item>
  <s:list-item><s:term type="keyword">void</s:term></s:list-item>
  <s:list-item><s:term type="keyword">volatile</s:term></s:list-item>
  <s:list-item><s:term type="keyword">while</s:term></s:list-item>
  <s:list-item><s:term type="keyword">writeonly</s:term></s:list-item>
</s:list-unordered>
      </s:formal-item>
    </s:section>

    <s:section>
      <s:section-title>Lists</s:section-title>
      <s:formal-item kind="lists">
        <s:formal-item-title>List of specifications</s:formal-item-title>
        <s:formal-item-list kind="specifications"/>
      </s:formal-item>
      <s:formal-item kind="lists">
        <s:formal-item-title>List of examples</s:formal-item-title>
        <s:formal-item-list kind="examples"/>
      </s:formal-item>
    </s:section>
  </s:part>

</s:document>
